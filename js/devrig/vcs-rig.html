<html>
  <head>
    <title>Daily VCS dev rig</title>
    <style>

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  font-size: 15px;
  background-color: #272627;
  color: black;
  margin: 0;
  padding: 0;
}

#mainContainer {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: row;
}

#leftSplit {
  width: 63%;
  min-width: 800px;
  height: 100%;
  flex: 0 0 auto;
  display: flex;
  flex-direction: column;
}

#rightSplit {
  height: 100%;
  flex: 1 0 0;
  background-color: black;
  color: #ddd;
  overflow-x: hidden;
  overflow-y: scroll;
}
#sceneDescPrintOut {
  padding: 1em;
  font-size: 12px;
  font-family: Menlo, monospace;
}
#sceneDescPrintOut h4 {
  margin: 0;
  margin-top: 1em;
}

#canvasContainer {
  flex: none;
  background-color: black;
  overflow: hidden;
  width: 640px;
  height: auto;
}
#deco {
  flex: none;
  margin-top: 1px;
  height: 62px;
  background-image: url('example-assets/atari_vcs_woodgrain_texture.png');
  display: flex;
  flex-direction: row;
  color: rgba(255, 255, 240, 0.7);
}
#deco > div {
  margin-top: 5px;
  padding: 1rem;
}
#compInfo {
  flex: 0 0 1;
  text-shadow: rgba(0, 0, 0, 0.4) 1px 1px;
  font-size: 1.05rem;
}
#compInfo .name {
  font-weight: 600;
  margin-bottom: 0.25em;
  display: inline-block;
}
#compInfo .description {
  font-weight: 300;
  font-size: 0.9em;
  opacity: 0.95;
  display: inline-block;
  margin-left: 2em;
}
#compOutput {
  flex: 1 0 auto;
  text-align: right;
}
#compOutput button {
  background: transparent;
  color: white;
}
#compOutput button.selected {
  background-color: coral;
}

#controls {
  flex: 1 0 auto;
  background-color: #474749;
  color: #eee;
  padding: 1rem;
  font-size: 14px;
  overflow-y: scroll;
}
#controls button {
  padding: 1px 6px;
}
#controls button.selected {
  background-color: coral;
}
#controls input[type=checkbox] {
  appearance: none;
  display: inline-block;
  width: 1.1em;
  height: 1.1em;
  border: 1px solid gray;
  outline: none;
  vertical-align: middle;
  position: relative;
  top: -2px;
}
#controls input[type=checkbox]:checked {
  background-color: coral;
}
#demoassets {
  display: none;
}
#controls h3 {
  margin: 0;
  margin-bottom: 0.5rem;
  font-size: 0.95rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.25);
}
#controls h4 {
  margin-top: 0.5rem;
  margin-right: 1rem;
  margin-bottom: 0;
  font-weight: normal;
}
#controls .compInterface {
  margin-top: 1.5em;
}
#controls .compInterface > div.params {
  margin-left: 1rem;
}
#controls .compInterface .params > div {
  margin-top: 0.35em;
}
#controls .compInterface .params > div > input[type=text] {
  display: inline-block;
  width: 30em;
  margin-left: 1em;
  background-color: rgba(90, 90, 90, 0.5);
  color: white;
}
#controls .compInterface .params select {
  min-width: 20em;
  margin-left: 1em;
}
#controls .videoInputButtons {
  display: inline-block;
  height: 4em;
}
#controls .videoInputButtons > div {
  display: inline-block;
  margin-left: 4px;
  width: 2.3em;
  height: 100%;
}
#controls .videoInputButtons > div > div {
  display: flex;
  flex-direction: column;
  height: 100%;
}
#controls .videoInputButtons > div > div button {
  width: 100%;
}
#controls .videoInputButtons > div > div button.dominant {
  opacity: 85%;
}
#controls .videoInputButtons > div > div button.screenshare {
  opacity: 78%;
}

    </style>
  </head>

  <body>
    <div id="mainContainer">
      <div id="leftSplit">
        <div id="canvasContainer">
          <canvas id="renderCanvas" width="640" height="360" />
        </div>
        <div id="deco">
          <div id="compInfo">
            <div class="name"></div>
            <div class="description"></div>
          </div>
          <div id="compOutput">
            <span>Output:</span>
            <span>
              <button class="selected" data-outputid="landscape">16:9</button><button data-outputid="square">Square</button><button data-outputid="portrait">9:16</button>
            </span>
          </div>
        </div>
        <div id="controls">
          <div class="vc">
            <h3>Media input</h3>
            <span>Active video inputs: </span>
            <span class="videoInputButtons"></span>
          </div>
          <div class="compInterface">
            <h3>Composition interface</h3>
            <h4>Params:</h4>
            <div class="params"></div>
          </div>
        </div>  
      </div>
      <div id="rightSplit">
        <div id="sceneDescPrintOut">
          Loading...
        </div>
      </div>
    </div>

    <div id="demoassets">
      <img id="demoperson_missfury" src="example-assets/demoperson_missfury.png" />
      <img id="demoperson_moongirl" src="example-assets/demoperson_moongirl.png" />
      <img id="demoperson_yellowkid" src="example-assets/demoperson_yellowkid.png" />
      <img id="screenshare_standin" src="example-assets/screenshare_standin_1600x900.png" />
    </div>
  </body>

<script>

// --- UI state ---

const MAX_VIDEO_INPUTS = 16;

const g_activeVideoInputSlots = [];
let g_dominantIdx = -1;

for (let i = 0; i < MAX_VIDEO_INPUTS; i++) {
  setActiveVideoInput(i, false);
}
setActiveVideoInput(0, true);

function getVideoInputIdForSlotIndex(idx) {
  if (idx === 0) return 'devlivecam0';
  return 'devinput'+idx;
}

function setActiveVideoInput(idx, active, isScreenshare) {
  g_activeVideoInputSlots[idx] = {
    id: getVideoInputIdForSlotIndex(idx),
    active: !!active,
    type: isScreenshare ? 'screenshare' : 'camera',
  };
}

let g_paramValues = {};


// --- UI actions ---

function participantToggled(ev) {
  const btn = ev.target;
  const idx = parseInt(btn.dataset.index, 10);

  const active = g_activeVideoInputSlots[idx].active ? false : true;
  btn.setAttribute('class', active ? 'selected' : '');

  g_activeVideoInputSlots[idx].active = active;

  sendActiveVideoInputSlots();
}

function dominantToggled(ev) {
  const btn = ev.target;
  const idx = parseInt(btn.dataset.index, 10);

  g_dominantIdx = (idx === g_dominantIdx) ? -1 : idx;

  console.log("dominant now ", g_dominantIdx)

  sendActiveVideoInputSlots();
  
  createVideoInputsUI();
}

function screenshareToggled(ev) {
  const btn = ev.target;
  const idx = parseInt(btn.dataset.index, 10);

  const s = g_activeVideoInputSlots[idx].type !== 'screenshare';

  setActiveVideoInput(idx, g_activeVideoInputSlots[idx].active, s);

  sendActiveVideoInputSlots();

  // for any screenshares, replace the default source with a screenshare input
  let sources = {...g_defaultSources};
  sources.videos = g_defaultSources.videos.slice();

  const ssImageEl = document.getElementById('screenshare_standin');
  for (let i = 0; i < MAX_VIDEO_INPUTS; i++) {
    if (g_activeVideoInputSlots[i].type !== 'screenshare') continue;

    sources.videos.splice(i, 1, ssImageEl);
  }

  sendUpdateImageSources(sources);
  
  createVideoInputsUI();
}

function paramCheckboxToggled(ev) {
  const btn = ev.target;
  const paramId = btn.dataset.paramId;
  if (!paramId || paramId.length < 1) {
    alert("Missing paramId");
    return;
  }
  const newValue = btn.checked === true;

  sendParam(paramId, newValue);
}

function paramTextEdited(ev) {
  const field = ev.target;
  const paramId = field.dataset.paramId;
  if (!paramId || paramId.length < 1) {
    alert("Missing paramId");
    return;
  }
  const newValue = field.value || '';

  sendParam(paramId, newValue);
}

function paramEnumSelected(ev) {
  const sel = ev.target;
  const paramId = sel.dataset.paramId;
  if (!paramId || paramId.length < 1) {
    alert("Missing paramId");
    return;
  }
  const opt = sel.options[sel.selectedIndex];
  const newValue = opt.value || '';

  sendParam(paramId, newValue);
}

function createParamsUI(compInterface, box) {
  for (const paramDesc of compInterface.params) {
    const {id, type, defaultValue} = paramDesc;
    let el;
    let posLeft = false;
    switch (type) {
      default:
        console.warn("** unsupported param type from composition: '%s'", type);
        break;

      case 'boolean':
        el = document.createElement('input');
        el.setAttribute('type', 'checkbox');
        if (defaultValue) el.setAttribute('checked', true);

        el.addEventListener('change', paramCheckboxToggled);
        posLeft = true;
        break;

      case 'text':
        el = document.createElement('input');
        el.setAttribute('type', 'text');
        if (defaultValue) el.setAttribute('value', defaultValue);

        el.addEventListener('change', paramTextEdited);
        break;

      case 'enum':
        el = document.createElement('select');
        createEnumUI(paramDesc.values || [], id, el);

        if (defaultValue) {
          // TODO: select default item
        }
        
        el.addEventListener('change', paramEnumSelected);
        break;
    }

    if (el) {
      el.setAttribute('data-param-id', id);

      const div = document.createElement('div');
      const label = document.createElement('label');
      label.innerText = id || '<No id provided>';
      
      if (posLeft) {
        div.appendChild(el);
        div.appendChild(label);
      } else {
        div.appendChild(label);
        div.appendChild(el);
      }
      box.appendChild(div);
    }
  }
}

function createEnumUI(enumValues, paramId, sel) {
  let child;
  while ((child = sel.firstChild)) {
    sel.removeChild(child);
  }

  let firstId;
  for (const val of enumValues) {
    const opt = document.createElement('option');
    opt.setAttribute('value', val);
    opt.innerText = val;
    sel.appendChild(opt);

    if ( !firstId) firstId = val;
  }
  if ( !firstId) {
    // TODO: add a placeholder item
  }
}

function createVideoInputsUI() {
  const mainBox = document.querySelector("#controls .videoInputButtons");

  let child;
  while ((child = mainBox.firstChild)) {
    mainBox.removeChild(child);
  }

  const n = MAX_VIDEO_INPUTS;
  for (i = 0; i < n; i++) {
    const active = g_activeVideoInputSlots[i].active;
    const screenshare = g_activeVideoInputSlots[i].type === 'screenshare';
    const dominant = g_dominantIdx === i;

    const box = document.createElement('div');
    const flexbox = document.createElement('div');

    const btn = document.createElement('button');
    btn.setAttribute('data-index', i);
    btn.innerText = ""+(i + 1);
    box.appendChild(btn);

    let cls = '';
    if (active) cls += 'selected';
    btn.className = cls;
    
    btn.addEventListener('click', participantToggled);

    const domBtn = document.createElement('button');
    domBtn.setAttribute('data-index', i);
    domBtn.setAttribute('data-video-dominant', true);
    domBtn.innerText = "D";
    box.appendChild(domBtn);

    cls = 'dominant';
    if (dominant) cls += ' selected';
    domBtn.className = cls;

    domBtn.addEventListener('click', dominantToggled);

    const sBtn = document.createElement('button');
    sBtn.setAttribute('data-index', i);
    sBtn.setAttribute('data-video-screenshare', true);
    sBtn.innerText = "S";
    box.appendChild(sBtn);

    cls = 'screenshare';
    if (screenshare) cls += ' selected';
    sBtn.className = cls;

    sBtn.addEventListener('click', screenshareToggled);

    flexbox.appendChild(box);
    mainBox.appendChild(flexbox);
  }
}

createVideoInputsUI();


// --- setup rendering ---

let g_viewportSize = { w: 1280, h: 720 };

let g_canvas = document.getElementById("renderCanvas");

let g_vcsApi;


async function setupLiveVideo() {
  // this video element will be used as a drawable source when rendering to canvas
  let liveVideoEl;

  try {
    const mediaStream = await navigator.mediaDevices.getUserMedia(
      { video: {width: 1280, height: 720},
        audio: false
      }
    );
    console.log("got mediaStream: ", mediaStream);

    liveVideoEl = document.createElement('video');
    liveVideoEl.setAttribute('muted', true);
    liveVideoEl.setAttribute('autoPlay', true);
    liveVideoEl.srcObject = mediaStream;

    // place element in DOM so it gets updates
    liveVideoEl.setAttribute('style', "display: none;");
    g_canvas.parentElement.appendChild(liveVideoEl);
  } catch (e) {
    console.error("** getUserMedia failed: ", e);
    alert("Live video not available, getUserMedia failed:\n\n"+e);
  }
  return liveVideoEl;
}

async function loadTestImages() {
  const exampleAssets = [
    { name: 'test_square', file: 'test_square_320px.png' },
  ];

  const promises = [];
  for (const ea of exampleAssets) {
    promises.push(new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        resolve({name: ea.name, image: img});
      };
      img.onerror = () => {
        const msg = `Image load failed, asset ${ea.file}`;
        console.error(msg);
        reject(new Error(msg));
      };
      img.src = `example-assets/${ea.file}`;
    }));
  }

  const results = await Promise.all(promises);
  const imagesByName = {};
  for (const item of results) {
    imagesByName[item.name] = item.image;
  }
  return imagesByName;
}

const demoPeople = [
  document.getElementById('demoperson_missfury'),
  document.getElementById('demoperson_moongirl'),
  document.getElementById('demoperson_yellowkid'),
];

let g_defaultSources = {}; // initialized in start

async function start() {
  const liveVideoEl = await setupLiveVideo();
  const testImages = await loadTestImages();

  // build the video sources map.
  // live video goes in the first slot, rest are public domain images.
  const videoInputElements = [];
  videoInputElements[0] = {
    id: getVideoInputIdForSlotIndex(0),
    element: liveVideoEl,
  };
  for (let i = 1; i < MAX_VIDEO_INPUTS; i++) {
    videoInputElements.push({
      id: getVideoInputIdForSlotIndex(i),
      element: demoPeople[ (i - 1) % demoPeople.length ]
    });
  }

  g_defaultSources = {
    videoSlots: videoInputElements,
    compositionAssetImages: testImages,
  };

  console.log("--- awaiting DailyVCS start ---");

  await recreateVCSCanvasOutput();

  console.log("### start done.")

  // print composition info
  const compInterface = g_vcsApi.getCompositionInterface();
  const {displayMeta} = compInterface;

  console.log("composition metadata: ", displayMeta);

  document.querySelector("#compInfo .name").innerHTML = displayMeta.name;
  document.querySelector("#compInfo .description").innerHTML = displayMeta.description;

  // create composition UI
  createParamsUI(compInterface, document.querySelector("#controls .compInterface .params"));
}

window.addEventListener('load', function(ev) {
  start();
});

for (const el of document.querySelectorAll("#compOutput button")) {
  el.addEventListener('click', outputIdChanged);
}

function outputIdChanged(ev) {
  const btn = ev.target;
  const outputId = btn.dataset.outputid;

  const btns = {
    landscape: document.querySelector("#compOutput button[data-outputid='landscape']"),
    square:    document.querySelector("#compOutput button[data-outputid='square']"),
    portrait:  document.querySelector("#compOutput button[data-outputid='portrait']"),
  };
  for (const key in btns) {
    btns[key].className = '';
  }
  btns[outputId].className = 'selected';

  let newViewport;
  switch (outputId) {
    case 'landscape':
      newViewport = {w: 1280, h: 720}; break;

    case 'square':
      newViewport = {w: 720, h: 720}; break;      

    case 'portrait':
      newViewport = {w: 720, h: 1280}; break;
  }
  g_viewportSize = newViewport;

  let parent = g_canvas.parentElement;
  let scale = 0.5;

  parent.removeChild(g_canvas);

  g_canvas = document.createElement('canvas');
  g_canvas.width = g_viewportSize.w * scale;
  g_canvas.height = g_viewportSize.h * scale;
  parent.appendChild(g_canvas);

  parent.style = `width: ${g_canvas.width}px;`;

  recreateVCSCanvasOutput();
}

async function recreateVCSCanvasOutput() {
  let enablePreload = true;

  if (g_vcsApi) {
    stopVCS();

    enablePreload = false; // don't preload again
  }

  g_vcsApi = await DailyVCS.startCanvasOutputAsync(
    g_viewportSize.w, g_viewportSize.h,
    g_canvas, g_defaultSources, compUpdated,
    {enablePreload});

  sendActiveVideoInputSlots();

  for (const key in g_paramValues) {
    sendParam(key, g_paramValues[key]);
  }
}

function stopVCS() {
  console.log("stopping existing VCS renderer");

  g_vcsApi.stop();
}


// --- callback received from composition ---

function compUpdated(sceneDesc) {
  if ( !sceneDesc) return;

  //console.log("scene desc JSON: ", JSON.stringify(sceneDesc));

  const printoutEl = document.getElementById("sceneDescPrintOut");

  let html = '';

  html += "<h4>videoLayers:</h4><br>";
  for (const item of sceneDesc.videoLayers) {
    const json = JSON.stringify(item);
    html += `${json}<br>`;
  }
  
  html += "<h4>fgDisplayList:</h4><br>";
  for (const cmd of sceneDesc.fgDisplayList.commands) {
    const json = JSON.stringify(cmd);
    html += `${json}<br>`;
  }

  printoutEl.innerHTML = html;
}


// --- commands sent to composition ---

function sendActiveVideoInputSlots() {
  if (!g_vcsApi) return;

  const arr = [];
  for (let i = 0; i < g_activeVideoInputSlots.length; i++) {
    let obj = g_activeVideoInputSlots[i];
    if (obj.active) {
      obj = {...obj};
      if (i === g_dominantIdx) {
        obj.dominant = true;
      }
      arr.push(obj);
    } else {
      arr.push(false);
    }
  }

  g_vcsApi.setActiveVideoInputSlots(arr);
}

function sendParam(paramId, value) {
  if (!g_vcsApi) return;

  g_vcsApi.setParamValue(paramId, value);

  // retain a copy of param values so we can reset renderer to the same state
  g_paramValues[paramId] = value;
}

function sendUpdateImageSources(srcs) {
  if (!g_vcsApi) return;

  g_vcsApi.updateImageSources(srcs);
}

</script>
</html>
