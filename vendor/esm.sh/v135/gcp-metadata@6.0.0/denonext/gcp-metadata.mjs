/* esm.sh - esbuild bundle(gcp-metadata@6.0.0) denonext production */
import __Process$ from "node:process";
import * as __0$ from "/v135/gaxios@6.1.1/denonext/gaxios.mjs";
import * as __1$ from "/v135/json-bigint@1.0.0/denonext/json-bigint.mjs";
import * as __2$ from "node:fs";
import * as __3$ from "node:os";
var require=n=>{const e=m=>typeof m.default<"u"?m.default:m,c=m=>Object.assign({},m);switch(n){case"gaxios":return c(__0$);case"json-bigint":return e(__1$);case"fs":return e(__2$);case"os":return e(__3$);default:throw new Error("module \""+n+"\" not found");}};
var M=Object.create;var _=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var B=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var d=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var g=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),L=(e,t)=>{for(var r in t)_(e,r,{get:t[r],enumerable:!0})},A=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of w(t))!j.call(e,s)&&s!==r&&_(e,s,{get:()=>t[s],enumerable:!(i=P(t,s))||i.enumerable});return e},u=(e,t,r)=>(A(e,t,"default"),r&&A(r,t,"default")),D=(e,t,r)=>(r=e!=null?M(B(e)):{},A(t||!e||!e.__esModule?_(r,"default",{value:e,enumerable:!0}):r,e));var f=g(o=>{"use strict";Object.defineProperty(o,"__esModule",{value:!0});o.detectGCPResidency=o.isGoogleComputeEngine=o.isGoogleComputeEngineMACAddress=o.isGoogleComputeEngineLinux=o.isGoogleCloudServerless=o.GCE_LINUX_BIOS_PATHS=void 0;var O=d("fs"),y=d("os");o.GCE_LINUX_BIOS_PATHS={BIOS_DATE:"/sys/class/dmi/id/bios_date",BIOS_VENDOR:"/sys/class/dmi/id/bios_vendor"};var q=/^42:01/;function h(){return!!(__Process$.env.CLOUD_RUN_JOB||__Process$.env.FUNCTION_NAME||__Process$.env.K_SERVICE)}o.isGoogleCloudServerless=h;function v(){if((0,y.platform)()!=="linux")return!1;try{(0,O.statSync)(o.GCE_LINUX_BIOS_PATHS.BIOS_DATE);let e=(0,O.readFileSync)(o.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR,"utf8");return/Google/.test(e)}catch{return!1}}o.isGoogleComputeEngineLinux=v;function m(){let e=(0,y.networkInterfaces)();for(let t of Object.values(e))if(t){for(let{mac:r}of t)if(q.test(r))return!0}return!1}o.isGoogleComputeEngineMACAddress=m;function G(){return v()||m()}o.isGoogleComputeEngine=G;function U(){return h()||G()}o.detectGCPResidency=U});var S=g(n=>{"use strict";var V=n&&n.__createBinding||(Object.create?function(e,t,r,i){i===void 0&&(i=r);var s=Object.getOwnPropertyDescriptor(t,r);(!s||("get"in s?!t.__esModule:s.writable||s.configurable))&&(s={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,i,s)}:function(e,t,r,i){i===void 0&&(i=r),e[i]=t[r]}),$=n&&n.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&V(t,e,r)};Object.defineProperty(n,"__esModule",{value:!0});n.requestTimeout=n.setGCPResidency=n.getGCPResidency=n.gcpResidencyCache=n.resetIsAvailableCache=n.isAvailable=n.project=n.instance=n.METADATA_SERVER_DETECTION=n.HEADERS=n.HEADER_VALUE=n.HEADER_NAME=n.SECONDARY_HOST_ADDRESS=n.HOST_ADDRESS=n.BASE_PATH=void 0;var p=d("gaxios"),x=d("json-bigint"),F=f();n.BASE_PATH="/computeMetadata/v1";n.HOST_ADDRESS="http://169.254.169.254";n.SECONDARY_HOST_ADDRESS="http://metadata.google.internal.";n.HEADER_NAME="Metadata-Flavor";n.HEADER_VALUE="Google";n.HEADERS=Object.freeze({[n.HEADER_NAME]:n.HEADER_VALUE});n.METADATA_SERVER_DETECTION=Object.freeze({"assume-present":"don't try to ping the metadata server, but assume it's present",none:"don't try to ping the metadata server, but don't try to use it either","bios-only":"treat the result of a BIOS probe as canonical (don't fall back to pinging)","ping-only":"skip the BIOS probe, and go straight to pinging"});function C(e){return e||(e=__Process$.env.GCE_METADATA_IP||__Process$.env.GCE_METADATA_HOST||n.HOST_ADDRESS),/^https?:\/\//.test(e)||(e=`http://${e}`),new URL(n.BASE_PATH,e).href}function X(e){Object.keys(e).forEach(t=>{switch(t){case"params":case"property":case"headers":break;case"qs":throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");default:throw new Error(`'${t}' is not a valid configuration option.`)}})}async function R(e,t,r=3,i=!1){t=t||{},typeof t=="string"&&(t={property:t});let s="";typeof t=="object"&&t.property&&(s="/"+t.property),X(t);try{let c=await(i?W:p.request)({url:`${C()}/${e}${s}`,headers:Object.assign({},n.HEADERS,t.headers),retryConfig:{noResponseRetries:r},params:t.params,responseType:"text",timeout:H()});if(c.headers[n.HEADER_NAME.toLowerCase()]!==n.HEADER_VALUE)throw new Error(`Invalid response from metadata service: incorrect ${n.HEADER_NAME} header.`);if(!c.data)throw new Error("Invalid response from the metadata service");if(typeof c.data=="string")try{return x.parse(c.data)}catch{}return c.data}catch(a){let c=a;throw c.response&&c.response.status!==200&&(c.message=`Unsuccessful response status code. ${c.message}`),a}}async function W(e){let t={...e,url:e.url.replace(C(),C(n.SECONDARY_HOST_ADDRESS))},r=!1,i=(0,p.request)(e).then(a=>(r=!0,a)).catch(a=>{if(r)return s;throw r=!0,a}),s=(0,p.request)(t).then(a=>(r=!0,a)).catch(a=>{if(r)return i;throw r=!0,a});return Promise.race([i,s])}function Y(e){return R("instance",e)}n.instance=Y;function z(e){return R("project",e)}n.project=z;function K(){return __Process$.env.DETECT_GCP_RETRIES?Number(__Process$.env.DETECT_GCP_RETRIES):0}var l;async function J(){if(__Process$.env.METADATA_SERVER_DETECTION){let e=__Process$.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();if(!(e in n.METADATA_SERVER_DETECTION))throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${e}\`, but it should be \`${Object.keys(n.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);switch(e){case"assume-present":return!0;case"none":return!1;case"bios-only":return T();case"ping-only":}}try{return l===void 0&&(l=R("instance",void 0,K(),!(__Process$.env.GCE_METADATA_IP||__Process$.env.GCE_METADATA_HOST))),await l,!0}catch(e){let t=e;if(__Process$.env.DEBUG_AUTH&&console.info(t),t.type==="request-timeout"||t.response&&t.response.status===404)return!1;if(!(t.response&&t.response.status===404)&&(!t.code||!["EHOSTDOWN","EHOSTUNREACH","ENETUNREACH","ENOENT","ENOTFOUND","ECONNREFUSED"].includes(t.code))){let r="UNKNOWN";t.code&&(r=t.code),__Process$.emitWarning(`received unexpected error = ${t.message} code = ${r}`,"MetadataLookupWarning")}return!1}}n.isAvailable=J;function k(){l=void 0}n.resetIsAvailableCache=k;n.gcpResidencyCache=null;function T(){return n.gcpResidencyCache===null&&N(),n.gcpResidencyCache}n.getGCPResidency=T;function N(e=null){n.gcpResidencyCache=e!==null?e:(0,F.detectGCPResidency)()}n.setGCPResidency=N;function H(){return T()?0:3e3}n.requestTimeout=H;$(f(),n)});var E={};L(E,{BASE_PATH:()=>Ae,GCE_LINUX_BIOS_PATHS:()=>Te,HEADERS:()=>ce,HEADER_NAME:()=>ue,HEADER_VALUE:()=>Ee,HOST_ADDRESS:()=>le,METADATA_SERVER_DETECTION:()=>ae,SECONDARY_HOST_ADDRESS:()=>de,__esModule:()=>Q,default:()=>ge,detectGCPResidency:()=>_e,gcpResidencyCache:()=>ne,getGCPResidency:()=>te,instance:()=>ie,isAvailable:()=>se,isGoogleCloudServerless:()=>Re,isGoogleComputeEngine:()=>fe,isGoogleComputeEngineLinux:()=>Ce,isGoogleComputeEngineMACAddress:()=>pe,project:()=>oe,requestTimeout:()=>Z,resetIsAvailableCache:()=>re,setGCPResidency:()=>ee});var b=D(S());u(E,D(S()));var{__esModule:Q,requestTimeout:Z,setGCPResidency:ee,getGCPResidency:te,gcpResidencyCache:ne,resetIsAvailableCache:re,isAvailable:se,project:oe,instance:ie,METADATA_SERVER_DETECTION:ae,HEADERS:ce,HEADER_VALUE:Ee,HEADER_NAME:ue,SECONDARY_HOST_ADDRESS:de,HOST_ADDRESS:le,BASE_PATH:Ae,detectGCPResidency:_e,isGoogleComputeEngine:fe,isGoogleComputeEngineMACAddress:pe,isGoogleComputeEngineLinux:Ce,isGoogleCloudServerless:Re,GCE_LINUX_BIOS_PATHS:Te}=b,{default:I,...Se}=b,ge=I!==void 0?I:Se;export{Ae as BASE_PATH,Te as GCE_LINUX_BIOS_PATHS,ce as HEADERS,ue as HEADER_NAME,Ee as HEADER_VALUE,le as HOST_ADDRESS,ae as METADATA_SERVER_DETECTION,de as SECONDARY_HOST_ADDRESS,Q as __esModule,ge as default,_e as detectGCPResidency,ne as gcpResidencyCache,te as getGCPResidency,ie as instance,se as isAvailable,Re as isGoogleCloudServerless,fe as isGoogleComputeEngine,Ce as isGoogleComputeEngineLinux,pe as isGoogleComputeEngineMACAddress,oe as project,Z as requestTimeout,re as resetIsAvailableCache,ee as setGCPResidency};
//# sourceMappingURL=gcp-metadata.mjs.map