/* esm.sh - esbuild bundle(langsmith@0.1.39/run_trees) denonext production */
import __Process$ from "node:process";
import*as Y from"/v135/uuid@9.0.1/denonext/uuid.mjs";import*as N from"/v135/uuid@9.0.1/denonext/uuid.mjs";import te from"/v135/p-retry@4.6.2/denonext/p-retry.mjs";import I from"/v135/p-queue@6.6.2/denonext/p-queue.mjs";var ie=[400,401,403,404,405,406,407,408],re=[409],T=class{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"onFailedResponseHook",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6,"default"in I?this.queue=new I.default({concurrency:this.maxConcurrency}):this.queue=new I({concurrency:this.maxConcurrency}),this.onFailedResponseHook=e?.onFailedResponseHook}call(e,...t){let i=this.onFailedResponseHook;return this.queue.add(()=>te(()=>e(...t).catch(r=>{throw r instanceof Error?r:new Error(r)}),{async onFailedAttempt(r){if(r.message.startsWith("Cancel")||r.message.startsWith("TimeoutError")||r.message.startsWith("AbortError")||r?.code==="ECONNABORTED")throw r;let a=r?.response,s=a?.status;if(s){if(ie.includes(+s))throw r;if(re.includes(+s))return;i&&await i(a)}},retries:this.maxRetries,randomize:!0}),{throwOnTimeout:!0})}callWithOptions(e,t,...i){return e.signal?Promise.race([this.call(t,...i),new Promise((r,a)=>{e.signal?.addEventListener("abort",()=>{a(new Error("AbortError"))})})]):this.call(t,...i)}fetch(...e){return this.call(()=>fetch(...e).then(t=>t.ok?t:Promise.reject(t)))}};function U(o){return typeof o?._getType=="function"}function k(o){let e={type:o._getType(),data:{content:o.content}};return o?.additional_kwargs&&Object.keys(o.additional_kwargs).length>0&&(e.data.additional_kwargs={...o.additional_kwargs}),e}import*as J from"/v135/uuid@9.0.1/denonext/uuid.mjs";function p(o){if(!J.validate(o))throw new Error(`Invalid UUID: ${o}`)}var V={};function A(o){V[o]||(console.warn(o),V[o]=!0)}async function z(o){let e=await C(),t=K();return o.map(i=>{let r=i.extra??{},a=r.metadata;return i.extra={...r,runtime:{...e,...r?.runtime},metadata:{...t,...t.revision_id||i.revision_id?{revision_id:i.revision_id??t.revision_id}:{},...a}},i})}var ae=()=>{let o=_("LANGCHAIN_TRACING_SAMPLING_RATE");if(o===void 0)return;let e=parseFloat(o);if(e<0||e>1)throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${e}`);return e},se=o=>{let t=o.replace("http://","").replace("https://","").split("/")[0].split(":")[0];return t==="localhost"||t==="127.0.0.1"||t==="::1"},v=async(o,e)=>{let t=await o.text();if(!o.ok)throw new Error(`Failed to ${e}: ${o.status} ${o.statusText} ${t}`)};async function ne(o){let e=[];for await(let t of o)e.push(t);return e}function x(o){if(o!==void 0)return o.trim().replace(/^"(.*)"$/,"$1").replace(/^'(.*)'$/,"$1")}var oe=async o=>{if(o?.status===429){let e=parseInt(o.headers.get("retry-after")??"30",10)*1e3;if(e>0)return await new Promise(t=>setTimeout(t,e)),!0}return!1},L=class{constructor(){Object.defineProperty(this,"items",{enumerable:!0,configurable:!0,writable:!0,value:[]})}get size(){return this.items.length}push(e){return new Promise(t=>{this.items.push([e,t])})}pop(e){if(e<1)throw new Error("Number of items to pop off may not be less than 1.");let t=[];for(;t.length<e&&this.items.length;){let i=this.items.shift();if(i)t.push(i);else break}return[t.map(i=>i[0]),()=>t.forEach(i=>i[1]())]}},ue=20971520,j=class o{constructor(e={}){Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"webUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"batchIngestCaller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"timeout_ms",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_tenantId",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"hideInputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hideOutputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tracingSampleRate",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sampledPostUuids",{enumerable:!0,configurable:!0,writable:!0,value:new Set}),Object.defineProperty(this,"autoBatchTracing",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"batchEndpointSupported",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoBatchQueue",{enumerable:!0,configurable:!0,writable:!0,value:new L}),Object.defineProperty(this,"pendingAutoBatchedRunLimit",{enumerable:!0,configurable:!0,writable:!0,value:100}),Object.defineProperty(this,"autoBatchTimeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoBatchInitialDelayMs",{enumerable:!0,configurable:!0,writable:!0,value:250}),Object.defineProperty(this,"autoBatchAggregationDelayMs",{enumerable:!0,configurable:!0,writable:!0,value:50}),Object.defineProperty(this,"serverInfo",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fetchOptions",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=o.getDefaultClientConfig();this.tracingSampleRate=ae(),this.apiUrl=x(e.apiUrl??t.apiUrl)??"",this.apiKey=x(e.apiKey??t.apiKey),this.webUrl=x(e.webUrl??t.webUrl),this.timeout_ms=e.timeout_ms??12e3,this.caller=new T(e.callerOptions??{}),this.batchIngestCaller=new T({...e.callerOptions??{},onFailedResponseHook:oe}),this.hideInputs=e.hideInputs??e.anonymizer??t.hideInputs,this.hideOutputs=e.hideOutputs??e.anonymizer??t.hideOutputs,this.autoBatchTracing=e.autoBatchTracing??this.autoBatchTracing,this.pendingAutoBatchedRunLimit=e.pendingAutoBatchedRunLimit??this.pendingAutoBatchedRunLimit,this.fetchOptions=e.fetchOptions||{}}static getDefaultClientConfig(){let e=_("LANGCHAIN_API_KEY"),t=_("LANGCHAIN_ENDPOINT")??"https://api.smith.langchain.com",i=_("LANGCHAIN_HIDE_INPUTS")==="true",r=_("LANGCHAIN_HIDE_OUTPUTS")==="true";return{apiUrl:t,apiKey:e,webUrl:void 0,hideInputs:i,hideOutputs:r}}getHostUrl(){return this.webUrl?this.webUrl:se(this.apiUrl)?(this.webUrl="http://localhost:3000",this.webUrl):this.apiUrl.includes("/api")&&!this.apiUrl.split(".",1)[0].endsWith("api")?(this.webUrl=this.apiUrl.replace("/api",""),this.webUrl):this.apiUrl.split(".",1)[0].includes("dev")?(this.webUrl="https://dev.smith.langchain.com",this.webUrl):this.apiUrl.split(".",1)[0].includes("eu")?(this.webUrl="https://eu.smith.langchain.com",this.webUrl):(this.webUrl="https://smith.langchain.com",this.webUrl)}get headers(){let e={"User-Agent":`langsmith-js/${$}`};return this.apiKey&&(e["x-api-key"]=`${this.apiKey}`),e}processInputs(e){return this.hideInputs===!1?e:this.hideInputs===!0?{}:typeof this.hideInputs=="function"?this.hideInputs(e):e}processOutputs(e){return this.hideOutputs===!1?e:this.hideOutputs===!0?{}:typeof this.hideOutputs=="function"?this.hideOutputs(e):e}prepareRunCreateOrUpdateInputs(e){let t={...e};return t.inputs!==void 0&&(t.inputs=this.processInputs(t.inputs)),t.outputs!==void 0&&(t.outputs=this.processOutputs(t.outputs)),t}async _getResponse(e,t){let i=t?.toString()??"",r=`${this.apiUrl}${e}?${i}`,a=await this.caller.call(fetch,r,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!a.ok)throw new Error(`Failed to fetch ${e}: ${a.status} ${a.statusText}`);return a}async _get(e,t){return(await this._getResponse(e,t)).json()}async*_getPaginated(e,t=new URLSearchParams){let i=Number(t.get("offset"))||0,r=Number(t.get("limit"))||100;for(;;){t.set("offset",String(i)),t.set("limit",String(r));let a=`${this.apiUrl}${e}?${t}`,s=await this.caller.call(fetch,a,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!s.ok)throw new Error(`Failed to fetch ${e}: ${s.status} ${s.statusText}`);let n=await s.json();if(n.length===0||(yield n,n.length<r))break;i+=n.length}}async*_getCursorPaginatedList(e,t=null,i="POST",r="runs"){let a=t?{...t}:{};for(;;){let n=await(await this.caller.call(fetch,`${this.apiUrl}${e}`,{method:i,headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:JSON.stringify(a)})).json();if(!n||!n[r])break;yield n[r];let u=n.cursors;if(!u||!u.next)break;a.cursor=u.next}}_filterForSampling(e,t=!1){if(this.tracingSampleRate===void 0)return e;if(t){let i=[];for(let r of e)this.sampledPostUuids.has(r.id)&&(i.push(r),this.sampledPostUuids.delete(r.id));return i}else{let i=[];for(let r of e)Math.random()<this.tracingSampleRate&&(i.push(r),this.sampledPostUuids.add(r.id));return i}}async drainAutoBatchQueue(){for(;this.autoBatchQueue.size>=0;){let[e,t]=this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);if(!e.length){t();return}try{await this.batchIngestRuns({runCreates:e.filter(i=>i.action==="create").map(i=>i.item),runUpdates:e.filter(i=>i.action==="update").map(i=>i.item)})}finally{t()}}}async processRunOperation(e,t){let i=this.autoBatchTimeout;clearTimeout(this.autoBatchTimeout),this.autoBatchTimeout=void 0;let r=this.autoBatchQueue.push(e);return(t||this.autoBatchQueue.size>this.pendingAutoBatchedRunLimit)&&await this.drainAutoBatchQueue(),this.autoBatchQueue.size>0&&(this.autoBatchTimeout=setTimeout(()=>{this.autoBatchTimeout=void 0,this.drainAutoBatchQueue().catch(console.error)},i?this.autoBatchAggregationDelayMs:this.autoBatchInitialDelayMs)),r}async _getServerInfo(){let e=await fetch(`${this.apiUrl}/info`,{method:"GET",headers:{Accept:"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!e.ok)throw await e.text(),new Error("Failed to retrieve server info.");return e.json()}async batchEndpointIsSupported(){try{this.serverInfo=await this._getServerInfo()}catch{return!1}return!0}async createRun(e){if(!this._filterForSampling([e]).length)return;let t={...this.headers,"Content-Type":"application/json"},i=e.project_name;delete e.project_name;let r=this.prepareRunCreateOrUpdateInputs({session_name:i,...e,start_time:e.start_time??Date.now()});if(this.autoBatchTracing&&r.trace_id!==void 0&&r.dotted_order!==void 0){this.processRunOperation({action:"create",item:r}).catch(console.error);return}let a=await z([r]),s=await this.caller.call(fetch,`${this.apiUrl}/runs`,{method:"POST",headers:t,body:JSON.stringify(a[0]),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(s,"create run")}async batchIngestRuns({runCreates:e,runUpdates:t}){if(e===void 0&&t===void 0)return;let i=e?.map(d=>this.prepareRunCreateOrUpdateInputs(d))??[],r=t?.map(d=>this.prepareRunCreateOrUpdateInputs(d))??[];if(i.length>0&&r.length>0){let d=i.reduce((l,c)=>(c.id&&(l[c.id]=c),l),{}),h=[];for(let l of r)l.id!==void 0&&d[l.id]?d[l.id]={...d[l.id],...l}:h.push(l);i=Object.values(d),r=h}let a={post:this._filterForSampling(i),patch:this._filterForSampling(r,!0)};if(!a.post.length&&!a.patch.length)return;if(i=await z(i),this.batchEndpointSupported===void 0&&(this.batchEndpointSupported=await this.batchEndpointIsSupported()),!this.batchEndpointSupported){this.autoBatchTracing=!1;for(let d of a.post)await this.createRun(d);for(let d of a.patch)d.id!==void 0&&await this.updateRun(d.id,d);return}let s=this.serverInfo?.batch_ingest_config?.size_limit_bytes??ue,n={post:[],patch:[]},u=0;for(let d of["post","patch"]){let h=d,l=a[h].reverse(),c=l.pop();for(;c!==void 0;){let m=JSON.stringify(c);u>0&&u+m.length>s&&(await this._postBatchIngestRuns(JSON.stringify(n)),u=0,n.post=[],n.patch=[]),u+=m.length,n[h].push(c),c=l.pop()}}(n.post.length>0||n.patch.length>0)&&await this._postBatchIngestRuns(JSON.stringify(n))}async _postBatchIngestRuns(e){let t={...this.headers,"Content-Type":"application/json",Accept:"application/json"},i=await this.batchIngestCaller.call(fetch,`${this.apiUrl}/runs/batch`,{method:"POST",headers:t,body:e,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(i,"batch create run")}async updateRun(e,t){p(e),t.inputs&&(t.inputs=this.processInputs(t.inputs)),t.outputs&&(t.outputs=this.processOutputs(t.outputs));let i={...t,id:e};if(!this._filterForSampling([i],!0).length)return;if(this.autoBatchTracing&&i.trace_id!==void 0&&i.dotted_order!==void 0){if(t.end_time!==void 0&&i.parent_run_id===void 0){await this.processRunOperation({action:"update",item:i},!0);return}else this.processRunOperation({action:"update",item:i}).catch(console.error);return}let r={...this.headers,"Content-Type":"application/json"},a=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}`,{method:"PATCH",headers:r,body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(a,"update run")}async readRun(e,{loadChildRuns:t}={loadChildRuns:!1}){p(e);let i=await this._get(`/runs/${e}`);return t&&i.child_run_ids&&(i=await this._loadChildRuns(i)),i}async getRunUrl({runId:e,run:t,projectOpts:i}){if(t!==void 0){let r;t.session_id?r=t.session_id:i?.projectName?r=(await this.readProject({projectName:i?.projectName})).id:i?.projectId?r=i?.projectId:r=(await this.readProject({projectName:_("LANGCHAIN_PROJECT")||"default"})).id;let a=await this._getTenantId();return`${this.getHostUrl()}/o/${a}/projects/p/${r}/r/${t.id}?poll=true`}else if(e!==void 0){let r=await this.readRun(e);if(!r.app_path)throw new Error(`Run ${e} has no app_path`);return`${this.getHostUrl()}${r.app_path}`}else throw new Error("Must provide either runId or run")}async _loadChildRuns(e){let t=await ne(this.listRuns({id:e.child_run_ids})),i={},r={};t.sort((a,s)=>(a?.dotted_order??"").localeCompare(s?.dotted_order??""));for(let a of t){if(a.parent_run_id===null||a.parent_run_id===void 0)throw new Error(`Child run ${a.id} has no parent`);a.parent_run_id in i||(i[a.parent_run_id]=[]),i[a.parent_run_id].push(a),r[a.id]=a}e.child_runs=i[e.id]||[];for(let a in i)a!==e.id&&(r[a].child_runs=i[a]);return e}async*listRuns(e){let{projectId:t,projectName:i,parentRunId:r,traceId:a,referenceExampleId:s,startTime:n,executionOrder:u,isRoot:d,runType:h,error:l,id:c,query:m,filter:f,traceFilter:y,treeFilter:g,limit:b,select:R}=e,S=[];if(t&&(S=Array.isArray(t)?t:[t]),i){let w=Array.isArray(i)?i:[i],G=await Promise.all(w.map(X=>this.readProject({projectName:X}).then(ee=>ee.id)));S.push(...G)}let B=["app_path","child_run_ids","completion_cost","completion_tokens","dotted_order","end_time","error","events","extra","feedback_stats","first_token_time","id","inputs","name","outputs","parent_run_id","parent_run_ids","prompt_cost","prompt_tokens","reference_example_id","run_type","session_id","start_time","status","tags","total_cost","total_tokens","trace_id"],F={session:S.length?S:null,run_type:h,reference_example:s,query:m,filter:f,trace_filter:y,tree_filter:g,execution_order:u,parent_run:r,start_time:n?n.toISOString():null,error:l,id:c,limit:b,trace:a,select:R||B,is_root:d},E=0;for await(let w of this._getCursorPaginatedList("/runs/query",F))if(b){if(E>=b)break;if(w.length+E>b){yield*w.slice(0,b-E);break}E+=w.length,yield*w}else yield*w}async getRunStats({id:e,trace:t,parentRun:i,runType:r,projectNames:a,projectIds:s,referenceExampleIds:n,startTime:u,endTime:d,error:h,query:l,filter:c,traceFilter:m,treeFilter:f,isRoot:y,dataSourceType:g}){let b=s||[];a&&(b=[...s||[],...await Promise.all(a.map(E=>this.readProject({projectName:E}).then(w=>w.id)))]);let S=Object.fromEntries(Object.entries({id:e,trace:t,parent_run:i,run_type:r,session:b,reference_example:n,start_time:u,end_time:d,error:h,query:l,filter:c,trace_filter:m,tree_filter:f,is_root:y,data_source_type:g}).filter(([E,w])=>w!==void 0));return await(await this.caller.call(fetch,`${this.apiUrl}/runs/stats`,{method:"POST",headers:this.headers,body:JSON.stringify(S),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async shareRun(e,{shareId:t}={}){let i={run_id:e,share_token:t||N.v4()};p(e);let a=await(await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();if(a===null||!("share_token"in a))throw new Error("Invalid response from server");return`${this.getHostUrl()}/public/${a.share_token}/r`}async unshareRun(e){p(e);let t=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(t,"unshare run")}async readRunSharedLink(e){p(e);let i=await(await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();if(!(i===null||!("share_token"in i)))return`${this.getHostUrl()}/public/${i.share_token}/r`}async listSharedRuns(e,{runIds:t}={}){let i=new URLSearchParams({share_token:e});if(t!==void 0)for(let s of t)i.append("id",s);return p(e),await(await this.caller.call(fetch,`${this.apiUrl}/public/${e}/runs${i}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async readDatasetSharedSchema(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id),p(e);let r=await(await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();return r.url=`${this.getHostUrl()}/public/${r.share_token}/d`,r}async shareDataset(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id);let i={dataset_id:e};p(e);let a=await(await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();return a.url=`${this.getHostUrl()}/public/${a.share_token}/d`,a}async unshareDataset(e){p(e);let t=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(t,"unshare dataset")}async readSharedDataset(e){return p(e),await(await this.caller.call(fetch,`${this.apiUrl}/public/${e}/datasets`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async createProject({projectName:e,description:t=null,metadata:i=null,upsert:r=!1,projectExtra:a=null,referenceDatasetId:s=null}){let n=r?"?upsert=true":"",u=`${this.apiUrl}/sessions${n}`,d=a||{};i&&(d.metadata=i);let h={name:e,extra:d,description:t};s!==null&&(h.reference_dataset_id=s);let l=await this.caller.call(fetch,u,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(h),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions}),c=await l.json();if(!l.ok)throw new Error(`Failed to create session ${e}: ${l.status} ${l.statusText}`);return c}async updateProject(e,{name:t=null,description:i=null,metadata:r=null,projectExtra:a=null,endTime:s=null}){let n=`${this.apiUrl}/sessions/${e}`,u=a;r&&(u={...u||{},metadata:r});let d={name:t,extra:u,description:i,end_time:s?new Date(s).toISOString():null},h=await this.caller.call(fetch,n,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(d),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions}),l=await h.json();if(!h.ok)throw new Error(`Failed to update project ${e}: ${h.status} ${h.statusText}`);return l}async hasProject({projectId:e,projectName:t}){let i="/sessions",r=new URLSearchParams;if(e!==void 0&&t!==void 0)throw new Error("Must provide either projectName or projectId, not both");if(e!==void 0)p(e),i+=`/${e}`;else if(t!==void 0)r.append("name",t);else throw new Error("Must provide projectName or projectId");let a=await this.caller.call(fetch,`${this.apiUrl}${i}?${r}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});try{let s=await a.json();return a.ok?Array.isArray(s)?s.length>0:!0:!1}catch{return!1}}async readProject({projectId:e,projectName:t,includeStats:i}){let r="/sessions",a=new URLSearchParams;if(e!==void 0&&t!==void 0)throw new Error("Must provide either projectName or projectId, not both");if(e!==void 0)p(e),r+=`/${e}`;else if(t!==void 0)a.append("name",t);else throw new Error("Must provide projectName or projectId");i!==void 0&&a.append("include_stats",i.toString());let s=await this._get(r,a),n;if(Array.isArray(s)){if(s.length===0)throw new Error(`Project[id=${e}, name=${t}] not found`);n=s[0]}else n=s;return n}async getProjectUrl({projectId:e,projectName:t}){if(e===void 0&&t===void 0)throw new Error("Must provide either projectName or projectId");let i=await this.readProject({projectId:e,projectName:t}),r=await this._getTenantId();return`${this.getHostUrl()}/o/${r}/projects/p/${i.id}`}async getDatasetUrl({datasetId:e,datasetName:t}){if(e===void 0&&t===void 0)throw new Error("Must provide either datasetName or datasetId");let i=await this.readDataset({datasetId:e,datasetName:t}),r=await this._getTenantId();return`${this.getHostUrl()}/o/${r}/datasets/${i.id}`}async _getTenantId(){if(this._tenantId!==null)return this._tenantId;let e=new URLSearchParams({limit:"1"});for await(let t of this._getPaginated("/sessions",e))return this._tenantId=t[0].tenant_id,t[0].tenant_id;throw new Error("No projects found to resolve tenant.")}async*listProjects({projectIds:e,name:t,nameContains:i,referenceDatasetId:r,referenceDatasetName:a,referenceFree:s}={}){let n=new URLSearchParams;if(e!==void 0)for(let u of e)n.append("id",u);if(t!==void 0&&n.append("name",t),i!==void 0&&n.append("name_contains",i),r!==void 0)n.append("reference_dataset",r);else if(a!==void 0){let u=await this.readDataset({datasetName:a});n.append("reference_dataset",u.id)}s!==void 0&&n.append("reference_free",s.toString());for await(let u of this._getPaginated("/sessions",n))yield*u}async deleteProject({projectId:e,projectName:t}){let i;if(e===void 0&&t===void 0)throw new Error("Must provide projectName or projectId");if(e!==void 0&&t!==void 0)throw new Error("Must provide either projectName or projectId, not both");e===void 0?i=(await this.readProject({projectName:t})).id:i=e,p(i);let r=await this.caller.call(fetch,`${this.apiUrl}/sessions/${i}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(r,`delete session ${i} (${t})`)}async uploadCsv({csvFile:e,fileName:t,inputKeys:i,outputKeys:r,description:a,dataType:s,name:n}){let u=`${this.apiUrl}/datasets/upload`,d=new FormData;d.append("file",e,t),i.forEach(c=>{d.append("input_keys",c)}),r.forEach(c=>{d.append("output_keys",c)}),a&&d.append("description",a),s&&d.append("data_type",s),n&&d.append("name",n);let h=await this.caller.call(fetch,u,{method:"POST",headers:this.headers,body:d,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!h.ok){let c=await h.json();throw c.detail&&c.detail.includes("already exists")?new Error(`Dataset ${t} already exists`):new Error(`Failed to upload CSV: ${h.status} ${h.statusText}`)}return await h.json()}async createDataset(e,{description:t,dataType:i}={}){let r={name:e,description:t};i&&(r.data_type=i);let a=await this.caller.call(fetch,`${this.apiUrl}/datasets`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!a.ok){let n=await a.json();throw n.detail&&n.detail.includes("already exists")?new Error(`Dataset ${e} already exists`):new Error(`Failed to create dataset ${a.status} ${a.statusText}`)}return await a.json()}async readDataset({datasetId:e,datasetName:t}){let i="/datasets",r=new URLSearchParams({limit:"1"});if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(e!==void 0)p(e),i+=`/${e}`;else if(t!==void 0)r.append("name",t);else throw new Error("Must provide datasetName or datasetId");let a=await this._get(i,r),s;if(Array.isArray(a)){if(a.length===0)throw new Error(`Dataset[id=${e}, name=${t}] not found`);s=a[0]}else s=a;return s}async hasDataset({datasetId:e,datasetName:t}){try{return await this.readDataset({datasetId:e,datasetName:t}),!0}catch(i){if(i instanceof Error&&i.message.toLocaleLowerCase().includes("not found"))return!1;throw i}}async diffDatasetVersions({datasetId:e,datasetName:t,fromVersion:i,toVersion:r}){let a=e;if(a===void 0&&t===void 0)throw new Error("Must provide either datasetName or datasetId");if(a!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");a===void 0&&(a=(await this.readDataset({datasetName:t})).id);let s=new URLSearchParams({from_version:typeof i=="string"?i:i.toISOString(),to_version:typeof r=="string"?r:r.toISOString()});return await this._get(`/datasets/${a}/versions/diff`,s)}async readDatasetOpenaiFinetuning({datasetId:e,datasetName:t}){let i="/datasets";if(e===void 0)if(t!==void 0)e=(await this.readDataset({datasetName:t})).id;else throw new Error("Must provide datasetName or datasetId");return(await(await this._getResponse(`${i}/${e}/openai_ft`)).text()).trim().split(`
`).map(n=>JSON.parse(n))}async*listDatasets({limit:e=100,offset:t=0,datasetIds:i,datasetName:r,datasetNameContains:a}={}){let s="/datasets",n=new URLSearchParams({limit:e.toString(),offset:t.toString()});if(i!==void 0)for(let u of i)n.append("id",u);r!==void 0&&n.append("name",r),a!==void 0&&n.append("name_contains",a);for await(let u of this._getPaginated(s,n))yield*u}async updateDataset(e){let{datasetId:t,datasetName:i,...r}=e;if(!t&&!i)throw new Error("Must provide either datasetName or datasetId");let a=t??(await this.readDataset({datasetName:i})).id;p(a);let s=await this.caller.call(fetch,`${this.apiUrl}/datasets/${a}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!s.ok)throw new Error(`Failed to update dataset ${a}: ${s.status} ${s.statusText}`);return await s.json()}async deleteDataset({datasetId:e,datasetName:t}){let i="/datasets",r=e;if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(t!==void 0&&(r=(await this.readDataset({datasetName:t})).id),r!==void 0)p(r),i+=`/${r}`;else throw new Error("Must provide datasetName or datasetId");let a=await this.caller.call(fetch,this.apiUrl+i,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!a.ok)throw new Error(`Failed to delete ${i}: ${a.status} ${a.statusText}`);await a.json()}async createExample(e,t,{datasetId:i,datasetName:r,createdAt:a,exampleId:s,metadata:n,split:u}){let d=i;if(d===void 0&&r===void 0)throw new Error("Must provide either datasetName or datasetId");if(d!==void 0&&r!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");d===void 0&&(d=(await this.readDataset({datasetName:r})).id);let l={dataset_id:d,inputs:e,outputs:t,created_at:(a||new Date)?.toISOString(),id:s,metadata:n,split:u},c=await this.caller.call(fetch,`${this.apiUrl}/examples`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(l),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!c.ok)throw new Error(`Failed to create example: ${c.status} ${c.statusText}`);return await c.json()}async createExamples(e){let{inputs:t,outputs:i,metadata:r,sourceRunIds:a,exampleIds:s,datasetId:n,datasetName:u}=e,d=n;if(d===void 0&&u===void 0)throw new Error("Must provide either datasetName or datasetId");if(d!==void 0&&u!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");d===void 0&&(d=(await this.readDataset({datasetName:u})).id);let h=t.map((m,f)=>({dataset_id:d,inputs:m,outputs:i?i[f]:void 0,metadata:r?r[f]:void 0,split:e.splits?e.splits[f]:void 0,id:s?s[f]:void 0,source_run_id:a?a[f]:void 0})),l=await this.caller.call(fetch,`${this.apiUrl}/examples/bulk`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(h),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!l.ok)throw new Error(`Failed to create examples: ${l.status} ${l.statusText}`);return await l.json()}async createLLMExample(e,t,i){return this.createExample({input:e},{output:t},i)}async createChatExample(e,t,i){let r=e.map(s=>U(s)?k(s):s),a=U(t)?k(t):t;return this.createExample({input:r},{output:a},i)}async readExample(e){p(e);let t=`/examples/${e}`;return await this._get(t)}async*listExamples({datasetId:e,datasetName:t,exampleIds:i,asOf:r,splits:a,inlineS3Urls:s,metadata:n,limit:u,offset:d,filter:h}={}){let l;if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(e!==void 0)l=e;else if(t!==void 0)l=(await this.readDataset({datasetName:t})).id;else throw new Error("Must provide a datasetName or datasetId");let c=new URLSearchParams({dataset:l}),m=r?typeof r=="string"?r:r?.toISOString():void 0;m&&c.append("as_of",m);let f=s??!0;if(c.append("inline_s3_urls",f.toString()),i!==void 0)for(let g of i)c.append("id",g);if(a!==void 0)for(let g of a)c.append("splits",g);if(n!==void 0){let g=JSON.stringify(n);c.append("metadata",g)}u!==void 0&&c.append("limit",u.toString()),d!==void 0&&c.append("offset",d.toString()),h!==void 0&&c.append("filter",h);let y=0;for await(let g of this._getPaginated("/examples",c)){for(let b of g)yield b,y++;if(u!==void 0&&y>=u)break}}async deleteExample(e){p(e);let t=`/examples/${e}`,i=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!i.ok)throw new Error(`Failed to delete ${t}: ${i.status} ${i.statusText}`);await i.json()}async updateExample(e,t){p(e);let i=await this.caller.call(fetch,`${this.apiUrl}/examples/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!i.ok)throw new Error(`Failed to update example ${e}: ${i.status} ${i.statusText}`);return await i.json()}async updateExamples(e){let t=await this.caller.call(fetch,`${this.apiUrl}/examples/bulk`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(e),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!t.ok)throw new Error(`Failed to update examples: ${t.status} ${t.statusText}`);return await t.json()}async listDatasetSplits({datasetId:e,datasetName:t,asOf:i}){let r;if(e===void 0&&t===void 0)throw new Error("Must provide dataset name or ID");if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");e===void 0?r=(await this.readDataset({datasetName:t})).id:r=e,p(r);let a=new URLSearchParams,s=i?typeof i=="string"?i:i?.toISOString():void 0;return s&&a.append("as_of",s),await this._get(`/datasets/${r}/splits`,a)}async updateDatasetSplits({datasetId:e,datasetName:t,splitName:i,exampleIds:r,remove:a=!1}){let s;if(e===void 0&&t===void 0)throw new Error("Must provide dataset name or ID");if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");e===void 0?s=(await this.readDataset({datasetName:t})).id:s=e,p(s);let n={split_name:i,examples:r.map(d=>(p(d),d)),remove:a},u=await this.caller.call(fetch,`${this.apiUrl}/datasets/${s}/splits`,{method:"PUT",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(n),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(u,"update dataset splits")}async evaluateRun(e,t,{sourceInfo:i,loadChildRuns:r,referenceExample:a}={loadChildRuns:!1}){A("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");let s;if(typeof e=="string")s=await this.readRun(e,{loadChildRuns:r});else if(typeof e=="object"&&"id"in e)s=e;else throw new Error(`Invalid run type: ${typeof e}`);s.reference_example_id!==null&&s.reference_example_id!==void 0&&(a=await this.readExample(s.reference_example_id));let n=await t.evaluateRun(s,a),[u,d]=await this._logEvaluationFeedback(n,s,i);return d[0]}async createFeedback(e,t,{score:i,value:r,correction:a,comment:s,sourceInfo:n,feedbackSourceType:u="api",sourceRunId:d,feedbackId:h,feedbackConfig:l,projectId:c,comparativeExperimentId:m}){if(!e&&!c)throw new Error("One of runId or projectId must be provided");if(e&&c)throw new Error("Only one of runId or projectId can be provided");let f={type:u??"api",metadata:n??{}};d!==void 0&&f?.metadata!==void 0&&!f.metadata.__run&&(f.metadata.__run={run_id:d}),f?.metadata!==void 0&&f.metadata.__run?.run_id!==void 0&&p(f.metadata.__run.run_id);let y={id:h??N.v4(),run_id:e,key:t,score:i,value:r,correction:a,comment:s,feedback_source:f,comparative_experiment_id:m,feedbackConfig:l,session_id:c},g=`${this.apiUrl}/feedback`,b=await this.caller.call(fetch,g,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(y),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await v(b,"create feedback"),y}async updateFeedback(e,{score:t,value:i,correction:r,comment:a}){let s={};t!=null&&(s.score=t),i!=null&&(s.value=i),r!=null&&(s.correction=r),a!=null&&(s.comment=a),p(e);let n=await this.caller.call(fetch,`${this.apiUrl}/feedback/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(s),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await v(n,"update feedback")}async readFeedback(e){p(e);let t=`/feedback/${e}`;return await this._get(t)}async deleteFeedback(e){p(e);let t=`/feedback/${e}`,i=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!i.ok)throw new Error(`Failed to delete ${t}: ${i.status} ${i.statusText}`);await i.json()}async*listFeedback({runIds:e,feedbackKeys:t,feedbackSourceTypes:i}={}){let r=new URLSearchParams;if(e&&r.append("run",e.join(",")),t)for(let a of t)r.append("key",a);if(i)for(let a of i)r.append("source",a);for await(let a of this._getPaginated("/feedback",r))yield*a}async createPresignedFeedbackToken(e,t,{expiration:i,feedbackConfig:r}={}){let a={run_id:e,feedback_key:t,feedback_config:r};return i?typeof i=="string"?a.expires_at=i:(i?.hours||i?.minutes||i?.days)&&(a.expires_in=i):a.expires_in={hours:3},await(await this.caller.call(fetch,`${this.apiUrl}/feedback/tokens`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(a),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async createComparativeExperiment({name:e,experimentIds:t,referenceDatasetId:i,createdAt:r,description:a,metadata:s,id:n}){if(t.length===0)throw new Error("At least one experiment is required");if(i||(i=(await this.readProject({projectId:t[0]})).reference_dataset_id),!i==null)throw new Error("A reference dataset is required");let u={id:n,name:e,experiment_ids:t,reference_dataset_id:i,description:a,created_at:(r??new Date)?.toISOString(),extra:{}};return s&&(u.extra.metadata=s),await(await this.caller.call(fetch,`${this.apiUrl}/datasets/comparative`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(u),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async*listPresignedFeedbackTokens(e){p(e);let t=new URLSearchParams({run_id:e});for await(let i of this._getPaginated("/feedback/tokens",t))yield*i}_selectEvalResults(e){let t;return"results"in e?t=e.results:t=[e],t}async _logEvaluationFeedback(e,t,i){let r=this._selectEvalResults(e),a=[];for(let s of r){let n=i||{};s.evaluatorInfo&&(n={...s.evaluatorInfo,...n});let u=null;s.targetRunId?u=s.targetRunId:t&&(u=t.id),a.push(await this.createFeedback(u,s.key,{score:s.score,value:s.value,comment:s.comment,correction:s.correction,sourceInfo:n,sourceRunId:s.sourceRunId,feedbackConfig:s.feedbackConfig,feedbackSourceType:"model"}))}return[r,a]}async logEvaluationFeedback(e,t,i){let[r]=await this._logEvaluationFeedback(e,t,i);return r}};var $="0.1.39";var O,de=()=>typeof window<"u"&&typeof window.document<"u",le=()=>typeof globalThis=="object"&&globalThis.constructor&&globalThis.constructor.name==="DedicatedWorkerGlobalScope",ce=()=>typeof window<"u"&&window.name==="nodejs"||typeof navigator<"u"&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom")),Q=()=>typeof Deno<"u",he=()=>typeof __Process$<"u"&&typeof __Process$.versions<"u"&&typeof __Process$.versions.node<"u"&&!Q(),pe=()=>O||(de()?O="browser":he()?O="node":le()?O="webworker":ce()?O="jsdom":Q()?O="deno":O="other",O),M;async function C(){if(M===void 0){let o=pe(),e=me();M={library:"langsmith",runtime:o,sdk:"langsmith-js",sdk_version:$,...e}}return M}function K(){let o=fe()||{},e={},t=["LANGCHAIN_API_KEY","LANGCHAIN_ENDPOINT","LANGCHAIN_TRACING_V2","LANGCHAIN_PROJECT","LANGCHAIN_SESSION"];for(let[i,r]of Object.entries(o))i.startsWith("LANGCHAIN_")&&typeof r=="string"&&!t.includes(i)&&!i.toLowerCase().includes("key")&&!i.toLowerCase().includes("secret")&&!i.toLowerCase().includes("token")&&(i==="LANGCHAIN_REVISION_ID"?e.revision_id=r:e[i]=r);return e}function fe(){try{return typeof __Process$<"u"&&__Process$.env?Object.entries(__Process$.env).reduce((o,[e,t])=>(o[e]=String(t),o),{}):void 0}catch{return}}function _(o){try{return typeof __Process$<"u"?__Process$.env?.[o]:void 0}catch{return}}var H;function me(){if(H!==void 0)return H;let o=["VERCEL_GIT_COMMIT_SHA","NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA","COMMIT_REF","RENDER_GIT_COMMIT","CI_COMMIT_SHA","CIRCLE_SHA1","CF_PAGES_COMMIT_SHA","REACT_APP_GIT_SHA","SOURCE_VERSION","GITHUB_SHA","TRAVIS_COMMIT","GIT_COMMIT","BUILD_VCS_NUMBER","bamboo_planRepository_revision","Build.SourceVersion","BITBUCKET_COMMIT","DRONE_COMMIT_SHA","SEMAPHORE_GIT_SHA","BUILDKITE_COMMIT"],e={};for(let t of o){let i=_(t);i!==void 0&&(e[t]=i)}return H=e,e}var W=o=>o!==void 0?o:!!["LANGSMITH_TRACING_V2","LANGCHAIN_TRACING_V2","LANGSMITH_TRACING","LANGCHAIN_TRACING"].find(t=>_(t)==="true");function _e(o){return o.replace(/[-:.]/g,"")}function ge(o,e,t=1){let i=t.toFixed(0).slice(0,3).padStart(3,"0");return _e(`${new Date(o).toISOString().slice(0,-1)}${i}Z`)+e}var P=class o{constructor(e,t){Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.metadata=e,this.tags=t}static fromHeader(e){let t=e.split(","),i={},r=[];for(let a of t){let[s,n]=a.split("="),u=decodeURIComponent(n);s==="langsmith-metadata"?i=JSON.parse(u):s==="langsmith-tags"&&(r=u.split(","))}return new o(i,r)}toHeader(){let e=[];return this.metadata&&Object.keys(this.metadata).length>0&&e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`),this.tags&&this.tags.length>0&&e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`),e.join(",")}},D=class o{constructor(e){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"run_type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"project_name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"parent_run",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"child_runs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"start_time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"end_time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extra",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"error",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"serialized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"reference_example_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"events",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"trace_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"dotted_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tracingEnabled",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"execution_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"child_execution_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=o.getDefaultConfig(),{metadata:i,...r}=e,a=r.client??new j,s={...i,...r?.extra?.metadata};if(r.extra={...r.extra,metadata:s},Object.assign(this,{...t,...r,client:a}),this.trace_id||(this.parent_run?this.trace_id=this.parent_run.trace_id??this.id:this.trace_id=this.id),this.execution_order??=1,this.child_execution_order??=1,!this.dotted_order){let n=ge(this.start_time,this.id,this.execution_order);this.parent_run?this.dotted_order=this.parent_run.dotted_order+"."+n:this.dotted_order=n}}static getDefaultConfig(){return{id:Y.v4(),run_type:"chain",project_name:_("LANGCHAIN_PROJECT")??_("LANGCHAIN_SESSION")??"default",child_runs:[],api_url:_("LANGCHAIN_ENDPOINT")??"http://localhost:1984",api_key:_("LANGCHAIN_API_KEY"),caller_options:{},start_time:Date.now(),serialized:{},inputs:{},extra:{}}}createChild(e){let t=this.child_execution_order+1,i=new o({...e,parent_run:this,project_name:this.project_name,client:this.client,tracingEnabled:this.tracingEnabled,execution_order:t,child_execution_order:t}),r=Symbol.for("lc:child_config"),a=e.extra?.[r]??this.extra[r];if(we(a)){let u={...a},d=be(u.callbacks)?u.callbacks.copy?.():void 0;d&&(Object.assign(d,{_parentRunId:i.id}),d.handlers?.find(Z)?.updateFromRunTree?.(i),u.callbacks=d),i.extra[r]=u}let s=new Set,n=this;for(;n!=null&&!s.has(n.id);)s.add(n.id),n.child_execution_order=Math.max(n.child_execution_order,t),n=n.parent_run;return this.child_runs.push(i),i}async end(e,t,i=Date.now()){this.outputs=this.outputs??e,this.error=this.error??t,this.end_time=this.end_time??i}_convertToCreate(e,t,i=!0){let r=e.extra??{};if(r.runtime||(r.runtime={}),t)for(let[u,d]of Object.entries(t))r.runtime[u]||(r.runtime[u]=d);let a,s;return i?(s=e.parent_run?.id,a=[]):(a=e.child_runs.map(u=>this._convertToCreate(u,t,i)),s=void 0),{id:e.id,name:e.name,start_time:e.start_time,end_time:e.end_time,run_type:e.run_type,reference_example_id:e.reference_example_id,extra:r,serialized:e.serialized,error:e.error,inputs:e.inputs,outputs:e.outputs,session_name:e.project_name,child_runs:a,parent_run_id:s,trace_id:e.trace_id,dotted_order:e.dotted_order,tags:e.tags}}async postRun(e=!0){let t=await C(),i=await this._convertToCreate(this,t,!0);if(await this.client.createRun(i),!e){A("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");for(let r of this.child_runs)await r.postRun(!1)}}async patchRun(){let e={end_time:this.end_time,error:this.error,inputs:this.inputs,outputs:this.outputs,parent_run_id:this.parent_run?.id,reference_example_id:this.reference_example_id,extra:this.extra,events:this.events,dotted_order:this.dotted_order,trace_id:this.trace_id,tags:this.tags};await this.client.updateRun(this.id,e)}toJSON(){return this._convertToCreate(this,void 0,!1)}static fromRunnableConfig(e,t){let i=e?.callbacks,r,a,s,n=W();if(i){let d=i?.getParentRunId?.()??"",h=i?.handlers?.find(l=>l?.name=="langchain_tracer");r=h?.getRun?.(d),a=h?.projectName,s=h?.client,n=n||!!h}return r?new o({name:r.name,id:r.id,client:s,tracingEnabled:n,project_name:a,tags:[...new Set((r?.tags??[]).concat(e?.tags??[]))],extra:{metadata:{...r?.extra?.metadata,...e?.metadata}}}).createChild(t):new o({...t,client:s,tracingEnabled:n,project_name:a})}static fromDottedOrder(e){return this.fromHeaders({"langsmith-trace":e})}static fromHeaders(e,t){let i="get"in e&&typeof e.get=="function"?{"langsmith-trace":e.get("langsmith-trace"),baggage:e.get("baggage")}:e,r=i["langsmith-trace"];if(!r||typeof r!="string")return;let a=r.trim(),s=a.split(".").map(d=>{let[h,l]=d.split("Z");return{strTime:h,time:Date.parse(h+"Z"),uuid:l}}),n=s[0].uuid,u={...t,name:t?.name??"parent",run_type:t?.run_type??"chain",start_time:t?.start_time??Date.now(),id:s.at(-1)?.uuid,trace_id:n,dotted_order:a};if(i.baggage&&typeof i.baggage=="string"){let d=P.fromHeader(i.baggage);u.metadata=d.metadata,u.tags=d.tags}return new o(u)}toHeaders(e){let t={"langsmith-trace":this.dotted_order,baggage:new P(this.extra?.metadata,this.tags).toHeader()};if(e)for(let[i,r]of Object.entries(t))e.set(i,r);return t}};function Je(o){return o!==void 0&&typeof o.createChild=="function"&&typeof o.postRun=="function"}function Z(o){return typeof o=="object"&&o!=null&&typeof o.name=="string"&&o.name==="langchain_tracer"}function q(o){return Array.isArray(o)&&o.some(e=>Z(e))}function be(o){return typeof o=="object"&&o!=null&&Array.isArray(o.handlers)}function we(o){return o!==void 0&&typeof o.callbacks=="object"&&(q(o.callbacks?.handlers)||q(o.callbacks))}export{D as RunTree,ge as convertToDottedOrderFormat,Je as isRunTree,we as isRunnableConfigLike};
//# sourceMappingURL=run_trees.js.map