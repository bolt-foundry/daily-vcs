/* esm.sh - esbuild bundle(@graphql-tools/schema@10.0.2) denonext production */
import{getNamedType as V,isScalarType as C}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{forEachField as P}from"/v135/@graphql-tools/utils@10.0.11/denonext/utils.mjs";function T(t,l={}){let{requireResolversForArgs:i,requireResolversForNonScalar:r,requireResolversForAllFields:s}=l;if(s&&(i||r))throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");P(t,(e,n,o)=>{s&&v("requireResolversForAllFields",s,e,n,o),i&&e.args.length>0&&v("requireResolversForArgs",i,e,n,o),r!=="ignore"&&!C(V(e.type))&&v("requireResolversForNonScalar",r,e,n,o)})}function v(t,l,i,r,s){if(!i.resolve){let e=`Resolver missing for "${r}.${s}".
To disable this validator, use:
  resolverValidationOptions: {
    ${t}: 'ignore'
  }`;if(l==="error")throw new Error(e);l==="warn"&&console.warn(e);return}if(typeof i.resolve!="function")throw new Error(`Resolver "${r}.${s}" must be a function`)}import{defaultFieldResolver as q}from"/v135/graphql@16.8.1/denonext/graphql.mjs";function M(t){return(l,i,r,s)=>t.reduce((e,n)=>n!=null?n(e,i,r,s):q(e,i,r,s),l)}import{GraphQLEnumType as R,GraphQLInterfaceType as L,GraphQLObjectType as k,GraphQLScalarType as Y,GraphQLUnionType as G,isEnumType as b,isInterfaceType as E,isObjectType as w,isScalarType as Q,isSpecifiedScalarType as A,isUnionType as F}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{forEachDefaultValue as S,forEachField as U,healSchema as B,MapperKind as p,mapSchema as _,parseInputValue as J,serializeInputValue as K}from"/v135/@graphql-tools/utils@10.0.11/denonext/utils.mjs";import{MapperKind as W,mapSchema as D}from"/v135/@graphql-tools/utils@10.0.11/denonext/utils.mjs";function x(t,l){D(t,{[W.ABSTRACT_TYPE]:i=>{if(!i.resolveType){let r=`Type "${i.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;if(l==="error")throw new Error(r);l==="warn"&&console.warn(r)}}})}function N(t,l){let i={},r=t.getTypeMap();for(let s in r){let e=r[s];if("getInterfaces"in e){i[s]={};for(let o of e.getInterfaces())if(l[o.name])for(let a in l[o.name])(a==="__isTypeOf"||!a.startsWith("__"))&&(i[s][a]=l[o.name][a]);let n=l[s];i[s]={...i[s],...n}}else{let n=l[s];n!=null&&(i[s]=n)}}return i}function h({schema:t,resolvers:l,defaultFieldResolver:i,resolverValidationOptions:r={},inheritResolversFromInterfaces:s=!1,updateResolversInPlace:e=!1}){let{requireResolversToMatchSchema:n="error",requireResolversForResolveType:o}=r,a=s?N(t,l):l;for(let c in a){let d=a[c];if(typeof d!=="object")throw new Error(`"${c}" defined in resolvers, but has invalid value "${d}". The resolver's value must be of type object.`);let u=t.getType(c);if(u==null){if(n==="ignore")continue;throw new Error(`"${c}" defined in resolvers, but not in schema`)}else if(A(u))for(let f in d)f.startsWith("__")?u[f.substring(2)]=d[f]:u[f]=d[f];else if(b(u)){let f=u.getValues();for(let m in d)if(!m.startsWith("__")&&!f.some(y=>y.name===m)&&n&&n!=="ignore")throw new Error(`${u.name}.${m} was defined in resolvers, but not present within ${u.name}`)}else if(F(u)){for(let f in d)if(!f.startsWith("__")&&n&&n!=="ignore")throw new Error(`${u.name}.${f} was defined in resolvers, but ${u.name} is not an object or interface type`)}else if(w(u)||E(u)){for(let f in d)if(!f.startsWith("__"))if(u.getFields()[f]==null){if(n&&n!=="ignore")throw new Error(`${c}.${f} defined in resolvers, but not in schema`)}else{let g=d[f];if(typeof g!="function"&&typeof g!="object")throw new Error(`Resolver ${c}.${f} must be object or function`)}}}return t=e?z(t,a,i):H(t,a,i),o&&o!=="ignore"&&x(t,o),t}function z(t,l,i){let r=t.getTypeMap();for(let s in l){let e=t.getType(s),n=l[s];if(Q(e))for(let o in n)o.startsWith("__")?e[o.substring(2)]=n[o]:o==="astNode"&&e.astNode!=null?e.astNode={...e.astNode,description:n?.astNode?.description??e.astNode.description,directives:(e.astNode.directives??[]).concat(n?.astNode?.directives??[])}:o==="extensionASTNodes"&&e.extensionASTNodes!=null?e.extensionASTNodes=e.extensionASTNodes.concat(n?.extensionASTNodes??[]):o==="extensions"&&e.extensions!=null&&n.extensions!=null?e.extensions=Object.assign(Object.create(null),e.extensions,n.extensions):e[o]=n[o];else if(b(e)){let o=e.toConfig(),a=o.values;for(let c in n)c.startsWith("__")?o[c.substring(2)]=n[c]:c==="astNode"&&o.astNode!=null?o.astNode={...o.astNode,description:n?.astNode?.description??o.astNode.description,directives:(o.astNode.directives??[]).concat(n?.astNode?.directives??[])}:c==="extensionASTNodes"&&o.extensionASTNodes!=null?o.extensionASTNodes=o.extensionASTNodes.concat(n?.extensionASTNodes??[]):c==="extensions"&&e.extensions!=null&&n.extensions!=null?e.extensions=Object.assign(Object.create(null),e.extensions,n.extensions):a[c]&&(a[c].value=n[c]);r[s]=new R(o)}else if(F(e))for(let o in n)o.startsWith("__")&&(e[o.substring(2)]=n[o]);else if(w(e)||E(e))for(let o in n){if(o.startsWith("__")){e[o.substring(2)]=n[o];continue}let c=e.getFields()[o];if(c!=null){let d=n[o];typeof d=="function"?c.resolve=d.bind(n):$(c,d)}}}return S(t,K),B(t),S(t,J),i!=null&&U(t,s=>{s.resolve||(s.resolve=i)}),t}function H(t,l,i){return t=_(t,{[p.SCALAR_TYPE]:r=>{let s=r.toConfig(),e=l[r.name];if(!A(r)&&e!=null){for(let n in e)n.startsWith("__")?s[n.substring(2)]=e[n]:n==="astNode"&&s.astNode!=null?s.astNode={...s.astNode,description:e?.astNode?.description??s.astNode.description,directives:(s.astNode.directives??[]).concat(e?.astNode?.directives??[])}:n==="extensionASTNodes"&&s.extensionASTNodes!=null?s.extensionASTNodes=s.extensionASTNodes.concat(e?.extensionASTNodes??[]):n==="extensions"&&s.extensions!=null&&e.extensions!=null?s.extensions=Object.assign(Object.create(null),r.extensions,e.extensions):s[n]=e[n];return new Y(s)}},[p.ENUM_TYPE]:r=>{let s=l[r.name],e=r.toConfig(),n=e.values;if(s!=null){for(let o in s)o.startsWith("__")?e[o.substring(2)]=s[o]:o==="astNode"&&e.astNode!=null?e.astNode={...e.astNode,description:s?.astNode?.description??e.astNode.description,directives:(e.astNode.directives??[]).concat(s?.astNode?.directives??[])}:o==="extensionASTNodes"&&e.extensionASTNodes!=null?e.extensionASTNodes=e.extensionASTNodes.concat(s?.extensionASTNodes??[]):o==="extensions"&&e.extensions!=null&&s.extensions!=null?e.extensions=Object.assign(Object.create(null),r.extensions,s.extensions):n[o]&&(n[o].value=s[o]);return new R(e)}},[p.UNION_TYPE]:r=>{let s=l[r.name];if(s!=null){let e=r.toConfig();return s.__resolveType&&(e.resolveType=s.__resolveType),new G(e)}},[p.OBJECT_TYPE]:r=>{let s=l[r.name];if(s!=null){let e=r.toConfig();return s.__isTypeOf&&(e.isTypeOf=s.__isTypeOf),new k(e)}},[p.INTERFACE_TYPE]:r=>{let s=l[r.name];if(s!=null){let e=r.toConfig();return s.__resolveType&&(e.resolveType=s.__resolveType),new L(e)}},[p.COMPOSITE_FIELD]:(r,s,e)=>{let n=l[e];if(n!=null){let o=n[s];if(o!=null){let a={...r};return typeof o=="function"?a.resolve=o.bind(n):$(a,o),a}}}}),i!=null&&(t=_(t,{[p.OBJECT_FIELD]:r=>({...r,resolve:r.resolve!=null?r.resolve:i})})),t}function $(t,l){for(let i in l)t[i]=l[i]}import{buildASTSchema as X,buildSchema as Z,isSchema as ee}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{applyExtensions as se,mergeExtensions as oe,mergeResolvers as ne,mergeTypeDefs as j}from"/v135/@graphql-tools/merge@9.0.1/denonext/merge.mjs";import{asArray as te}from"/v135/@graphql-tools/utils@10.0.11/denonext/utils.mjs";function O({typeDefs:t,resolvers:l={},resolverValidationOptions:i={},inheritResolversFromInterfaces:r=!1,updateResolversInPlace:s=!1,schemaExtensions:e,...n}){if(typeof i!="object")throw new Error("Expected `resolverValidationOptions` to be an object");if(!t)throw new Error("Must provide typeDefs");let o;if(ee(t))o=t;else if(n?.commentDescriptions){let a=j(t,{...n,commentDescriptions:!0});o=Z(a,n)}else{let a=j(t,n);o=X(a,n)}return o=h({schema:o,resolvers:ne(l),resolverValidationOptions:i,inheritResolversFromInterfaces:r,updateResolversInPlace:s}),Object.keys(i).length>0&&T(o,i),e&&(e=oe(te(e)),se(o,e)),o}import{asArray as I,extractExtensionsFromSchema as re,getResolversFromSchema as ie}from"/v135/@graphql-tools/utils@10.0.11/denonext/utils.mjs";function Fe(t){let l=[],i=[],r=[];if(t.schemas!=null)for(let s of t.schemas)l.push(s),i.push(ie(s)),r.push(re(s));if(t.typeDefs!=null&&l.push(t.typeDefs),t.resolvers!=null){let s=I(t.resolvers);i.push(...s)}if(t.schemaExtensions!=null){let s=I(t.schemaExtensions);r.push(...s)}return O({...t,typeDefs:l,resolvers:i,schemaExtensions:r})}import{extractExtensionsFromSchema as Le}from"/v135/@graphql-tools/utils@10.0.11/denonext/utils.mjs";export{h as addResolversToSchema,T as assertResolversPresent,M as chainResolvers,x as checkForResolveTypeResolver,N as extendResolversFromInterfaces,Le as extractExtensionsFromSchema,O as makeExecutableSchema,Fe as mergeSchemas};
//# sourceMappingURL=schema.mjs.map