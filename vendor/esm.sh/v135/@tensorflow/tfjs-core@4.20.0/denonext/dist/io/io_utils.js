/* esm.sh - esbuild bundle(@tensorflow/tfjs-core@4.20.0/dist/io/io_utils) denonext production */
import { Buffer as __Buffer$ } from "node:buffer";
import{complex as L}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/ops/complex.js";import{tensor as T}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/ops/tensor.js";import{sizeFromShape as m}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/util.js";import{DTYPE_VALUE_SIZE_MAP as d}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/io/types.js";import{CompositeArrayBuffer as z}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/io/composite_array_buffer.js";import{backend as M}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/globals.js";import{env as D}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/environment.js";import{getBackend as F}from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/globals.js";var p=4;async function Z(e,n){let r=[],t=[],o=Array.isArray(e)?e.map(a=>a.name):Object.keys(e);for(let a=0;a<o.length;++a){let l=o[a],i=Array.isArray(e)?e[a].tensor:e[l];if(i.dtype!=="float32"&&i.dtype!=="int32"&&i.dtype!=="bool"&&i.dtype!=="string"&&i.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${i.dtype}`);let y={name:l,shape:i.shape,dtype:i.dtype};if(i.dtype==="string"){let f=new Promise(async u=>{let c=await i.bytes(),A=c.reduce((h,w)=>h+w.length,0)+p*c.length,g=new Uint8Array(A),b=0;for(let h=0;h<c.length;h++){let w=c[h],x=new Uint8Array(new Uint32Array([w.length]).buffer);g.set(x,b),b+=p,g.set(w,b),b+=w.length}u(g)});t.push(f)}else t.push(i.data());n!=null&&(y.group=n),r.push(y)}let s=await Promise.all(t);return{data:q(s),specs:r}}function N(e,n){let r=new z(e),t={},o=0;for(let s of n){let a=$(s,(l,i)=>r.slice(o+l,o+i));t[s.name]=S(s,r.slice(o,o+a)),o+=a}return t}function $(e,n){let r=m(e.shape),t;if("quantization"in e){let o=e.quantization;t=d[o.dtype]}else if(e.dtype==="string"){let o=0;for(let s=0;s<r;s++)o+=p+new Uint32Array(n(o,o+p))[0];return o}else t=d[e.dtype];return r*t}async function v(e,n){let r=m(e.shape),t;if("quantization"in e){let o=e.quantization;t=d[o.dtype]}else if(e.dtype==="string"){let o=0;for(let s=0;s<r;s++)o+=p+new Uint32Array(await n(o,o+p))[0];return o}else t=d[e.dtype];return r*t}function S(e,n){let r=e.name,t=e.dtype,o=e.shape,s=m(o),a,l=0;if("quantization"in e){let i=e.quantization;if(i.dtype==="uint8"||i.dtype==="uint16"){if(!("min"in i&&"scale"in i))throw new Error(`Weight ${e.name} with quantization ${i.dtype} doesn't have corresponding metadata min and scale.`)}else if(i.dtype==="float16"){if(t!=="float32")throw new Error(`Weight ${e.name} is quantized with ${i.dtype} which only supports weights of type float32 not ${t}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${i.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let y=d[i.dtype],f=i.dtype==="uint8"?new Uint8Array(n):new Uint16Array(n);if(t==="float32")if(i.dtype==="uint8"||i.dtype==="uint16"){a=new Float32Array(f.length);for(let u=0;u<f.length;u++){let c=f[u];a[u]=c*i.scale+i.min}}else if(i.dtype==="float16")a=_()(f);else throw new Error(`Unsupported quantization type ${i.dtype} for weight type float32.`);else if(t==="int32"){if(i.dtype!=="uint8"&&i.dtype!=="uint16")throw new Error(`Unsupported quantization type ${i.dtype} for weight type int32.`);a=new Int32Array(f.length);for(let u=0;u<f.length;u++){let c=f[u];a[u]=Math.round(c*i.scale+i.min)}}else throw new Error(`Unsupported dtype in weight '${r}': ${t}`);l+=s*y}else if(t==="string"){let i=m(e.shape);a=[];for(let y=0;y<i;y++){let f=new Uint32Array(n.slice(l,l+p))[0];l+=p;let u=new Uint8Array(n.slice(l,l+f));a.push(u),l+=f}}else{let i=d[t];if(t==="float32")a=new Float32Array(n);else if(t==="int32")a=new Int32Array(n);else if(t==="bool")a=new Uint8Array(n);else if(t==="complex64"){a=new Float32Array(n);let y=new Float32Array(a.length/2),f=new Float32Array(a.length/2);for(let g=0;g<y.length;g++)y[g]=a[g*2],f[g]=a[g*2+1];let u=T(y,o,"float32"),c=T(f,o,"float32"),A=L(u,c);return u.dispose(),c.dispose(),A}else throw new Error(`Unsupported dtype in weight '${r}': ${t}`);l+=s*i}return T(a,o,t)}async function B(e,n,r){let t=new Uint8Array(n);for(;t.byteLength<r;){let{done:o,value:s}=await e.read();if(o&&s==null){let l=r-t.byteLength;throw new Error(`Reader is done but ${l} bytes are still expected`)}let a=new Uint8Array(t.length+s.byteLength);a.set(t,0),a.set(new Uint8Array(s),t.length),t=a}return t.buffer}async function X(e,n){let r={},t=e.getReader(),o=new ArrayBuffer(0);for(let s of n){let a=await v(s,async(y,f)=>(o=await B(t,o,f),o.slice(y,f)));o=await B(t,o,a);let l=o.slice(0,a);o=o.slice(a);let i=S(s,l);if(r[s.name]=i,F()==="webgpu"){let y=M();"uploadToGPU"in y&&m(i.shape)>=D().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&y.uploadToGPU(i.dataId)}}return r}function q(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let n=0,r=[];e.forEach(s=>{if(n+=s.byteLength,r.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let t=new Uint8Array(n),o=0;return r.forEach(s=>{t.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),t.buffer}var U=typeof __Buffer$<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function E(e){return U?__Buffer$.byteLength(e,"utf8"):new Blob([e]).size}function K(e){if(U)return __Buffer$.from(e).toString("base64");let n=new Uint8Array(e),r="";for(let t=0,o=n.length;t<o;t++)r+=String.fromCharCode(n[t]);return btoa(r)}function Q(e){if(U){let t=__Buffer$.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let n=atob(e),r=new Uint8Array(n.length);for(let t=0;t<n.length;++t)r.set([n.charCodeAt(t)],t);return r.buffer}function J(e){return z.join(e)}function ee(e){let n="/";for(e=e.trim();e.endsWith(n);)e=e.slice(0,e.length-1);let r=e.split(n);return r[r.length-1]}function te(e,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),r}function I(e,n,r){let t={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(t.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!r)throw new Error("modelJSON has weightsManifest but weightData is null");t.weightSpecs=n,t.weightData=r}return e.signature!=null&&(t.signature=e.signature),e.userDefinedMetadata!=null&&(t.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(t.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(t.initializerSignature=e.initializerSignature),t}async function ne(e,n){let r,t;return e.weightsManifest!=null&&([r,t]=await n(e.weightsManifest)),I(e,r,t)}function re(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:E(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:E(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new z(e.weightData).byteLength}}function oe(e){let n=[];for(let r of e)n.push(...r.weights);return n}function P(){let e=r=>{let t=r<<13,o=0;for(;!(t&8388608);)o-=8388608,t<<=1;return t&=-8388609,o+=947912704,t|o},n=new Uint32Array(2048);n[0]=0;for(let r=1;r<1024;r++)n[r]=e(r);for(let r=1024;r<2048;r++)n[r]=939524096+(r-1024<<13);return n}function W(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let n=1;n<31;n++)e[n]=n<<23;for(let n=33;n<63;n++)e[n]=2147483648+(n-32<<23);return e}function C(){let e=new Uint32Array(64);for(let n=0;n<64;n++)e[n]=1024;return e[0]=e[32]=0,e}function _(){let e=P(),n=W(),r=C();return t=>{let o=new ArrayBuffer(4*t.length),s=new Uint32Array(o);for(let a=0;a<t.length;a++){let l=t[a],i=e[r[l>>10]+(l&1023)]+n[l>>10];s[a]=i}return new Float32Array(o)}}export{K as arrayBufferToBase64String,Q as base64StringToArrayBuffer,ee as basename,J as concatenateArrayBuffers,q as concatenateTypedArrays,N as decodeWeights,X as decodeWeightsStream,Z as encodeWeights,_ as getFloat16Decoder,ne as getModelArtifactsForJSON,I as getModelArtifactsForJSONSync,re as getModelArtifactsInfoForJSON,te as getModelJSONForModelArtifacts,oe as getWeightSpecs,E as stringByteLength};
/*! Bundled license information:

@tensorflow/tfjs-core/dist/io/io_utils.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=io_utils.js.map