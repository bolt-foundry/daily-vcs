/* esm.sh - esbuild bundle(@tensorflow/tfjs-core@4.20.0/dist/io/composite_array_buffer) denonext production */
import*as f from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/util.js";var d=class s{static join(t){return new s(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(i=>f.isTypedArray(i)?i.buffer:i),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let r=0;for(let i=0;i<t.length;i++){let n=t[i];i!==t.length-1&&n.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let e=r+n.byteLength;this.shards.push({buffer:n,start:r,end:e}),r=e}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,r=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,r=isNaN(Number(r))?0:r,t=Math.max(0,t),r=Math.min(this.byteLength,r),r<=t)return new ArrayBuffer(0);let i=this.findShardForByte(t);if(i===-1)throw new Error(`Could not find start shard for byte ${t}`);let n=r-t,e=new ArrayBuffer(n),c=new Uint8Array(e),o=0;for(let a=i;a<this.shards.length;a++){let h=this.shards[a],l=t+o-h.start,g=o,S=Math.min(r,h.end)-h.start,u=new Uint8Array(h.buffer,l,S-l);if(c.set(u,g),o+=u.length,r<h.end)break}return e}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function r(n){return t<n.start?-1:t>=n.end?1:0}if(r(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let i=m(this.shards,r);return i===-1?-1:(this.previousShardIndex=i,this.previousShardIndex)}};function m(s,t){let r=0,i=s.length;for(;r<=i;){let n=Math.floor((i-r)/2)+r,e=t(s[n]);if(e===0)return n;e<0?i=n:r=n+1}return-1}export{d as CompositeArrayBuffer,m as search};
//# sourceMappingURL=composite_array_buffer.js.map