/* esm.sh - esbuild bundle(@tensorflow/tfjs-core@4.20.0/dist/ops/slice_util) denonext production */
import*as g from"/v135/@tensorflow/tfjs-core@4.20.0/denonext/dist/util.js";var y=-2,D=-1;function z(n,e,t){let r=n.shape.length;g.assert(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),g.assert(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)g.assert(e[i]+t[i]<=n.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function B(n){let e=[],t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function C(n,e,t){let r=[];for(let i=0;i<n.length;i++)r[i]=Math.ceil((e[i]-n[i])/t[i]);return r}function T(n,e,t,r){let i=[...n];for(let o=i.length;o<r.length;o++)i.push(1);for(let o=0;o<t;o++)o===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function F(n,e,t){return t<=n?t:t-(e-1)}function V(n,e){let t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function H(n,e,t,r,i,o,f,a,u){let h=n.length,x=new Array(h),p=new Array(h),s=new Array(h);if(e.length&&t>0){let c=e[0],A=t+1;x=O(f,c,A,r,n),p=R(a,c,A,i,n),s=T(o,c,A,n)}else for(let c=0;c<h;c++)x[c]=W(f,r,o,n,c,u),p[c]=L(a,i,o,n,c,u),s[c]=X(o,c,u);return{begin:x,end:p,strides:s}}function O(n,e,t,r,i){let o=[...i],f=V(t,e);for(let a=0;a<o.length;a++)if(f.indexOf(a)>-1)o[a]=0;else{let u=F(e,t,a),h=r[u];n&1<<u&&(h=0),o[a]=h}return o}function R(n,e,t,r,i){let o=[...i],f=V(t,e);for(let a=0;a<o.length;a++)if(f.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{let u=F(e,t,a),h=r[u];n&1<<u&&(h=Number.MAX_SAFE_INTEGER),o[a]=h}for(let a=0;a<o.length;a++){let u=i[a];o[a]<0&&(o[a]+=u),o[a]=g.clamp(0,o[a],i[a])}return o}function X(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function W(n,e,t,r,i,o){let f=e[i],a=t[i]||1;(n&1<<i||o&1<<i||f==null)&&(a>0?f=Number.MIN_SAFE_INTEGER:f=Number.MAX_SAFE_INTEGER);let u=r[i];return f<0&&(f+=u),f=g.clamp(0,f,u-1),f}function L(n,e,t,r,i,o){let f=e[i],a=t[i]||1;(n&1<<i||o&1<<i||f==null)&&(a>0?f=Number.MAX_SAFE_INTEGER:f=Number.MIN_SAFE_INTEGER);let u=r[i];return f<0&&(f+=u),a>0?f=g.clamp(0,f,u):f=g.clamp(-1,f,u-1),f}function K(n,e,t){let r=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){r=i;break}for(let i=r+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function j(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function q(n,e,t){let r,i=n.shape.length;typeof e=="number"?r=[e,...new Array(i-1).fill(0)]:e.length<i?r=e.concat(new Array(i-e.length).fill(0)):r=e.slice(),r.forEach(f=>{g.assert(f!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(i).fill(-1):typeof t=="number"?o=[t,...new Array(i-1).fill(-1)]:t.length<i?o=t.concat(new Array(i-t.length).fill(-1)):o=t,o=o.map((f,a)=>f>=0?f:(g.assert(f===-1,()=>`Negative size values should be exactly -1 but got ${f} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function J(n,e,t,r,i,o,f,a,u){let h;if(r==null?(h=new Array(e.length),h.fill(1)):h=r,f!=null&&f&f-1)throw new Error("Multiple ellipses in slice is not allowed.");let x=!1,p={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:h.slice(),beginMask:i,endMask:o,ellipsisMask:f,newAxisMask:a,shrinkAxisMask:u};for(let l=0;l<p.dims;l++)x&&1<<l&a&&p.numAddAxisAfterEllipsis++,1<<l&f&&(x=!0);x||(p.ellipsisMask|=1<<p.dims,p.dims++);let s={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};v(p,s);let c=!0,A=!0,k=!0,E=[],I=[];for(let l=0;l<n.length;++l){if(s.strides[l]===0)throw Error(`strides[${l}] must be non-zero`);let m=!!(s.shrinkAxisMask&1<<l),d=n[l];if(d===-1){E.push(m?1:-1);continue}let N=[s.beginMask&1<<l,s.endMask&1<<l],$=[s.strides[l]>0?0:-1,s.strides[l]>0?d:d-1];if(m&&s.strides[l]<=0)throw Error("only stride 1 allowed on non-range indexing.");k=k&&s.strides[l]===1;let M=!!(s.beginMask&1<<l&&s.endMask&1<<l);if(s.beginValid&&s.endValid){if(m){let G=s.begin[l]<0?d+s.begin[l]:s.begin[l];if(s.begin[l]=G,s.end[l]=s.begin[l]+1,G<0||G>=d)throw Error(`slice index ${s.begin[l]} of dimension ${l} out of bounds.`)}else s.begin[l]=_(s.begin[l],0,s.strides[l],d,N,$),s.end[l]=_(s.end[l],1,s.strides[l],d,N,$);let b=s.strides[l]===1&&s.begin[l]===0&&s.end[l]===d;c=c&&b,A=A&&(l===0&&s.strides[l]===1||b)}else c=c&&s.strides[l]===1&&M,A=A&&(l===0&&s.strides[l]===1||M);let S,w=!1;if(s.beginValid&&s.endValid?(S=s.end[l]-s.begin[l],w=!0):m?(S=1,w=!0):M&&d>=0&&(s.strides[l]<0?S=-d:S=d,w=!0),w){let b;S===0||S<0!=s.strides[l]<0?b=0:b=Math.trunc(S/s.strides[l])+(S%s.strides[l]!==0?1:0),E.push(b)}else E.push(-1)}for(let l=0;l<s.finalShapeGatherIndices.length;++l){let m=s.finalShapeGatherIndices[l];m>=0?I.push(E[m]):m===y&&I.push(1)}return{finalShapeSparse:I.filter((l,m)=>s.finalShapeGatherIndices[m]!==y),finalShape:I,isIdentity:c,sliceDim0:A,isSimpleSlice:k,begin:s.begin,end:s.end,strides:s.strides}}function v(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){let i=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(y),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(D),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function _(n,e,t,r,i,o){if(i[e])return t>0?o[e]:o[e+1&1];{let f=n<0?r+n:n;return f<o[0]?o[0]:f>o[1]?o[1]:f}}export{z as assertParamsValid,j as computeFlatOffset,C as computeOutShape,H as getNormalizedAxes,K as isSliceContinous,B as maskToAxes,q as parseSliceParams,J as sliceInfo,W as startForAxis,O as startIndicesWithElidedDims,L as stopForAxis,R as stopIndicesWithElidedDims,X as stridesForAxis,T as stridesWithElidedDims};
/*! Bundled license information:

@tensorflow/tfjs-core/dist/ops/slice_util.js:
  (**
   * @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=slice_util.js.map