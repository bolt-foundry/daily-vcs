/* esm.sh - esbuild bundle(@tensorflow/tfjs-core@4.15.0/dist/util_base) denonext production */
function g(r){let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,a(r,t,n)}function d(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let n=r.length,e=0;for(;n>0;)e=Math.random()*n|0,n--,a(r,n,e),a(t,n,e)}function F(r,t,n){return Math.max(r,Math.min(t,n))}function I(r){return r%2===0?r:r+1}function a(r,t,n){let e=r[t];r[t]=r[n],r[n]=e}function N(r){let t=0;for(let n=0;n<r.length;n++)t+=r[n];return t}function M(r,t){let n=Math.random();return t*n+(1-n)*r}function U(r,t){let n=0;for(let e=0;e<r.length;e++){let o=Number(r[e])-Number(t[e]);n+=o*o}return n}function c(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function k(r,t,n=""){c(w(r,t),()=>n+` Shapes ${r} and ${t} must match`)}function T(r){c(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function q(r){if(r.length===0)return 1;let t=r[0];for(let n=1;n<r.length;n++)t*=r[n];return t}function D(r){return r.length===0}function P(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==null&&t[n]!==null&&r[n]!==t[n])return!1;return!0}function w(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==t[n])return!1;return!0}function p(r){return r%1===0}function B(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function L(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function v(r){let t=new Uint32Array(r);for(let n=0;n<r;++n)t[n]=n;return g(t),t}function V(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function Z(r,t=o=>0,n,e){return new Promise((o,i)=>{let l=0,u=()=>{if(r()){o();return}l++;let f=t(l);if(n!=null&&l>=n){i();return}e!=null?e(u,f):setTimeout(u,f)};u()})}function C(r,t){let n=1,e=-1;for(let i=0;i<r.length;++i)if(r[i]>=0)n*=r[i];else if(r[i]===-1){if(e!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${e} and dim ${i}`);e=i}else if(r[i]<0)throw Error(`Shapes can not be < 0. Found ${r[i]} at dim ${i}`);if(e===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(n===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let o=r.slice();return o[e]=t/n,o}function x(r,t){let n=t.length;return r=r==null?t.map((e,o)=>o):[].concat(r),c(r.every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${r}`),c(r.every(e=>p(e)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(e=>e<0?n+e:e)}function G(r,t){let n=[],e=[],o=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||o?null:x(t,r).sort(),l=0;for(let u=0;u<r.length;++u){if(i!=null){if(i[l]===u&&r[u]!==1)throw new Error(`Can't squeeze axis ${u} since its dim '${r[u]}' is not 1`);(i[l]==null||i[l]>u)&&r[u]===1&&(n.push(r[u]),e.push(u)),i[l]<=u&&l++}r[u]!==1&&(n.push(r[u]),e.push(u))}return{newShape:n,keptDims:e}}function O(r,t){return A(r,t)}function A(r,t){let n=null;if(r==null||r==="float32")n=new Float32Array(t);else if(r==="int32")n=new Int32Array(t);else if(r==="bool")n=new Uint8Array(t);else if(r==="string")n=new Array(t);else throw new Error(`Unknown data type ${r}`);return n}function W(r,t){for(let n=0;n<r.length;n++){let e=r[n];if(isNaN(e)||!isFinite(e))throw Error(`A tensor of type ${t} being uploaded contains ${e}.`)}}function H(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function J(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function K(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function Q(r){if(r==null)return 0;let t=0;return r.forEach(n=>t+=n.length),t}function y(r){return typeof r=="string"||r instanceof String}function $(r){return typeof r=="boolean"}function b(r){return typeof r=="number"}function E(r){return Array.isArray(r)?E(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":b(r)?"float32":y(r)?"string":$(r)?"bool":"float32"}function R(r){return!!(r&&r.constructor&&r.call&&r.apply)}function X(r,t){for(let n=t;n<r;++n)if(r%n===0)return n;return r}function Y(r){let t=r.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=r[t-1];for(let e=t-3;e>=0;--e)n[e]=n[e+1]*r[e+1];return n}function h(r,t,n,e=!1){let o=new Array;if(t.length===1){let i=t[0]*(e?2:1);for(let l=0;l<i;l++)o[l]=n[r+l]}else{let i=t[0],l=t.slice(1),u=l.reduce((f,m)=>f*m)*(e?2:1);for(let f=0;f<i;f++)o[f]=h(r+f*u,l,n,e)}return o}function s(r,t,n=!1){if(r.length===0)return t[0];let e=r.reduce((o,i)=>o*i)*(n?2:1);if(e===0)return[];if(e!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return h(0,r,t,n)}function _(r,t){if(Array.isArray(r))return r;if(t==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(t==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function z(r,t){let n=S(r,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function S(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function j(r,t){let n=r.reduce((e,o)=>e*o,1);if(t==null||t==="float32")return s(r,new Float32Array(n));if(t==="int32")return s(r,new Int32Array(n));if(t==="bool")return s(r,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function rr(r){r.forEach(t=>{c(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function tr(r,t,n){if(t===0)return 0;if(t===1)return r[0];let e=r[r.length-1];for(let o=0;o<r.length-1;++o)e+=n[o]*r[o];return e}function nr(r,t,n){if(t===0)return[];if(t===1)return[r];let e=new Array(t);for(let o=0;o<e.length-1;++o)e[o]=Math.floor(r/n[o]),r-=e[o]*n[o];return e[e.length-1]=r,e}function er(r){return r&&r.then&&typeof r.then=="function"}export{w as arraysEqual,P as arraysEqualWithNull,c as assert,rr as assertNonNegativeIntegerDimensions,T as assertNonNull,k as assertShapesMatch,Q as bytesFromStringArray,K as bytesPerElement,W as checkConversionForErrors,F as clamp,Y as computeStrides,_ as convertBackendValuesAndArrayBuffer,v as createShuffledIndices,U as distSquared,A as getArrayFromDType,O as getTypedArrayFromDType,J as hasEncodingLoss,nr as indexToLoc,E as inferDtype,C as inferFromImplicitShape,$ as isBoolean,R as isFunction,p as isInt,b as isNumber,er as isPromise,D as isScalarShape,y as isString,H as isValidDtype,tr as locToIndex,z as makeOnesTypedArray,j as makeZerosNestedTypedArray,S as makeZerosTypedArray,X as nearestDivisor,I as nearestLargerEven,x as parseAxisParam,M as randUniform,Z as repeatedTry,V as rightPad,g as shuffle,d as shuffleCombo,q as sizeFromShape,L as sizeToSquarishShape,G as squeezeShape,N as sum,a as swap,B as tanh,s as toNestedArray};
/*! Bundled license information:

@tensorflow/tfjs-core/dist/util_base.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=util_base.js.map