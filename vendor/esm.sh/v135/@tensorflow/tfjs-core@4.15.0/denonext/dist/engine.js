/* esm.sh - esbuild bundle(@tensorflow/tfjs-core@4.15.0/dist/engine) denonext production */
import{KernelBackend as z}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/backends/backend.js";import{Environment as G,setEnvironmentGlobal as C}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/environment.js";import{getGlobalNamespace as N}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/global_util.js";import{Add as R,Cast as $,Identity as P}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/kernel_names.js";import{getGradient as D,getKernel as x,getKernelsForBackend as M}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/kernel_registry.js";import*as y from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/log.js";import{Profiler as j}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/profiler.js";import{backpropagateGradients as L,getFilteredNodesXToY as O}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/tape.js";import{setTensorTracker as _,Tensor as m,Variable as V}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/tensor.js";import{getTensorsInContainer as U}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/tensor_util.js";import*as h from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/util.js";import{bytesFromStringArray as W,makeOnesTypedArray as X,now as K,sizeFromShape as Y}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/dist/util.js";function S(l){return l.kernelName!=null}var B=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},I=class l{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new B}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(y.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new j(this.backendInstance),!0}setupRegisteredKernels(){M(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){M(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let s=e.factory();if(s&&!(s instanceof z)&&typeof s.then=="function"){let n=++this.pendingBackendInitId,r=s.then(i=>n<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(n<this.pendingBackendInitId||(this.pendingBackendInit=null,y.warn(`Initialization of backend ${t} failed`),y.warn(i.stack||i.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return y.warn(`Initialization of backend ${t} failed`),y.warn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let s=t[e],{success:n,asyncInit:r}=this.initializeBackend(s);if(r||n)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let s=this.state.tensorInfo.get(e),n=s.backend,r=this.readSync(e),i=n.refCount(e);n.disposeData(e,!0),s.backend=t,t.move(e,r,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let n;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,s){t();try{let n=s();return e(),n}catch(n){throw e(),n}}nextTensorId(){return l.nextTensorId++}nextVariableId(){return l.nextVariableId++}clone(t){let e=v.runKernel(P,{x:t}),s={x:t},n=i=>({x:()=>{let o="float32",a={x:i},c={dtype:o};return v.runKernel($,a,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[e],n,r,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(x(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){let n=this.backend.numDataIds(),r=0;s.forEach(a=>{r+=a.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=n-e-r-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[],n=this.isTapeOn(),r=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let a,c=S(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(S(t)){let{kernelName:d,inputs:w,attrs:b}=t;this.backendName==null&&this.backend;let g=x(d,this.backendName);h.assert(g!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),o=()=>{let A=this.backend.numDataIds();a=g.kernelFunc({inputs:w,attrs:b,backend:this.backend});let F=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,A,F);let E=F.map(T=>T.rank!=null?T:this.makeTensorFromTensorInfo(T));if(n){let T=this.getTensorsForGradient(d,w,E);s=this.saveTensorsForBackwardMode(T)}return E}}else{let{forwardFunc:d}=t,w=b=>{n&&(s=b.map(g=>this.keep(this.clone(g))))};o=()=>{let b=this.backend.numDataIds();a=this.tidy(()=>d(this.backend,w));let g=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,b,g),g}}let{inputs:u,attrs:k}=t,f=S(t)?null:t.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=o():(p=this.profiler.profileKernel(c,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs)}),n&&this.addTapeNode(c,u,e,f,s,k),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(d=>u[d]!=null?u[d].shape:null),outputShapes:e.map(d=>d.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(a)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){let n=D(t);if(n!=null){let r=n.inputsToSave||[],i=n.outputsToSave||[],o;n.saveAllInputs?(h.assert(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(e).map(c=>e[c])):o=r.map(c=>e[c]);let a=s.filter((c,u)=>i[u]);return o.concat(a)}return[]}makeTensor(t,e,s,n){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",n=n||this.backend;let r=t;s==="string"&&h.isString(t[0])&&(r=t.map(a=>h.encodeString(a)));let i=n.write(r,e,s),o=new m(e,s,i,this.nextTensorId());if(this.trackTensor(o,n),s==="string"){let a=this.state.tensorInfo.get(i),c=W(r);this.state.numBytes+=c-a.bytes,a.bytes=c}return o}makeTensorFromDataId(t,e,s,n){s=s||"float32";let r={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(r,n)}makeTensorFromTensorInfo(t,e){let{dataId:s,shape:n,dtype:r}=t,i=new m(n,r,s,this.nextTensorId());return this.trackTensor(i,e),i}makeVariable(t,e=!0,s,n){s=s||this.nextVariableId().toString(),n!=null&&n!==t.dtype&&(t=t.cast(n));let r=new V(t,e,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*h.bytesPerElement(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof V||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let s=t.size*h.bytesPerElement(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(n=>n.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(let n of this.state.activeProfile.kernels)n.kernelTimeMs=await n.kernelTimeMs,n.extraInfo=await n.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,n,r,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:r},a=D(t);a!=null&&(n=a.gradFunc),n!=null&&(o.gradient=c=>(c=c.map((u,k)=>{if(u==null){let f=s[k],p=h.makeZerosTypedArray(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return u}),n(c.length>1?c:c[0],r,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=U(t),s=new Set(e.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){let i=this.state.activeScope.track[r];!i.kept&&!s.has(i.id)&&i.dispose()}let n=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(r=>{!r.kept&&r.scopeId===n.id&&this.track(r)})}gradients(t,e,s,n=!1){if(h.assert(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);let r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));h.assert(r instanceof m,()=>"The result y returned by f() must be a tensor.");let i=O(this.state.activeTape,e,r);if(!n&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[r.id]=s??Z(r.shape),L(o,i,c=>this.tidy(c),H);let a=e.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let u of c.saved)u.dispose()}),this.state.activeTape=null),{value:r,grads:a}})}customGrad(t){return h.assert(h.isFunction(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{h.assert(e.every(o=>o instanceof m),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s,n={};e.forEach((o,a)=>{n[a]=o});let r=(o,a)=>(s=t(...e,a),h.assert(s.value instanceof m,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),h.assert(h.isFunction(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(o,a)=>{let c=s.gradFunc(o,a),u=Array.isArray(c)?c:[c];h.assert(u.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),h.assert(u.every(f=>f instanceof m),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let k={};return u.forEach((f,p)=>{k[p]=()=>f}),k};return this.runKernelFunc({forwardFunc:r,backwardsFunc:i,inputs:n})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){let e=K(),s=await this.backend.time(t);return s.wallMs=K()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new B;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};I.nextTensorId=0;I.nextVariableId=0;function Z(l){let t=X(Y(l),"float32");return v.makeTensor(t,l,"float32")}function q(){let l=N();if(l._tfengine==null){let t=new G(l);l._tfengine=new I(t)}return C(l._tfengine.ENV),_(()=>l._tfengine),l._tfengine}var v=q();function H(l,t){let e={a:l,b:t};return v.runKernel(R,e)}export{v as ENGINE,I as Engine,H as add,q as getOrMakeEngine};
/*! Bundled license information:

@tensorflow/tfjs-core/dist/engine.js:
  (**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=engine.js.map