/* esm.sh - esbuild bundle(@tensorflow/tfjs-backend-webgl@4.15.0/dist/kernels/Conv2D_impl) denonext production */
import{util as D}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/tfjs-core.mjs";import{Im2ColPackedProgram as q}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/im2col_packed_gpu.js";import{mapActivationToShaderProgram as W}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/kernel_utils/kernel_funcs_utils.js";import{MatMulPackedProgram as j}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/mulmat_packed_gpu.js";import*as U from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/webgl_util.js";import{batchMatMulImpl as O,MATMUL_SHARED_DIM_THRESHOLD as J}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/kernels/BatchMatMul_impl.js";import{identity as K}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/kernels/Identity.js";import{reshape as n}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/kernels/Reshape.js";function T(a,d){let t=a.length;return t>=3?d?[...a.slice(0,-3),a[t-3]*a[t-2],a[t-1]]:[...a.slice(0,-3),a[t-3],a[t-2]*a[t-1]]:!d&&t===1&&a[0]>1?[a[0],1]:null}function I({x:a,filter:d,convInfo:t,backend:s,bias:l=null,preluActivationWeights:h=null,leakyreluAlpha:R=0,activation:g=null}){let i=a.shape,p=s.texData.get(a.dataId),z=t.inChannels,H=i[0]*i[1]*i[2],L=t.outChannels,m=t.dataFormat==="channelsLast",S=!1,f=!1,C,u=[];if(h!=null){let e=T(h.shape,m);e!=null&&(h=n({inputs:{x:h},backend:s,attrs:{shape:e}}),u.push(h))}if(l!=null){let e=T(l.shape,m);e!=null&&(l=n({inputs:{x:l},backend:s,attrs:{shape:e}}),u.push(l))}if(!((H===1||L===1)&&z>J)&&p.isPacked&&m&&p.texture!=null&&i[2]%2!==0&&D.arraysEqual(p.shape.slice(-3),i.slice(-3))){let e=i[0]*i[1]*(i[2]+1),r={dataId:a.dataId,shape:[1,e,t.inChannels],dtype:a.dtype},x=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,D.assert(U.isReshapeFree(p.shape,r.shape),()=>`packed reshape ${p.shape} to ${r.shape} isn't free`);let M=n({inputs:{x:d},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});u.push(M);let P=O({a:r,b:M,backend:s,transposeA:S,transposeB:f,bias:l,activation:g,preluActivationWeights:h,leakyreluAlpha:R}),c=s.texData.get(P.dataId);D.assert(c.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=x,c.shape=t.outShape,C=K({inputs:{x:P},backend:s}),C.shape=t.outShape,u.push(P)}else{let e=t.outHeight*t.outWidth,r=n({inputs:{x:a},backend:s,attrs:{shape:m?[t.batchSize,e,t.inChannels]:[t.batchSize,t.inChannels,e]}}),x=n({inputs:{x:d},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),M=O({a:m?r:x,b:m?x:r,transposeA:!m,transposeB:f,backend:s,bias:l,activation:g,preluActivationWeights:h,leakyreluAlpha:R});C=n({inputs:{x:M},backend:s,attrs:{shape:t.outShape}}),u.push(r),u.push(x),u.push(M)}for(let e of u)s.disposeIntermediateTensorInfo(e);return C}function v({x:a,filter:d,convInfo:t,backend:s,bias:l=null,preluActivationWeights:h=null,leakyreluAlpha:R=0,activation:g=null}){let{filterWidth:i,filterHeight:p,inChannels:z,outWidth:H,outHeight:L,dataFormat:m}=t,S=m==="channelsLast",f=i*p*z,C=L*H,u=[t.batchSize,f,C],y=!0,B=!1,e=[];if(h!=null){let o=T(h.shape,S);o!=null&&(h=n({inputs:{x:h},backend:s,attrs:{shape:o}}),e.push(h))}if(l!=null){let o=T(l.shape,S);o!=null&&(l=n({inputs:{x:l},backend:s,attrs:{shape:o}}),e.push(l))}let r=n({inputs:{x:d},backend:s,attrs:{shape:[1,f,D.sizeFromShape(d.shape)/f]}});e.push(r);let x=new q(u,t),M=[a.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],P=s.runWebGLProgram(x,[a],"float32",M),c=n({inputs:{x:P},backend:s,attrs:{shape:u}});e.push(P),e.push(c);let $=l!=null,F=h!=null,_=g==="leakyrelu",G=g?W(g,!0):null,V=new j(S?c.shape:r.shape,S?r.shape:c.shape,S?[t.batchSize,C,t.outChannels]:[t.batchSize,t.outChannels,C],y,B,$,G,F,_),w=S?[c,r]:[r,c];if(l&&w.push(l),F&&w.push(h),_){let o=s.makeTensorInfo([],"float32",D.createScalarValue(R,"float32"));w.push(o),e.push(o)}let E=s.runWebGLProgram(V,w,"float32"),X=n({inputs:{x:E},backend:s,attrs:{shape:t.outShape}});e.push(E);for(let o of e)s.disposeIntermediateTensorInfo(o);return X}export{I as conv2dByMatMul,v as conv2dWithIm2Row};
/*! Bundled license information:

@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=Conv2D_impl.js.map