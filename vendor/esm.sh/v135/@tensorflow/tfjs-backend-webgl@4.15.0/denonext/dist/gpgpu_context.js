/* esm.sh - esbuild bundle(@tensorflow/tfjs-backend-webgl@4.15.0/dist/gpgpu_context) denonext production */
import{env as u,util as g}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/tfjs-core.mjs";import{getWebGLContext as d,setWebGLContext as x}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/canvas_util.js";import*as l from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/gpgpu_util.js";import*as a from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/tex_util.js";import*as i from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/webgl_util.js";var f=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=u().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,x(t,e)):this.gl=d(t),e=this.gl,u().getNumber("WEBGL_VERSION")===2){let o=e;this.createVertexArray=()=>i.callAndCheck(o,()=>o.createVertexArray()),this.bindVertexArray=n=>i.callAndCheck(o,()=>o.bindVertexArray(n)),this.deleteVertexArray=n=>i.callAndCheck(o,()=>o.deleteVertexArray(n)),this.getVertexArray=()=>i.callAndCheck(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){let o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>i.callAndCheck(e,()=>o.createVertexArrayOES()),this.bindVertexArray=n=>i.callAndCheck(e,()=>o.bindVertexArrayOES(n)),this.deleteVertexArray=n=>i.callAndCheck(e,()=>o.deleteVertexArrayOES(n)),this.getVertexArray=()=>i.callAndCheck(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),u().getNumber("WEBGL_VERSION")===1){let o="OES_texture_float",n="OES_texture_half_float";if(this.textureFloatExtension=i.getExtensionOrThrow(this.gl,o),i.hasExtension(this.gl,n))this.textureHalfFloatExtension=i.getExtensionOrThrow(this.gl,n);else if(u().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),i.hasExtension(this.gl,s))this.colorBufferHalfFloatExtension=i.getExtensionOrThrow(this.gl,s);else if(u().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",i.hasExtension(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(i.hasExtension(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=l.createVertexBuffer(this.gl),this.indexBuffer=l.createIndexBuffer(this.gl),this.framebuffer=i.createFramebuffer(this.gl),this.textureConfig=a.getTextureConfig(this.gl,this.textureHalfFloatExtension)}get debug(){return u().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;i.callAndCheck(e,()=>e.finish()),i.callAndCheck(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),i.callAndCheck(e,()=>e.deleteFramebuffer(this.framebuffer)),i.callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),i.callAndCheck(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),i.callAndCheck(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),l.createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),l.createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),l.createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),l.uploadPixelDataToTexture(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),l.uploadDenseMatrixToTexture(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),l.createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),l.createPackedMatrixTexture(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(i.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),i.callAndCheck(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>l.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,o,n){return l.downloadPackedMatrixFromBuffer(this.gl,e,t,r,s,o,n,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return l.downloadFloat32MatrixFromBuffer(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);let s=l.createBufferFromOutputTexture(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(u().getBool("WEBGL_FENCE_API_ENABLED")){let s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{let n=s.clientWaitSync(o,0,0);return n===s.ALREADY_SIGNALED||n===s.CONDITION_SATISFIED},t=o}else u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>l.downloadMatrixFromPackedOutputTexture(this.gl,t,r))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=l.createVertexShader(t));let r=i.createProgram(t);i.callAndCheck(t,()=>t.attachShader(r,this.vertexShader)),i.callAndCheck(t,()=>t.attachShader(r,e)),i.linkProgram(t,r);let s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&i.validateProgram(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;i.callAndCheck(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),l.bindVertexProgramAttributeStreams(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(i.callAndCheck(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&i.validateProgram(this.gl,this.program),i.callAndCheck(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?i.getProgramUniformLocationOrThrow(this.gl,e,t):i.getProgramUniformLocation(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),i.callAndCheck(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),i.bindTextureToProgramUniformSampler(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();let[s,o]=a.getPackedMatrixTextureShapeWidthHeight(t,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&i.validateProgram(this.gl,this.program),i.validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}i.callAndCheck(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),i.callAndCheck(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=i.getExtensionOrThrow(this.gl,u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await g.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=_(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in u().platform&&(r=u().platform.setTimeoutCustom.bind(u().platform)),g.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),i.bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.debug&&i.validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(i.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&i.validateFramebuffer(this.gl)):i.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();let s=this.gl;i.bindColorTextureToFramebuffer(s,e,this.framebuffer),this.debug&&i.validateFramebuffer(s),this.outputTexture=e,i.callAndCheck(s,()=>s.viewport(0,0,t,r)),i.callAndCheck(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),i.callAndCheck(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function _(h){let e=0;for(;e<h.length&&h[e]();++e);return e-1}export{f as GPGPUContext,_ as linearSearchLastTrue};
/*! Bundled license information:

@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=gpgpu_context.js.map