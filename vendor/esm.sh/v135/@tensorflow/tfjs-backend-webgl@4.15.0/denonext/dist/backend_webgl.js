/* esm.sh - esbuild bundle(@tensorflow/tfjs-backend-webgl@4.15.0/dist/backend_webgl) denonext production */
import"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/flags_webgl.js";import{backend_util as G,buffer as R,DataStorage as W,engine as I,env as u,kernel_impls as v,KernelBackend as V,nextFrame as H,scalar as Q,tidy as z,util as d}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/tfjs-core.mjs";import{getWebGLContext as M}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/canvas_util.js";import{DecodeMatrixProgram as K}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/decode_matrix_gpu.js";import{DecodeMatrixPackedProgram as Y}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/decode_matrix_packed_gpu.js";import{EncodeFloatProgram as j}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/encode_float_gpu.js";import{EncodeFloatPackedProgram as J}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/encode_float_packed_gpu.js";import{EncodeMatrixProgram as F}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/encode_matrix_gpu.js";import{EncodeMatrixPackedProgram as X}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/encode_matrix_packed_gpu.js";import{GPGPUContext as O}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/gpgpu_context.js";import*as y from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/gpgpu_math.js";import{getUniformLocations as $}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/gpgpu_math.js";import{simpleAbsImplCPU as q}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/kernel_utils/shared.js";import{PackProgram as Z}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/pack_gpu.js";import{ReshapePackedProgram as ee}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/reshape_packed_gpu.js";import*as _ from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/tex_util.js";import{TextureUsage as k}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/tex_util.js";import{TextureManager as te}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/texture_manager.js";import*as w from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/unaryop_gpu.js";import{UnaryOpProgram as A}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/unaryop_gpu.js";import{UnaryOpPackedProgram as B}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/unaryop_packed_gpu.js";import{UnpackProgram as se}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/unpack_gpu.js";import*as f from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/webgl_util.js";var ae=v.whereImpl,re=1e-7,ne=1e-4,C={};function oe(P){return P in C||(C[P]={}),C[P]}var ie=u().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),le=600;function ue(){return u().global.screen==null?1024:u().global.screen.height*u().global.screen.width*window.devicePixelRatio*le/1024/1024}var N=class P extends V{nextDataId(){return P.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!u().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof O)t=e;else{let s=M(u().getNumber("WEBGL_VERSION"),e);t=new O(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let s=M(u().getNumber("WEBGL_VERSION"));t=new O(s),this.binaryCache=oe(u().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new te(this.gpgpu),this.numMBBeforeWarning=ue(),this.texData=new W(this,I())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,a,o,l){let n=this.makeTensorInfo(t,s),r=this.texData.get(n.dataId);r.isPacked=!1,r.texture={texture:e,texShape:[a,o]},r.texShape=[a,o];let i=f.getShapeAs3D(t),h=new F(i,!1,l),g=this.runWebGLProgram(h,[n],s,[[a,o]]);return g.shape=t,r.texture=null,this.disposeIntermediateTensorInfo(n),g.dataId}write(e,t,s){if((u().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||u().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:s,values:e,usage:k.UPLOAD,refCount:1}),a}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,s,a,o){if(u().getBool("DEBUG")&&this.checkNumericalProblems(t),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:a,values:t,usage:k.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:s,dtype:a,complexTensorInfos:o,slice:l,shape:n,isPacked:r}=t;if(l!=null){let m;r?m=new B(n,w.CLONE):m=new A(n,w.CLONE);let x=this.runWebGLProgram(m,[{dataId:e,shape:n,dtype:a}],a),c=this.readSync(x.dataId);return this.disposeIntermediateTensorInfo(x),c}if(s!=null)return this.convertAndCacheOnCPU(e);if(a==="string")return s;let i=this.activeTimers!=null,h;i&&(h=d.now());let g;if(a==="complex64"){let m=this.readSync(o.real.dataId),x=this.readSync(o.imag.dataId);g=G.mergeRealAndImagArrays(m,x)}else g=this.getValuesFromTexture(e);return i&&(this.downloadWaitMs+=d.now()-h),this.convertAndCacheOnCPU(e,g)}async read(e){if(this.pendingRead.has(e)){let c=this.pendingRead.get(e);return new Promise(D=>c.push(D))}let t=this.texData.get(e),{values:s,shape:a,slice:o,dtype:l,complexTensorInfos:n,isPacked:r}=t;if(o!=null){let c;r?c=new B(a,w.CLONE):c=new A(a,w.CLONE);let D=this.runWebGLProgram(c,[{dataId:e,shape:a,dtype:l}],l),E=this.read(D.dataId);return this.disposeIntermediateTensorInfo(D),E}if(s!=null)return this.convertAndCacheOnCPU(e);if(u().getBool("DEBUG")&&!u().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&u().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let i=null,h;if(l!=="complex64"&&u().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);let c=this.texData.get(h.dataId);i=this.gpgpu.createBufferFromTexture(c.texture.texture,..._.getDenseTexShape(a))}this.pendingRead.set(e,[]),l!=="complex64"&&await this.gpgpu.createAndWaitForFence();let g;if(l==="complex64"){let c=await Promise.all([this.read(n.real.dataId),this.read(n.imag.dataId)]),D=c[0],E=c[1];g=G.mergeRealAndImagArrays(D,E)}else if(i==null)g=this.getValuesFromTexture(e);else{let c=d.sizeFromShape(a);g=this.gpgpu.downloadFloat32MatrixFromBuffer(i,c)}if(h!=null&&this.disposeIntermediateTensorInfo(h),i!=null){let c=this.gpgpu.gl;f.callAndCheck(c,()=>c.deleteBuffer(i))}let m=this.convertAndCacheOnCPU(e,g),x=this.pendingRead.get(e);return this.pendingRead.delete(e),x.forEach(c=>c(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&I().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){let s=this.texData.get(e),{values:a,shape:o,slice:l,dtype:n,isPacked:r,texture:i}=s;if(n==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(l!=null){let x;r?x=new B(o,w.CLONE):x=new A(o,w.CLONE);let c=this.runWebGLProgram(x,[{dataId:e,shape:o,dtype:n}],n),D=this.readToGPU(c,t);return this.disposeIntermediateTensorInfo(c),D}if(i==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let h=this.decode(e,t.customTexShape),g=I().makeTensorFromTensorInfo(h),m=this.texData.get(h.dataId);return Object.assign({tensorRef:g},m.texture)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let s=t.map(a=>d.decodeString(a));return R(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return R(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let s=e[t];if(!f.canBeRepresented(s))throw u().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:s,isPacked:a}=this.texData.get(e),o=d.sizeFromShape(t);if(u().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(e),x=this.texData.get(m.dataId),c=this.gpgpu.downloadMatrixFromPackedTexture(x.texture.texture,..._.getDenseTexShape(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(m),c}let l=u().getBool("WEBGL_PACK")&&a===!0,n=l?f.getShapeAs3D(t):t,r=l?new J(n):new j(n),i=this.runWebGLProgram(r,[{shape:n,dtype:s,dataId:e}],"float32"),h=this.texData.get(i.dataId),g=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(i),g}timerAvailable(){return u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,s=[],a=!1;this.programTimersStack==null?(this.programTimersStack=s,a=!0):this.activeTimers.push(s),this.activeTimers=s,e();let o=d.flatten(this.activeTimers.map(r=>r.query)).filter(r=>r!=null),l=d.flatten(this.activeTimers.map(r=>r.name)).filter(r=>r!=null);this.activeTimers=t,a&&(this.programTimersStack=null);let n={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let r=await Promise.all(o);n.kernelMs=d.sum(r),n.getExtraProfileInfo=()=>r.map((i,h)=>({name:l[h],ms:i})).map(i=>`${i.name}: ${i.ms}`).join(", ")}else n.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,n})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:d.now(),endMs:null}}endTimer(e){return u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=d.now(),e)}async getQueryTime(e){if(u().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:s,texShape:a,usage:o,isPacked:l,slice:n}=this.texData.get(e),r=n&&n.origDataId||e,i=this.dataRefCount.get(r);i>1?this.dataRefCount.set(r,i-1):(this.dataRefCount.delete(r),t!=null&&(this.numBytesInGPU-=this.computeBytes(a,s),this.textureManager.releaseTexture(t,a,o,l)));let h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=ie){return u().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&d.sizeFromShape(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){G.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return ae(e.shape,t)}packedUnaryOp(e,t,s){let a=new B(e.shape,t),o=this.compileAndRun(a,[e],s);return I().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let a=q(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,a)}if(u().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,w.ABS,e.dtype);let t=new A(e.shape,w.ABS),s=this.compileAndRun(t,[e]);return I().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let a;if(t==="string"&&s!=null&&s.length>0&&d.isString(s[0])){let o=s.map(l=>d.encodeString(l));a=this.write(o,e,t)}else a=this.write(s,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,s){return I().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){let t=new se(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new Z(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let s=[f.getBatchDim(e.shape),...f.getRowsCols(e.shape)],a={dtype:e.dtype,shape:s,dataId:e.dataId},o=[f.getBatchDim(t),...f.getRowsCols(t)],l=new ee(o,s),n=!0,r=[s],i=this.runWebGLProgram(l,[a],e.dtype,r,n);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){let s=this.texData.get(e),{isPacked:a,shape:o,dtype:l}=s;if(t!=null){let m=d.sizeFromShape(o),x=t[0]*t[1]*4;d.assert(m<=x,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let n=f.getShapeAs3D(o),r;a?r=new Y(n):r=new K(n);let i=!0,h=[t??_.getDenseTexShape(n)],g=this.runWebGLProgram(r,[{shape:n,dtype:l,dataId:e}],l,h,i,t);return{dtype:l,shape:o,dataId:g.dataId}}runWebGLProgram(e,t,s,a,o=!1,l){let n=this.makeTensorInfo(e.outputShape,s),r=this.texData.get(n.dataId);if(e.packedOutput&&(r.isPacked=!0),e.outPackingScheme===_.PackingScheme.DENSE){let p=l??_.getDenseTexShape(e.outputShape);r.texShape=p.map(T=>T*2)}if(e.outTexUsage!=null&&(r.usage=e.outTexUsage),d.sizeFromShape(n.shape)===0)return r.values=d.getTypedArrayFromDType(n.dtype,0),n;let i=[],h=t.map(p=>{if(p.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(p.dataId);if(T.texture==null){if(!e.packedInputs&&d.sizeFromShape(p.shape)<=u().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:p.shape,texData:null,isUniform:!0,uniformValues:T.values};e.packedInputs&&(T.isPacked=!0,T.shape=p.shape)}if(this.uploadToGPU(p.dataId),!!T.isPacked!=!!e.packedInputs)p=T.isPacked?this.unpackTensor(p):this.packTensor(p),i.push(p),T=this.texData.get(p.dataId);else if(T.isPacked&&!f.isReshapeFree(T.shape,p.shape)){let L=p,S=p.shape;p.shape=T.shape,p=this.packedReshape(p,S),i.push(p),T=this.texData.get(p.dataId),L.shape=S}return{shape:p.shape,texData:T,isUniform:!1}});this.uploadToGPU(n.dataId);let g={shape:n.shape,texData:r,isUniform:!1},m=y.makeShaderKey(e,h,g),x=this.getAndSaveBinary(m,()=>y.compileProgram(this.gpgpu,e,h,g)),c=this.activeTimers!=null,D;c&&(D=this.startTimer()),u().get("ENGINE_COMPILE_ONLY")||y.runProgram(this.gpgpu,x,h,g,a),i.forEach(p=>this.disposeIntermediateTensorInfo(p)),c&&(D=this.endTimer(D),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(D)}));let E=u().getNumber("WEBGL_FLUSH_THRESHOLD");if(E>0){let p=d.now();p-this.lastGlFlushTime>E&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=p)}if(!u().getBool("WEBGL_LAZILY_UNPACK")&&r.isPacked&&o===!1){let p=this.unpackTensor(n);return this.disposeIntermediateTensorInfo(n),p}return n}compileAndRun(e,t,s,a,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,a,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(u().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=z(()=>{if(!u().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=u().getBool("DEBUG");u().set("DEBUG",!1);let t=this.abs(Q(1e-8)).dataSync()[0];if(u().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?re:ne}uploadToGPU(e){let t=this.texData.get(e),{shape:s,dtype:a,values:o,texture:l,usage:n,isPacked:r}=t;if(l!=null)return;let i=this.activeTimers!=null,h;i&&(h=d.now());let g=t.texShape;if(g==null&&(g=f.getTextureShapeFromLogicalShape(s,r),t.texShape=g),o!=null){let m=f.getShapeAs3D(s),x,c=g[1],D=g[0],E=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(r||!E)&&([c,D]=_.getPackedMatrixTextureShapeWidthHeight(g[0],g[1])),r?x=new X(m,E):x=new F(m,E);let p=E?[D,c]:g,T=this.makeTensorInfo(p,a),L=this.texData.get(T.dataId);E?L.usage=k.PIXELS:L.usage=k.UPLOAD,L.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),c,D,o);let S=[[D,c]],U=this.runWebGLProgram(x,[T],a,S,!0),b=this.texData.get(U.dataId);t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,u().get("ENGINE_COMPILE_ONLY")?this.disposeData(U.dataId):(t.texture=b.texture,t.values=null,this.texData.delete(U.dataId)),this.disposeIntermediateTensorInfo(T),i&&(this.uploadWaitMs+=d.now()-h)}else{let m=this.acquireTexture(g,n,a,r);t.texture=m}}convertAndCacheOnCPU(e,t){let s=this.texData.get(e),{dtype:a}=s;return t!=null&&(s.values=he(t,a)),s.values}acquireTexture(e,t,s,a){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*d.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let s=new Promise(a=>{try{this.checkCompletion_(t),a(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await H(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(f.logShaderSourceAndInfoLog(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:s,infLoc:a,nanLoc:o,outShapeLocation:l,outShapeStridesLocation:n,outTexShapeLocation:r}=$(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=a,e.nanLoc=o,e.outShapeLocation=l,e.outShapeStridesLocation=n,e.outTexShapeLocation=r}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";let{texture:a,height:o,width:l,channels:n}=e,r=I().backend;if(!r.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let i=r.writeTexture(a,t,s,o,l,n);return I().makeTensorFromDataId(i,t,s,r)}};N.nextDataId=0;function he(P,e){if(e==="float32"||e==="complex64")return P;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(P.length):new Uint8Array(P.length);for(let s=0;s<t.length;++s)t[s]=Math.round(P[s]);return t}else throw new Error(`Unknown dtype ${e}`)}export{ne as EPSILON_FLOAT16,re as EPSILON_FLOAT32,N as MathBackendWebGL,oe as getBinaryCache};
/*! Bundled license information:

@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=backend_webgl.js.map