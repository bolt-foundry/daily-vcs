/* esm.sh - esbuild bundle(@tensorflow/tfjs-backend-webgl@4.15.0/dist/gpgpu_math) denonext production */
import{backend_util as E,env as L,util as u}from"/v135/@tensorflow/tfjs-core@4.15.0/denonext/tfjs-core.mjs";import*as v from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/shader_compiler.js";import{createFragmentShader as w}from"/v135/@tensorflow/tfjs-backend-webgl@4.15.0/denonext/dist/webgl_util.js";function N(e,a,r,s){let m=r.map((t,f)=>{let h={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:t.isUniform?!1:t.texData.isPacked,flatOffset:null};return t.texData!=null&&t.texData.slice!=null&&t.texData.slice.flatOffset>0&&(h.flatOffset=t.texData.slice.flatOffset),{name:a.variableNames[f],shapeInfo:h}}),l=m.map(t=>t.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},c=v.makeShader(m,i,a),n=w(e.gl,c),o=e.createProgram(n);return L().get("ENGINE_COMPILE_ONLY")?{program:a,fragmentShader:n,source:c,webGLProgram:o,inShapeInfos:l,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(o),Object.assign({program:a,fragmentShader:n,source:c,webGLProgram:o,inShapeInfos:l,outShapeInfo:i},O(e,a,o)))}function O(e,a,r){let s=[],m=[],l,i,c,n=null,o=null;o=e.getUniformLocation(r,"NAN",!1),L().getNumber("WEBGL_VERSION")===1&&(n=e.getUniformLocation(r,"INFINITY",!1));let t=!1;for(let f of a.variableNames){let h={name:f,uniform:e.getUniformLocation(r,f,t),offset:e.getUniformLocation(r,`offset${f}`,t)};a.enableShapeUniforms&&(h.shape=e.getUniformLocation(r,`${f}Shape`,t),h.texShape=e.getUniformLocation(r,`${f}TexShape`,t)),s.push(h)}if(a.enableShapeUniforms&&(l=e.getUniformLocation(r,"outShape",t),c=e.getUniformLocation(r,"outShapeStrides",t),i=e.getUniformLocation(r,"outTexShape",t)),a.customUniforms)for(let f of a.customUniforms)m.push(e.getUniformLocation(r,f.name,t));return{variablesLocations:s,customUniformLocations:m,infLoc:n,nanLoc:o,outShapeLocation:l,outShapeStridesLocation:c,outTexShapeLocation:i}}function U(e,a){if(e.length!==a.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${a.length} inputs`);e.forEach((r,s)=>{let m=r.logicalShape,l=a[s],i=l.shape;if(!u.arraysEqual(m,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${m} and ${i} must match`);if(r.isUniform&&l.isUniform)return;let c=r.texShape,n=l.isUniform?null:l.texData.texShape;if(!u.arraysEqual(c,n))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${c} and ${n} must match`)})}function y(e,a,r,s,m){a.program.enableShapeUniforms||(U(a.inShapeInfos,r),U([a.outShapeInfo],[s]));let l=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?e.setOutputPackedMatrixTexture(l.texture,i[0],i[1]):e.setOutputMatrixTexture(l.texture,i[0],i[1]),e.setProgram(a.webGLProgram),e.bindVertexArray(a.webGLProgram.vao),L().getNumber("WEBGL_VERSION")===1&&a.infLoc!==null&&e.gl.uniform1f(a.infLoc,1/0),a.nanLoc!==null&&e.gl.uniform1f(a.nanLoc,NaN);for(let n=0;n<r.length;++n){let o=r[n],{uniform:t,offset:f,shape:h,texShape:d}=a.variablesLocations[n];if(h){let{uniformShape:S}=v.getUniformInfoFromShape(a.program.packedInputs,o.shape,o.texData.texShape);switch(S.length){case 1:e.gl.uniform1iv(h,new Int32Array(S));break;case 2:e.gl.uniform2iv(h,new Int32Array(S));break;case 3:e.gl.uniform3iv(h,new Int32Array(S));break;case 4:e.gl.uniform4iv(h,new Int32Array(S));break;default:break}}if(d&&e.gl.uniform2i(d,o.texData.texShape[0],o.texData.texShape[1]),t!=null){if(o.isUniform){if(u.sizeFromShape(o.shape)<2)e.gl.uniform1f(t,o.uniformValues[0]);else{let S=o.uniformValues;S instanceof Float32Array||(S=new Float32Array(S)),e.gl.uniform1fv(t,S)}continue}o.texData.slice!=null&&f!=null&&e.gl.uniform1i(f,o.texData.slice.flatOffset),e.setInputMatrixTexture(o.texData.texture.texture,t,n)}}let c=a.outShapeLocation;if(c)switch(s.shape.length){case 1:e.gl.uniform1iv(c,new Int32Array(s.shape));break;case 2:e.gl.uniform2iv(c,new Int32Array(s.shape));break;case 3:e.gl.uniform3iv(c,new Int32Array(s.shape));break;case 4:e.gl.uniform4iv(c,new Int32Array(s.shape));break;default:break}if(a.outShapeStridesLocation){let n=u.computeStrides(s.shape);switch(s.shape.length){case 2:e.gl.uniform1iv(a.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(a.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(a.outShapeStridesLocation,new Int32Array(n));break;default:break}}if(a.outTexShapeLocation&&e.gl.uniform2i(a.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),a.program.customUniforms&&m)for(let n=0;n<a.program.customUniforms.length;++n){let o=a.program.customUniforms[n],t=a.customUniformLocations[n],f=m[n];if(o.type==="float")e.gl.uniform1fv(t,f);else if(o.type==="vec2")e.gl.uniform2fv(t,f);else if(o.type==="vec3")e.gl.uniform3fv(t,f);else if(o.type==="vec4")e.gl.uniform4fv(t,f);else if(o.type==="int")e.gl.uniform1iv(t,f);else if(o.type==="ivec2")e.gl.uniform2iv(t,f);else if(o.type==="ivec3")e.gl.uniform3iv(t,f);else if(o.type==="ivec4")e.gl.uniform4iv(t,f);else throw Error(`uniform type ${o.type} is not supported yet.`)}e.executeProgram()}function B(e,a,r){let s="";a.concat(r).forEach(i=>{let c=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let n=i.texData.texShape,{useSqueezeShape:o,uniformShape:t,keptDims:f}=v.getUniformInfoFromShape(e.packedInputs,i.shape,n),h="",d="",S="";if(t.length===1&&e.packedInputs){let x=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];h=`${x[0]>1}_${x[1]>1}`}else if(t.length===2&&!e.packedInputs)d=`${t[0]>1}_${t[1]>1}`;else if(t.length>2&&!e.packedInputs){let x=u.computeStrides(t);S=`${x[0]===n[1]}_${x[x.length-1]===n[1]}`}let k=i.shape.length,I=t.length===2&&u.arraysEqual(i.shape,n),$=u.sizeFromShape(i.shape)===1,_=E.getBroadcastDims(i.shape,r.shape),D=!e.packedInputs&&k===r.shape.length&&u.arraysEqual(n,r.texData.texShape),p=e.packedInputs||t.length>2?"":`${n[0]>1}_${n[1]>1}`;s+=`${k}_${D}_${o?f:""}_${t.length}_${$}_${_}_${I}_${h}_${d}_${S}_${p}_${c}`}else{let n=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${n}_${c}`}});let m=e.userCode,l=e.constructor.name;return l+="_"+s+"_"+m+`${L().getNumber("WEBGL_VERSION")}`,l}function F(e){return L().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}export{N as compileProgram,O as getUniformLocations,B as makeShaderKey,y as runProgram,F as useShapeUniforms};
/*! Bundled license information:

@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js:
  (**
   * @license
   * Copyright 2017 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=gpgpu_math.js.map