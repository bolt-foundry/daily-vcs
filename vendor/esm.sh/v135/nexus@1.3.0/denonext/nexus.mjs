/* esm.sh - esbuild bundle(nexus@1.3.0) denonext production */
import __Process$ from "node:process";
import { Buffer as __Buffer$ } from "node:buffer";
var __rResolve$ = p => p;
import * as __0$ from "node:util";
import * as __1$ from "node:fs";
import * as __2$ from "node:util";
import * as __3$ from "node:fs";
import * as __4$ from "node:util";
import * as __5$ from "/v135/prettier@3.1.1/denonext/prettier.mjs";
var require=n=>{const e=m=>typeof m.default<"u"?m.default:m,c=m=>Object.assign({},m);switch(n){case"util":return e(__0$);case"fs":return e(__1$);case"prettier":return e(__5$);default:throw new Error("module \""+n+"\" not found");}};
var ur=Object.defineProperty;var Ee=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});var lr=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),Fe=(n,e)=>{for(var t in e)ur(n,t,{get:e[t],enumerable:!0})};var Hn=lr((So,hr)=>{hr.exports={name:"nexus",version:"1.3.0",description:"Scalable, strongly typed GraphQL schema development",keywords:["graphql","schema","types","typescript"],homepage:"https://nexusjs.org",repository:{type:"git",url:"git://github.com/graphql-nexus/nexus.git"},license:"MIT",author:{name:"Tim Griesser",url:"https://github.com/tgriesser"},files:["src","dist","dist-esm","LICENSE.md","README.md","yarn.lock"],main:"dist",module:"dist-esm",types:"dist/index.d.ts",scripts:{build:"yarn -s clean && tsc -p tsconfig.cjs.json && tsc -p tsconfig.esm.json",clean:"rm -rf dist*","deploy-site":"yarn && yarn build",dev:"tsc -p tsconfig.cjs.json -w","dev:examples":"yarn -s link-examples && yarn dev","dev:test":"jest --watch",examples:"yarn link-examples && yarn gulp run-examples",format:"prettier --write 'src/**/*.ts' 'tests/**/*.ts' 'examples/*/src/**.ts'","format:ci":"prettier --check 'src/**/*.ts' 'tests/**/*.ts' 'examples/*/src/**.ts'","link-examples":"yarn && yarn gulp link-examples",lint:"tslint -p tsconfig.json",prepublish:"yarn clean && yarn build",postpublish:"yarn upgrade-deps || echo 'Oops...'","release:pr":"dripip pr","release:preview":"dripip preview","release:stable":"dripip stable",test:"yarn test:types && jest --testTimeout 10000","test:ci":"yarn test:types && jest --maxWorkers 2 --coverage --testTimeout 10000","test:debug":"node --inspect-brk $(yarn bin)/jest -i --watch","test:types":"tsc -p tsconfig.spec.types.json","ts-ast-reader":"cd examples/ts-ast-reader && yarn start","unlink-examples":"yarn && yarn gulp unlink-examples","upgrade-deps":"yarn && yarn gulp upgrade-deps"},husky:{hooks:{"pre-commit":"lint-staged"}},"lint-staged":{"*.{ts,js,graphql,json,css,md}":["prettier --write","git add"],"*package.json":["sort-package-json","git add"]},dependencies:{iterall:"^1.3.0",tslib:"^2.0.3"},devDependencies:{"@types/graphql-iso-date":"^3.4.0","@types/graphql-relay":"^0.4.11","@types/jest":"^26.0.15","@types/node":"^10.12.2","@types/prettier":"^1.18.3","@typescript-eslint/eslint-plugin":"2.7.0",dripip:"^0.10.0",eslint:"^6.6.0","get-port":"^5.1.1",graphql:"^16.3.0","graphql-relay":"^0.10.0","graphql-scalars":"^1.14.1",gulp:"4.0.2",husky:"^1.1.2",jest:"^26.6.3","jest-watch-typeahead":"^0.6.1","lint-staged":"^7.3.0",prettier:"^2.5.1","sort-package-json":"^1.22.1","ts-jest":"^26.4.4","ts-morph":"^13.0.3","ts-node":"^9.0.0",tsd:"^0.13.1",tslint:"^5.11.0","tslint-config-prettier":"^1.15.0",typescript:"^4.5.5"},peerDependencies:{graphql:"15.x || 16.x"}}});var Qn={};Fe(Qn,{InputDefinitionBlock:()=>ue,InterfaceDefinitionBlock:()=>ee,ObjectDefinitionBlock:()=>le,OutputDefinitionBlock:()=>Z,UnionDefinitionBlock:()=>me});var pe={removedDeclarativeWrapping:(n,e)=>`[declarativeWrappingPlugin]: The ${e.join(" / ")} object prop${e.length>1?"s":""} used in the ${n} has been
moved to a plugin, as improved chaining APIs and the list() / nonNull() helpers functions are preferred.

On Fields: 

t.string('someField', { nullable: false })   ->    t.nonNull.string('someField')

On args: 

stringArg({ required: true })    ->    nonNull(stringArg())

If you would like to incrementally migrate, or prefer the existing API, it is now supported via the declarativeWrappingPlugin. 
Add this to your plugins array in your makeSchema config:

makeSchema({
  plugins: [declarativeWrappingPlugin(), ...]
})
`,removedDeclarativeWrappingShort:(n,e)=>`[declarativeWrappingPlugin]: Additional warning for ${e.join(" / ")} at ${n}. Add the declarativeWrappingPlugin() to the plugins array to disable this message.
`,removedFunctionShorthand:(n,e)=>`Since v0.18.0, Nexus no longer supports resolver shorthands like:

    t.string("${e}", () => ...).

Instead please write:

    t.string("${e}", { resolve: () => ... })

.`};var Z=class n{constructor(e,t){this.typeBuilder=e,this.wrapping=t,this.typeName=e.typeName,this.typeBuilder.addDynamicOutputMembers(this,this.wrapping)}get list(){return this._wrapClass("List")}get nonNull(){return this._wrapClass("NonNull")}get nullable(){return this._wrapClass("Null")}boolean(e,...t){this.addScalarField(e,"Boolean",t)}string(e,...t){this.addScalarField(e,"String",t)}id(e,...t){this.addScalarField(e,"ID",t)}int(e,...t){this.addScalarField(e,"Int",t)}float(e,...t){this.addScalarField(e,"Float",t)}field(...e){let t=e.length===2?Object.assign({name:e[0]},e[1]):e[0];this.typeBuilder.addField(Object.assign(Object.assign({},t),{configFor:"outputField",wrapping:this.wrapping,parentType:this.typeName}))}_wrapClass(e){var t;let i=(t=this.wrapping)===null||t===void 0?void 0:t[0];return(e==="NonNull"||e==="Null")&&(i==="NonNull"||i==="Null")?new n(this.typeBuilder,this.wrapping||[]):new n(this.typeBuilder,[e].concat(this.wrapping||[]))}addScalarField(e,t,i){let r={type:t};if(typeof i[0]=="function")throw new Error(pe.removedFunctionShorthand(t,e));r=Object.assign(Object.assign({},r),i[0]),this.field(e,r)}},ue=class n{constructor(e,t){this.typeBuilder=e,this.wrapping=t,this.typeName=e.typeName,this.typeBuilder.addDynamicInputFields(this,this.wrapping)}get list(){return this._wrapClass("List")}get nonNull(){return this._wrapClass("NonNull")}get nullable(){return this._wrapClass("Null")}string(e,t){this.field(e,Object.assign(Object.assign({},t),{type:"String"}))}int(e,t){this.field(e,Object.assign(Object.assign({},t),{type:"Int"}))}boolean(e,t){this.field(e,Object.assign(Object.assign({},t),{type:"Boolean"}))}id(e,t){this.field(e,Object.assign(Object.assign({},t),{type:"ID"}))}float(e,t){this.field(e,Object.assign(Object.assign({},t),{type:"Float"}))}field(...e){let t=e.length===2?Object.assign({name:e[0]},e[1]):e[0];this.typeBuilder.addField(Object.assign(Object.assign({},t),{wrapping:this.wrapping,parentType:this.typeName,configFor:"inputField"}))}_wrapClass(e){var t;let i=(t=this.wrapping)===null||t===void 0?void 0:t[0];return(e==="NonNull"||e==="Null")&&(i==="NonNull"||i==="Null")?new n(this.typeBuilder,this.wrapping||[]):new n(this.typeBuilder,[e].concat(this.wrapping||[]))}};import{assertValidName as cr}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var d;(function(n){n.Arg="Arg",n.DynamicInput="DynamicInput",n.DynamicOutputMethod="DynamicOutputMethod",n.DynamicOutputProperty="DynamicOutputProperty",n.Enum="Enum",n.ExtendInputObject="ExtendInputObject",n.ExtendObject="ExtendObject",n.InputField="InputField",n.InputObject="InputObject",n.Interface="Interface",n.List="List",n.NonNull="NonNull",n.Null="Null",n.Object="Object",n.OutputField="OutputField",n.Plugin="Plugin",n.PrintedGenTyping="PrintedGenTyping",n.PrintedGenTypingImport="PrintedGenTypingImport",n.Scalar="Scalar",n.Union="Union"})(d||(d={}));var I=Symbol.for("@nexus/wrapped");function N(n,e){n.prototype[I]=e}var ee=class extends Z{constructor(e){super(e),this.typeBuilder=e}implements(...e){this.typeBuilder.addInterfaces(e)}modify(e,t){this.typeBuilder.addModification(Object.assign(Object.assign({},t),{field:e}))}},Ue=class{constructor(e,t){this.name=e,this.config=t,cr(e)}get value(){return this.config}};N(Ue,d.Interface);function vt(n){return new Ue(n.name,n)}import{assertValidName as dr}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var le=class extends Z{constructor(e){super(e),this.typeBuilder=e}implements(...e){this.typeBuilder.addInterfaces(e)}modify(e,t){this.typeBuilder.addModification(Object.assign(Object.assign({},t),{field:e}))}},ze=class{constructor(e,t){this.name=e,this.config=t,dr(e)}get value(){return this.config}};N(ze,d.Object);function k(n){return new ze(n.name,n)}import{assertValidName as fr}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var me=class{constructor(e){this.typeBuilder=e}members(...e){this.typeBuilder.addUnionMembers(e)}},Qe=class{constructor(e,t){this.name=e,this.config=t,fr(e)}get value(){return this.config}};N(Qe,d.Union);function Ot(n){return new Qe(n.name,n)}var sr={};Fe(sr,{DynamicInputMethodDef:()=>ut,DynamicOutputMethodDef:()=>lt,InputDefinitionBlock:()=>ue,InterfaceDefinitionBlock:()=>ee,NEXUS_BUILD:()=>wt,NEXUS_TYPE:()=>ye,NexusArgDef:()=>nt,NexusEnumTypeDef:()=>dt,NexusExtendInputTypeDef:()=>Tt,NexusExtendTypeDef:()=>xt,NexusInputObjectTypeDef:()=>ft,NexusInterfaceTypeDef:()=>Ue,NexusListDef:()=>rt,NexusNonNullDef:()=>De,NexusNullDef:()=>Ge,NexusObjectTypeDef:()=>ze,NexusPlugin:()=>pt,NexusScalarTypeDef:()=>ht,NexusTypes:()=>d,NexusUnionTypeDef:()=>Qe,NexusWrappedSymbol:()=>I,ObjectDefinitionBlock:()=>le,OutputDefinitionBlock:()=>Z,PrintedGenTyping:()=>He,PrintedGenTypingImport:()=>Ve,SCALAR_TYPES:()=>Ln,SDLConverter:()=>sn,SchemaBuilder:()=>nn,TypegenMetadata:()=>je,TypegenPrinter:()=>Le,UNKNOWN_TYPE_SCALAR:()=>Ze,UnionDefinitionBlock:()=>me,Unreachable:()=>Y,applyNexusWrapping:()=>re,arg:()=>A,asNexusMethod:()=>xi,assertAbsolutePath:()=>Me,assertNoMissingTypes:()=>Je,booleanArg:()=>ti,casesHandled:()=>Ye,completeValue:()=>R,composeMiddlewareFns:()=>In,connectionPlugin:()=>K,connectionPluginCore:()=>Fn,consoleWarn:()=>Ke,convertSDL:()=>rr,createPlugin:()=>ii,declarativeWrappingPlugin:()=>Kt,decorateType:()=>$e,dump:()=>Fr,dynamicInputMethod:()=>ri,dynamicOutputMethod:()=>Qt,eachObj:()=>O,enumType:()=>Zt,extendInputType:()=>Ji,extendType:()=>he,fieldAuthorizePlugin:()=>ke,fieldAuthorizePluginCore:()=>$n,finalizeWrapping:()=>st,firstDefined:()=>jr,floatArg:()=>Zn,formatPathForModuleImport:()=>Kn,generateSchema:()=>Yi,getArgNamedType:()=>hn,getNexusNamedType:()=>_e,getOwnPackage:()=>J,graphql15InterfaceConfig:()=>mn,graphql15InterfaceType:()=>tt,groupTypes:()=>Ae,idArg:()=>ei,inputObjectType:()=>en,intArg:()=>xe,interfaceType:()=>vt,invariantGuard:()=>At,isArray:()=>yn,isInterfaceField:()=>un,isNexusArgDef:()=>Se,isNexusDynamicInputMethod:()=>kt,isNexusDynamicOutputMethod:()=>Ct,isNexusDynamicOutputProperty:()=>Gt,isNexusEnumTypeDef:()=>bn,isNexusExtendInputTypeDef:()=>Pt,isNexusExtendTypeDef:()=>_t,isNexusInputObjectTypeDef:()=>Ce,isNexusInterfaceTypeDef:()=>ie,isNexusListTypeDef:()=>xn,isNexusMeta:()=>H,isNexusMetaBuild:()=>jt,isNexusMetaType:()=>V,isNexusMetaTypeFn:()=>an,isNexusMetaTypeProp:()=>Vn,isNexusNamedInputTypeDef:()=>On,isNexusNamedOuputTypeDef:()=>vn,isNexusNamedTypeDef:()=>se,isNexusNonNullTypeDef:()=>be,isNexusNullTypeDef:()=>Ne,isNexusObjectTypeDef:()=>ne,isNexusPlugin:()=>Lt,isNexusPrintedGenTyping:()=>wn,isNexusPrintedGenTypingImport:()=>Rt,isNexusScalarTypeDef:()=>Dt,isNexusStruct:()=>v,isNexusTypeDef:()=>kr,isNexusUnionTypeDef:()=>Nn,isNexusWrappingType:()=>W,isObject:()=>cn,isProductionStage:()=>et,isPromiseLike:()=>de,isUnknownType:()=>dn,list:()=>fe,log:()=>$t,makeSchema:()=>Hi,makeSchemaInternal:()=>mt,mapObj:()=>S,mapValues:()=>ln,mutationField:()=>Xi,mutationType:()=>Ki,nonNull:()=>B,normalizeArgWrapping:()=>jn,nullabilityGuardPlugin:()=>Mn,nullabilityGuardPluginCore:()=>An,nullable:()=>q,objValues:()=>ce,objectType:()=>k,ownProp:()=>te,pathToArray:()=>fn,plugin:()=>P,printedGenTyping:()=>U,printedGenTypingImport:()=>Te,queryComplexityPlugin:()=>Pn,queryComplexityPluginCore:()=>_n,queryField:()=>Zi,queryType:()=>er,raiseProgrammerError:()=>It,rebuildArgs:()=>Fi,rebuildEnumType:()=>wi,rebuildInputDefinition:()=>Ei,rebuildInputObjectType:()=>Ni,rebuildInterfaceType:()=>ji,rebuildNamedType:()=>Gn,rebuildObjectType:()=>Ii,rebuildOutputDefinition:()=>Cn,rebuildScalarType:()=>Oi,rebuildUnionType:()=>vi,relativePathTo:()=>Pe,resolveImportPath:()=>Mt,resolveNexusMetaType:()=>ge,resolveTypegenConfig:()=>gt,result:()=>Sr,rewrapAsGraphQLType:()=>Oe,runAbstractTypeRuntimeChecks:()=>Xe,scalarType:()=>tn,setConfigDefaults:()=>_i,stringArg:()=>it,subscriptionField:()=>tr,subscriptionType:()=>nr,suggestionList:()=>Xn,typeScriptFileExtension:()=>Ft,typegenAutoConfig:()=>Bn,typegenFormatPrettier:()=>qn,unionType:()=>Ot,unpack:()=>$r,unwrapGraphQLDef:()=>X,unwrapNexusDef:()=>ve,venn:()=>St,withNexusSymbol:()=>N});import{__rest as Ns}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{assertValidName as vs,defaultFieldResolver as Os,GraphQLBoolean as Pi,GraphQLEnumType as ws,GraphQLFloat as js,GraphQLID as Is,GraphQLInputObjectType as Es,GraphQLInt as Fs,GraphQLInterfaceType as $s,GraphQLNonNull as Ss,GraphQLObjectType as $i,GraphQLScalarType as Ms,GraphQLSchema as As,GraphQLString as Ps,GraphQLUnionType as _s,isInputObjectType as Ds,isInputType as Gs,isInterfaceType as Cs,isLeafType as ks,isNamedType as kn,isObjectType as Rn,isOutputType as Si,isSchema as Rs,isWrappingType as Ls}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{GraphQLList as Dr,GraphQLNonNull as Gr,isWrappingType as gn,isListType as ni,isNonNullType as Tn}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import*as Yn from"node:fs";import{GraphQLScalarType as mr,isAbstractType as yr,isEnumType as gr,isInputObjectType as Tr,isInterfaceType as Jn,isObjectType as xr,isScalarType as br,isSpecifiedScalarType as Nr,isUnionType as vr,isWrappingType as Et,specifiedScalarTypes as Or}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import*as G from"node:path";function $e(n,e){var t;return n.extensions=Object.assign(Object.assign({},n.extensions),{nexus:Object.assign(Object.assign({},Object((t=n.extensions)===null||t===void 0?void 0:t.nexus)),e)}),n}var ye=Symbol.for("@nexus/meta/NEXUS_TYPE"),wt=Symbol.for("@nexus/meta/NEXUS_BUILD");function jt(n){return!!(n&&typeof te.get(n,wt)=="function")}function V(n){return Vn(n)||an(n)}function Vn(n){return!!(n&&te.has(n,ye)&&v(te.get(n,ye)))}function an(n){return!!(n&&te.has(n,ye)&&typeof te.get(n,ye)=="function")}function H(n){return jt(n)||V(n)||an(n)}function ge(n){let e=te.get(n,ye);if(typeof e=="function"&&(e=te.set(n,ye,e.call(n))),!ne(e)&&!ie(e))throw new Error("Expected property of NEXUS_TYPE to be an object or interface type");return e}var un=(n,e)=>n.getInterfaces().some(t=>!!t.getFields()[e]);function Xn(n="",e=[]){for(var t=Object.create(null),i=e.length,r=n.length/2,s=0;s<i;s++){var o=wr(n,e[s]),a=Math.max(r,e[s].length/2,1);o<=a&&(t[e[s]]=o)}return Object.keys(t).sort(function(p,u){return t[p]-t[u]})}function wr(n,e){if(n===e)return 0;let t,i,r=[],s=n.toLowerCase(),o=e.toLowerCase(),a=s.length,p=o.length;if(s===o)return 1;for(t=0;t<=a;t++)r[t]=[t];for(i=1;i<=p;i++)r[0][i]=i;for(t=1;t<=a;t++)for(i=1;i<=p;i++){var u=s[t-1]===o[i-1]?0:1;r[t][i]=Math.min(r[t-1][i]+1,r[t][i-1]+1,r[t-1][i-1]+u),t>1&&i>1&&s[t-1]===o[i-2]&&s[t-2]===o[i-1]&&(r[t][i]=Math.min(r[t][i],r[t-2][i-2]+u))}return r[a][p]}function ce(n){return Object.keys(n).reduce((e,t)=>(e.push(n[t]),e),[])}function S(n,e){return Object.keys(n).map((t,i)=>e(n[t],t,i))}function ln(n,e){let t={};return Object.keys(n).forEach((i,r)=>t[i]=e(n[i],i,r)),t}function O(n,e){Object.keys(n).forEach((t,i)=>e(n[t],t,i))}var cn=n=>n!==null&&typeof n=="object",Me=(n,e)=>{if(!G.isAbsolute(n))throw new Error(`Expected path for "${e}" to be an absolute path, saw "${n}"`);return n};function Ae(n){let e={input:[],interface:[],object:[],union:[],enum:[],scalar:Array.from(Or)},t=n.getTypeMap();return Object.keys(t).sort().forEach(i=>{if(i.startsWith("__"))return;let r=n.getType(i);xr(r)?e.object.push(r):Tr(r)?e.input.push(r):br(r)&&!Nr(r)&&!dn(r)?e.scalar.push(r):vr(r)?e.union.push(r):Jn(r)?e.interface.push(r):gr(r)&&e.enum.push(r)}),e}function dn(n){return n.name===Ze.name}function jr(...n){for(let e=0;e<n.length;e++){let t=n[e];if(typeof t<"u")return t}throw new Error("At least one of the values should be defined")}function de(n){return!!(n&&typeof n.then=="function")}var Ft=/(\.d)?\.ts$/;function Ir(n){return G.isAbsolute(n)||n.startsWith("./")?n:`./${n}`}function Er(n){return n.replace(/\\+/g,"/")}function Kn(n){return Er(Ir(n).replace(Ft,""))}function Pe(n,e){let t=G.basename(n),i=G.relative(G.dirname(e),G.dirname(n));return Kn(G.join(i,t))}var Ve=class{constructor(e){this.config=e}};N(Ve,d.PrintedGenTypingImport);function Te(n){return new Ve(n)}var He=class{constructor(e){this.config=e}get imports(){return this.config.imports||[]}toString(){let e="";this.config.description&&(e=`/**
${this.config.description.split(`
`).map(r=>r.trim()).filter(r=>r).map(r=>` * ${r}`).join(`
`)}
 */
`);let t=`${this.config.name}${this.config.optional?"?":""}`;return e+=`${t}: ${this.config.type}`,e}};N(He,d.PrintedGenTyping);function U(n){return new He(n)}function Je(n,e){let t=Object.keys(e),i=n.getTypeMap(),r=Object.keys(i).filter(s=>!dn(i[s]));if(t.length>0){let s=t.map(o=>{let{fromObject:a}=e[o];if(a)return`- Looks like you forgot to import ${o} in the root "types" passed to Nexus makeSchema`;let p=Xn(o,r),u="";return p.length>0&&(u=` or mean ${p.join(", ")}`),`- Missing type ${o}, did you forget to import a type to the root query${u}?`}).join(`
`);throw new Error(`
`+s)}}function Xe(n,e){if(e.abstractTypeRuntimeChecks===!1)return;Object.values(n.getTypeMap()).filter(yr).forEach(i=>{let r=Jn(i)?"Interface":"Union",s=i.resolveType!==void 0,o=n.getPossibleTypes(i).filter(a=>a.isTypeOf===void 0);if(s===!1&&e.abstractTypeStrategies.resolveType===!0&&e.abstractTypeStrategies.isTypeOf===!1){let p=`${`You have a faulty implementation for your ${r.toLowerCase()} type "${i.name}".`} It is missing a \`resolveType\` implementation.`;It(new Error(p))}if(o.length>0&&e.abstractTypeStrategies.isTypeOf===!0&&e.abstractTypeStrategies.resolveType===!1){let a=o.map(c=>`"${c.name}"`).join(", "),p=`You have a faulty implementation for your ${r.toLowerCase()} type "${i.name}".`,u=`are missing an \`isTypeOf\` implementation: ${a}`,l;r==="Union"?l=`${p} Some members of union type "${i.name}" ${u}`:r==="Interface"?l=`${p} Some objects implementing the interface type "${i.name}" ${u}`:Ye(r),It(new Error(l))}if((s===!1||o.length>0)&&e.abstractTypeStrategies.isTypeOf===!0&&e.abstractTypeStrategies.resolveType===!0){let a=o.map(c=>`"${c.name}"`).join(", "),p=`You have a faulty implementation for your ${r.toLowerCase()} type "${i.name}". Either implement its \`resolveType\` or implement \`isTypeOf\` on each object`,u=`These objects are missing an \`isTypeOf\` implementation: ${a}`,l;r==="Union"?l=`${p} in the union. ${u}`:r==="Interface"?l=`${p} that implements this interface. ${u}`:Ye(r),It(new Error(l))}})}function Ke(n){console.warn(n)}function $t(n){console.log(`Nexus Schema: ${n}`)}function St(n,e){let t=new Set(n),i=new Set,r=new Set(e);return t.forEach(s=>{r.has(s)&&(i.add(s),t.delete(s),r.delete(s))}),[t,i,r]}var Ze=$e(new mr({name:"NEXUS__UNKNOWN__TYPE",description:`
    This scalar should never make it into production. It is used as a placeholder for situations
    where GraphQL Nexus encounters a missing type. We don't want to error immediately, otherwise
    the TypeScript definitions will not be updated.
  `,parseValue(n){throw new Error("Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.")},parseLiteral(n){throw new Error("Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.")},serialize(n){throw new Error("Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.")}}),{sourceType:"never"});function fn(n){let e=[],t=n;for(;t;)e.push(t.key),t=t.prev;return e.reverse()}function J(){return Hn()}function Ye(n){throw new Error(`A case was not handled for value: "${n}"`)}function Fr(n){console.log(Ee("util").inspect(n,{depth:null}))}function pn(n){return!G.isAbsolute(n)&&/^([A-z0-9@])/.test(n)}function Mt(n,e,t){let i=n.module;if(typeof i!="string"||!G.isAbsolute(i)&&!pn(i))throw new Error(`Expected an absolute path or Node package for the root typing path of the type "${e}", saw "${i}"`);if(pn(i))try{__rResolve$(i)}catch{throw new Error(`Module "${i}" for the type "${e}" does not exist`)}else if(!Yn.existsSync(i))throw new Error(`Root typing path "${i}" for the type "${e}" does not exist`);return pn(i)?i:G.isAbsolute(i)?Pe(i,t):i}function hn(n){let e=n;if(typeof e=="string")return e;for(;W(e)||Et(e)||Se(e);)Se(e)?e=e.value.type:W(e)?e=e.ofNexusType:Et(e)&&(e=e.ofType);return e}function _e(n){if(typeof n=="string")return n;let e=n;for(;W(e)||Et(e)||V(e);)W(e)&&(e=e.ofNexusType),Et(e)&&(e=e.ofType),V(e)&&(e=ge(e));return e}function At(n){if(!n)throw new Error("Nexus Error: This should never happen, please check your code or if you think this is a bug open a GitHub issue https://github.com/graphql-nexus/schema/issues/new.")}function et(){return!0}function It(n){if(et())throw n;console.error(n)}var Y=class extends Error{constructor(e){super(`Unreachable case or branch, unexpected ${e}`)}};function mn(n){return Object.assign(Object.assign({},n),{interfaces:[]})}function tt(n){return typeof n.getInterfaces!="function"&&(n.getInterfaces=()=>[]),n}function $r(n){return n instanceof Function?n():n}function yn(n){return Array.isArray(n)}var te={has(n,e){return!!Object.getOwnPropertyDescriptor(n,e)},set(n,e,t){return Object.defineProperty(n,e,{value:t}),t},get(n,e){var t;return(t=Object.getOwnPropertyDescriptor(n,e))===null||t===void 0?void 0:t.value}};function Sr(n){return n instanceof Function?n():n}var nt=class{constructor(e,t){this.name=e,this.config=t}get value(){return this.config}};N(nt,d.Arg);function A(n){if(!n.type)throw new Error('You must provide a "type" for the arg()');return new nt(typeof n.type=="string"?n.type:n.type.name,n)}function it(n){return A(Object.assign({type:"String"},n))}function xe(n){return A(Object.assign({type:"Int"},n))}function Zn(n){return A(Object.assign({type:"Float"},n))}function ei(n){return A(Object.assign({type:"ID"},n))}function ti(n){return A(Object.assign({type:"Boolean"},n))}import{isType as Mr}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var rt=class{constructor(e){if(this.ofNexusType=e,this._isNexusListDef=!0,typeof e!="string"&&!v(e)&&!H(e)&&!Mr(e))throw new Error("Cannot wrap unknown types in list(). Saw "+e)}};N(rt,d.List);function fe(n){return new rt(n)}import{isNonNullType as Ar,isType as Pr}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var De=class{constructor(e){if(this.ofNexusType=e,this._isNexusNonNullDef=!0,typeof e!="string"&&!v(e)&&!H(e)&&!Pr(e))throw new Error("Cannot wrap unknown types in a nonNull(). Saw "+e)}};N(De,d.NonNull);function B(n){return be(n)||Ar(n)?n:Ne(n)?new De(n.ofNexusType):new De(n)}import{isType as _r}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var Ge=class{constructor(e){if(this.ofNexusType=e,this._isNexusNullDef=!0,typeof e!="string"&&!v(e)&&!H(e)&&!_r(e))throw new Error("Cannot wrap unknown types in nullable(). Saw "+e)}};N(Ge,d.Null);function q(n){return be(n)?new Ge(n.ofNexusType):Ne(n)?n:new Ge(n)}var Cr=new Set([d.Enum,d.Object,d.Scalar,d.Union,d.Interface,d.InputObject]),kr=n=>(console.warn("isNexusTypeDef is deprecated, use isNexusStruct"),v(n));function v(n){return n&&!!n[I]}function se(n){return v(n)&&Cr.has(n[I])&&"name"in n}function xn(n){return v(n)&&n[I]===d.List}function be(n){return v(n)&&n[I]===d.NonNull}function Ne(n){return v(n)&&n[I]===d.Null}function W(n){return xn(n)||Ne(n)||be(n)}function Pt(n){return v(n)&&n[I]===d.ExtendInputObject}function _t(n){return v(n)&&n[I]===d.ExtendObject}function bn(n){return v(n)&&n[I]===d.Enum}function Ce(n){return v(n)&&n[I]===d.InputObject}function ne(n){return v(n)&&n[I]===d.Object}function Dt(n){return v(n)&&n[I]===d.Scalar}function Nn(n){return v(n)&&n[I]===d.Union}function ie(n){return v(n)&&n[I]===d.Interface}function Se(n){return v(n)&&n[I]===d.Arg}function vn(n){return se(n)&&!Ce(n)}function On(n){return se(n)&&!ne(n)&&!ie(n)}function Gt(n){return v(n)&&n[I]===d.DynamicOutputProperty}function Ct(n){return v(n)&&n[I]===d.DynamicOutputMethod}function kt(n){return v(n)&&n[I]===d.DynamicInput}function wn(n){return v(n)&&n[I]===d.PrintedGenTyping}function Rt(n){return v(n)&&n[I]===d.PrintedGenTypingImport}function Lt(n){return v(n)&&n[I]===d.Plugin}function X(n){let e=[],t=n;for(;gn(t);){if(ni(t))e.unshift("List");else if(Tn(t))e.unshift("NonNull");else throw new Y(t);t=t.ofType}return{namedType:t,wrapping:e}}function ve(n){let e=[],t=n;for(;W(t)||gn(t)||V(t);)if(V(t))t=ge(t);else if(gn(t)){if(ni(t))e.unshift("List");else if(Tn(t))e.unshift("NonNull");else throw new Y(t);t=t.ofType}else be(t)&&e.unshift("NonNull"),Ne(t)&&e.unshift("Null"),xn(t)&&e.unshift("List"),t=t.ofNexusType;return{namedType:t,wrapping:e}}function Oe(n,e){let t=n;return e.forEach(i=>{if(i==="List")t=new Dr(t);else if(i==="NonNull")Tn(t)||(t=new Gr(t));else throw new Y(i)}),t}function jn(n){if(Se(n))return n;if(W(n)){let{namedType:e,wrapping:t}=ve(n);if(Se(e)){let i=e.value;return A(Object.assign(Object.assign({},i),{type:re(i.type,t)}))}return A({type:re(e,t)})}return A({type:n})}function re(n,e){let t=n;return e.forEach(i=>{if(i==="List")t=fe(t);else if(i==="NonNull")t=B(t);else if(i==="Null")t=q(t);else throw new Y(i)}),t}function st(n,e,t){let i=[],r=e.concat(t??[]);n&&(!r[0]||r[0]==="List")&&r.unshift("NonNull");for(let s=0;s<r.length;s++){let o=r[s],a=r[s+1];o!=="Null"&&(o==="NonNull"?i.push("NonNull"):o==="List"&&(i.push("List"),n&&(a==="List"||!a)&&i.push("NonNull")))}return i}import{__rest as zt}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{defaultFieldResolver as Rr}from"/v135/graphql@16.8.1/denonext/graphql.mjs";function at(n){return!!n}var ot=class n{constructor(e){let{resolve:t}=e,i=zt(e,["resolve"]);this.config=i,this.hasDefinedResolver=!!(t&&t!==Rr)}modify(e){return new n(Object.assign(Object.assign({},this.config),e))}},Bt=class{constructor(e){let{definition:t}=e,i=zt(e,["definition"]);this.config=i}},qt=class{constructor(e){let{definition:t}=e,i=zt(e,["definition"]);this.config=i}},Wt=class{constructor(e){let{definition:t}=e,i=zt(e,["definition"]);this.config=i}},Ut=class{constructor(e){this.config=e}};function R(n,e,t){if(de(n))return n.then(e,t);let i=e(n);return de(i)?i.then(r=>r):i}function In(n,e){let t=e;for(let i of n.reverse()){let r=i,s=t;t=(o,a,p,u)=>r(o,a,p,u,s)}return t}var pt=class{constructor(e){this.config=e}};N(pt,d.Plugin);function P(n){return Lr(n),new pt(n)}P.completeValue=R;var ii=P;function Lr(n){let e=["name"],t=["onInstall","onCreateFieldResolver","onCreateFieldSubscribe","onBeforeBuild","onMissingType","onAfterBuild","onObjectDefinition","onAddOutputField","onAddInputField","onAddArg","onInputObjectDefinition"],i=["description","fieldDefTypes","inputFieldDefTypes","objectTypeDefTypes","inputObjectTypeDefTypes","argTypeDefTypes",...t],r=[...e,...i],s=Object.keys(n),o=l=>[...l].join(", "),[a,,]=St(e,s);if(a.size>0)throw new Error(`Plugin "${n.name}" is missing required properties: ${o(a)}`);let p=typeof n.name;if(p!=="string")throw new Error(`Plugin "${n.name}" is giving an invalid value for property name: expected "string" type, got ${p} type`);if(n.name==="")throw new Error(`Plugin "${n.name}" is giving an invalid value for property name: empty string`);let[,,u]=St(r,s);u.size>0&&console.error(new Error(`Plugin "${n.name}" is giving unexpected properties: ${o(u)}`)),t.forEach(l=>{let c=typeof n[l];c!=="function"&&c!=="undefined"&&console.error(new Error(`Plugin "${n.name}" is giving an invalid value for ${l} hook: expected "function" type, got ${c} type`))})}var Fn={};Fe(Fn,{BackwardOnlyStrictArgs:()=>pi,BackwardPaginateArgs:()=>Ht,ForwardOnlyStrictArgs:()=>ai,ForwardPaginateArgs:()=>Vt,connectionPlugin:()=>K,makeResolveFn:()=>ci});import{__rest as Br}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{defaultFieldResolver as Xt}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var ut=class{constructor(e,t){this.name=e,this.config=t}get value(){return this.config}};N(ut,d.DynamicInput);var lt=class{constructor(e,t){this.name=e,this.config=t}get value(){return this.config}};N(lt,d.DynamicOutputMethod);function Qt(n){return new lt(n.name,n)}function ri(n){return new ut(n.name,n)}var Vt={first:q(xe({description:"Returns the first n elements from the list."})),after:q(it({description:"Returns the elements in the list that come after the specified cursor"}))},ai=Object.assign(Object.assign({},Vt),{first:B(xe({description:"Returns the first n elements from the list."}))}),Ht={last:q(xe({description:"Returns the last n elements from the list."})),before:q(it({description:"Returns the elements in the list that come before the specified cursor"}))},pi=Object.assign(Object.assign({},Ht),{last:B(xe({description:"Returns the last n elements from the list."}))});function ui(n){return __Buffer$.from(n,"utf8").toString("base64")}function li(n){return __Buffer$.from(n,"base64").toString("utf8")}var K=n=>{var e;let t=Object.assign({},n);return P({name:"ConnectionPlugin",fieldDefTypes:[Te({module:(e=n?.nexusSchemaImportId)!==null&&e!==void 0?e:J().name,bindings:["core","connectionPluginCore"]})],onInstall(i){let r=[],{additionalArgs:s={},extendConnection:o,extendEdge:a,includeNodesField:p=!1,nexusFieldName:u="connectionField"}=t;if(o&&O(o,(c,f)=>{r.push(`${f}${c.requireResolver===!1?"?:":":"} connectionPluginCore.ConnectionFieldResolver<TypeName, FieldName, "${f}">`)}),a){let c=S(a,(f,m)=>`${m}${f.requireResolver===!1?"?:":":"} connectionPluginCore.EdgeFieldResolver<TypeName, FieldName, "${m}">`);r.push(`edgeFields: { ${c.join(", ")} }`)}let l="";r.length>0&&(l=` & { ${r.join(", ")} }`),i.addType(Qt({name:u,typeDescription:`
            Adds a Relay-style connection to the type, with numerous options for configuration

            @see https://nexusjs.org/docs/plugins/connection
          `,typeDefinition:`<FieldName extends string>(
      fieldName: FieldName,
      config: connectionPluginCore.ConnectionFieldConfig<TypeName, FieldName>${l}
    ): void`,factory({typeName:c,typeDef:f,args:m,stage:y,builder:g,wrapping:E}){var w,_;let[b,h]=m,T=h.type;if(E?.includes("List"))throw new Error(`Cannot chain .list with connectionField (on ${c}.${b})`);let{targetTypeName:j,connectionName:x,edgeName:$}=Hr(b,c,h,t);y==="build"&&Jr(c,b,t,h),i.hasType(x)||i.addType(k({name:x,definition(F){F.list.field("edges",{type:$,description:"https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types"}),F.nonNull.field("pageInfo",{type:"PageInfo",description:"https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo"}),p&&F.list.field("nodes",{type:T,description:`Flattened list of ${j} type`}),o&&O(o,(Q,ae)=>{F.field(ae,Q)}),zr(F,()=>{h.extendConnection instanceof Function&&h.extendConnection(F)})},nonNullDefaults:(w=h.nonNullDefaults)!==null&&w!==void 0?w:t.nonNullDefaults})),i.hasType($)||i.addType(k({name:$,definition(F){F.field("cursor",{type:z??B("String"),description:"https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"}),F.field("node",{type:T,description:"https://facebook.github.io/relay/graphql/connections.htm#sec-Node"}),a&&O(a,(Q,ae)=>{F.field(ae,Q)}),Ur(F,()=>{h.extendEdge instanceof Function&&h.extendEdge(F)})},nonNullDefaults:(_=h.nonNullDefaults)!==null&&_!==void 0?_:t.nonNullDefaults})),i.hasType("PageInfo")||i.addType(k({name:"PageInfo",description:"PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo",definition(F){F.nonNull.field("hasNextPage",{type:"Boolean",description:"Used to indicate whether more edges exist following the set defined by the clients arguments."}),F.nonNull.field("hasPreviousPage",{type:"Boolean",description:"Used to indicate whether more edges exist prior to the set defined by the clients arguments."}),F.nullable.field("startCursor",{type:"String",description:"The cursor corresponding to the first nodes in edges. Null if the connection is empty."}),F.nullable.field("endCursor",{type:"String",description:"The cursor corresponding to the last nodes in edges. Null if the connection is empty."})}}));let{disableBackwardPagination:D,disableForwardPagination:M,validateArgs:qe=yi,strictArgs:C=!0,cursorType:z}=Object.assign(Object.assign({},t),h),L={};M!==!0&&D!==!0?L=Object.assign(Object.assign({},Vt),Ht):M!==!0?L=C?Object.assign({},ai):Object.assign({},Vt):D!==!0&&(L=C?Object.assign({},pi):Object.assign({},Ht));let oe={};h.additionalArgs?s&&h.inheritAdditionalArgs?oe=Object.assign(Object.assign({},s),h.additionalArgs):oe=Object.assign({},h.additionalArgs):s&&(oe=Object.assign({},s));let or=Object.assign(Object.assign({},oe),L),bt;h.resolve?p?bt=(F,Q,ae,Nt)=>R(h.resolve(F,Q,ae,Nt),We=>We&&We.nodes===void 0?Yt(Q,Object.assign({get nodes(){return R(We.edges,ar=>ar.map(pr=>pr.node))}},We)):Yt(Q,Object.assign({},We))):bt=h.resolve:bt=ci(t,h);let Ie=x;if(E){if(typeof h.nullable=="boolean")throw new Error("[connectionPlugin]: You cannot chain .null/.nonNull and also set the nullable in the connectionField definition.");Ie=re(x,E)}else h.nullable===!0?Ie=q(Ie):h.nullable===!1&&(Ie=B(Ie));f.field(b,Object.assign(Object.assign({},qr(h)),{args:or,type:Ie,resolve(F,Q,ae,Nt){return qe(Q,Nt,F,ae),bt(F,Q,ae,Nt)}}))}}))}})};function qr(n){let{additionalArgs:e,cursorFromNode:t,disableBackwardPagination:i,disableForwardPagination:r,extendConnection:s,extendEdge:o,inheritAdditionalArgs:a,nodes:p,pageInfoFromNodes:u,resolve:l,type:c,validateArgs:f,strictArgs:m,nullable:y}=n;return Br(n,["additionalArgs","cursorFromNode","disableBackwardPagination","disableForwardPagination","extendConnection","extendEdge","inheritAdditionalArgs","nodes","pageInfoFromNodes","resolve","type","validateArgs","strictArgs","nullable"])}function ci(n,e){let t=Object.assign(Object.assign({},n),e);return(i,r,s,o)=>{let{nodes:a}=e,{decodeCursor:p=li,encodeCursor:u=ui}=n,{pageInfoFromNodes:l=Vr,cursorFromNode:c=En}=t;if(!a)return null;let f=Object.assign({},r);if(r.before&&(f.before=p(r.before).replace(Jt,"")),r.after&&(f.after=p(r.after).replace(Jt,"")),r.last&&!r.before&&c===En)throw new Error('Cannot paginate backward without a "before" cursor by default.');let m,y,g=!1,E=()=>{var h;return m!==void 0||(m=R((h=a(i,f,s,o))!==null&&h!==void 0?h:null,T=>T&&Array.from(T))),m},w=()=>(y!==void 0||(y=R(E(),h=>{if(!h){let x=JSON.stringify(fn(o.path));return console.warn(`You resolved null/undefined from nodes() at path ${x}, this is likely an error. Return an empty array to suppress this warning.`),{edges:[],nodes:[]}}let T=[],j=[];return Qr(h,r,(x,$)=>{de(x)?(g=!0,j.push(x),T.push(x.then(D=>R(c(x,f,s,o,{index:$,nodes:h}),M=>si(n,e,f,{cursor:u(M),node:D}))))):(j.push(x),T.push(si(n,e,f,{node:x,cursor:R(c(x,f,s,o,{index:$,nodes:h}),D=>u(D))})))}),g?Promise.all([Promise.all(T),Promise.all(j)]).then(([x,$])=>({edges:x,nodes:$})):{nodes:j,edges:T}})),y),_=()=>R(E(),h=>R(w(),({edges:T})=>R(h?l(h,r,s,o):{hasNextPage:!1,hasPreviousPage:!1},j=>{var x,$,D;return Object.assign(Object.assign({},j),{startCursor:!((x=T?.[0])===null||x===void 0)&&x.cursor?T[0].cursor:null,endCursor:(D=($=T?.[T.length-1])===null||$===void 0?void 0:$.cursor)!==null&&D!==void 0?D:null})}))),b=Wr(i,f,{get nodes(){return R(w(),h=>h.nodes)},get edges(){return R(w(),h=>h.edges)},get pageInfo(){return _()}});return n.extendConnection&&Object.keys(n.extendConnection).forEach(h=>{var T;let j=(T=e[h])!==null&&T!==void 0?T:Xt;Object.defineProperty(b,h,{value:(x,$,D)=>j(i,Object.assign(Object.assign({},f),x),$,D)})}),b}}function si(n,e,t,i){let r=Yt(t,i);return n.extendEdge&&Object.keys(n.extendEdge).forEach(s=>{var o,a;let p=(a=(o=e.edgeFields)===null||o===void 0?void 0:o[s])!==null&&a!==void 0?a:Xt;Object.defineProperty(r,s,{value:(u,l,c)=>p(r,Object.assign(Object.assign({},t),u),l,c)})}),r}function Yt(n,e){return Object.defineProperty(e,"__connectionArgs",{value:n,enumerable:!1}),e}function Wr(n,e,t){return Object.defineProperty(t,"__connectionSource",{value:n,enumerable:!1}),Yt(e,t)}function di(n,e){return Object.assign(Object.assign({},n.__connectionArgs),e)}function Ur(n,e){let t=n.field;n.field=function(...i){let r=i.length===2?Object.assign({name:i[0]},i[1]):i[0],{resolve:s=Xt}=r;t.call(this,Object.assign(Object.assign({},r),{resolve(o,a,p,u){return s(o,di(o,a),p,u)}}))},e(),n.field=t}function zr(n,e){let t=n.field;n.field=function(...i){let r=i.length===2?Object.assign({name:i[0]},i[1]):i[0],{resolve:s=Xt}=r;t.call(this,Object.assign(Object.assign({},r),{resolve(o,a,p,u){return s(o.__connectionSource,di(o,a),p,u)}}))},e(),n.field=t}function Qr(n,e,t){if(typeof e.first=="number"){let i=Math.min(e.first,n.length);for(let r=0;r<i;r++)t(n[r],r)}else if(typeof e.last=="number"){let i=Math.min(e.last,n.length);for(let r=0;r<i;r++)t(n[r],r)}else for(let i=0;i<n.length;i++)t(n[i],i)}function Vr(n,e){return{hasNextPage:fi(n,e),hasPreviousPage:hi(n,e)}}function fi(n,e){if(typeof e.first=="number")return n.length>e.first;if(typeof e.last=="number")return!!(e.before&&e.before!=="0");throw new Error("Unreachable")}function hi(n,e){if(typeof e.first=="number")return!!(e.after&&e.after!=="0");if(typeof e.last=="number")return n.length>=e.last;throw new Error("Unreachable")}var Jt="cursor:";function En(n,e,t,i,{index:r,nodes:s}){let o=r;if(typeof e.first=="number"&&e.after&&(o=parseInt(e.after,10)+r+1),typeof e.last=="number")if(e.before){let a=parseInt(e.before,10),p=Math.min(s.length,e.last);o=a-p+r}else throw new Error("Unreachable");return`${Jt}${o}`}var Hr=(n,e,t,i)=>{let r=typeof t.type=="string"?t.type:t.type.name,s;t.getConnectionName?s=t.getConnectionName(n,e):i.getConnectionName?s=i.getConnectionName(n,e):Yr(t)?s=`${e}${oi(n)}_Connection`:s=`${i.typePrefix||""}${r}Connection`;let o;return t.getEdgeName?o=t.getEdgeName(n,e):i.getEdgeName?o=i.getEdgeName(n,e):mi(t)?o=`${e}${oi(n)}_Edge`:o=`${i.typePrefix||""}${r}Edge`,{edgeName:o,targetTypeName:r,connectionName:s}},Yr=n=>!!(n.extendConnection||mi(n)),mi=n=>!!(n.extendEdge||n.cursorType),oi=n=>n.slice(0,1).toUpperCase().concat(n.slice(1)),Jr=(n,e,t,i)=>{typeof i.nodes!="function"&&typeof i.resolve!="function"&&console.error(new Error(`Nexus Connection Plugin: Missing nodes or resolve property for ${n}.${e}`)),O(t.extendConnection||{},(r,s)=>{typeof i[s]!="function"&&r.requireResolver!==!1&&console.error(new Error(`Nexus Connection Plugin: Missing ${s} resolver property for ${n}.${e}. Set requireResolver to "false" on the field config if you do not need a resolver.`))}),O(t.extendEdge||{},(r,s)=>{var o;typeof((o=i.edgeFields)===null||o===void 0?void 0:o[s])!="function"&&r.requireResolver!==!1&&console.error(new Error(`Nexus Connection Plugin: Missing edgeFields.${s} resolver property for ${n}.${e}. Set requireResolver to "false" on the edge field config if you do not need a resolver.`))})};function yi(n={},e){if(!(n.first||n.first===0)&&!(n.last||n.last===0))throw new Error(`The ${e.parentType}.${e.fieldName} connection field requires a "first" or "last" argument`);if(n.first&&n.last)throw new Error(`The ${e.parentType}.${e.fieldName} connection field requires a "first" or "last" argument, not both`);if(n.first&&n.before)throw new Error(`The ${e.parentType}.${e.fieldName} connection field does not allow a "before" argument with "first"`);if(n.last&&n.after)throw new Error(`The ${e.parentType}.${e.fieldName} connection field does not allow a "last" argument with "after"`)}K.defaultCursorFromNode=En;K.defaultValidateArgs=yi;K.defaultHasPreviousPage=hi;K.defaultHasNextPage=fi;K.base64Encode=ui;K.base64Decode=li;K.CURSOR_PREFIX=Jt;var $n={};Fe($n,{defaultFormatError:()=>gi,fieldAuthorizePlugin:()=>ke});var Xr=Te({module:"nexus/dist/plugins/fieldAuthorizePlugin",bindings:["FieldAuthorizeResolver"]}),Kr=U({optional:!0,name:"authorize",description:`
    Authorization for an individual field. Returning "true"
    or "Promise<true>" means the field can be accessed.
    Returning "false" or "Promise<false>" will respond
    with a "Not Authorized" error for the field. 
    Returning or throwing an error will also prevent the 
    resolver from executing.
  `,type:"FieldAuthorizeResolver<TypeName, FieldName>",imports:[Xr]}),gi=({error:n})=>{let e=new Error("Not authorized");return e.originalError=n,e},ke=(n={})=>{let{formatError:e=gi}=n,t=(r,s,o,a)=>p=>{let u=e({error:p,root:r,args:s,ctx:o,info:a});throw u instanceof Error?u:(console.error(`Non-Error value ${u} returned from custom formatError in authorize plugin`),new Error("Not authorized"))},i=!1;return P({name:"NexusAuthorize",description:"The authorize plugin provides field-level authorization for a schema.",fieldDefTypes:Kr,onCreateFieldResolver(r){var s,o,a;let p=(o=(s=r.fieldConfig.extensions)===null||s===void 0?void 0:s.nexus)===null||o===void 0?void 0:o.config.authorize;if(p!=null){if(typeof p!="function"){console.error(new Error(`The authorize property provided to ${r.fieldConfig.name} with type ${r.fieldConfig.type} should be a function, saw ${typeof p}`));return}return!((a=r.schemaConfig.plugins)===null||a===void 0)&&a.find(u=>u.config.name==="NexusAuthorize")||i||(console.warn('The GraphQL Nexus "authorize" feature has been moved to a plugin, add [fieldAuthorizePlugin()] to your makeSchema plugin config to remove this warning.'),i=!0),function(u,l,c,f,m){let y;try{y=p(u,l,c,f)}catch(g){y=Promise.reject(g)}return P.completeValue(y,g=>{if(g===!0)return m(u,l,c,f);let E=t(u,l,c,f);g instanceof Error&&E(g),g===!1&&E(new Error("Not authorized"));let{fieldName:w,parentType:{name:_}}=f;E(new Error(`Nexus authorize for ${_}.${w} Expected a boolean or Error, saw ${g}`))},g=>{t(u,l,c,f)(g)})}}}})};var An={};Fe(An,{nullabilityGuardPlugin:()=>Mn});import{isEnumType as Zr,isInterfaceType as es,isListType as ts,isNonNullType as ct,isObjectType as ns,isScalarType as is,isUnionType as rs,isWrappingType as ss}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{forEach as os}from"/v135/iterall@1.3.0/denonext/iterall.mjs";var as=U({name:"skipNullGuard",optional:!0,type:"boolean",description:`
    The nullability guard can be helpful, but is also a potentially expensive operation for lists.
    We need to iterate the entire list to check for null items to guard against. Set this to true
    to skip the null guard on a specific field if you know there's no potential for unsafe types.
  `}),Mn=n=>{let{shouldGuard:e=!0,fallbackValues:t={},onGuarded:i=s=>{console.warn(`Nullability guard called for ${s.info.parentType.name}.${s.info.fieldName}`)}}=n,r={shouldGuard:e,onGuarded:i,fallbackValues:t};return P({name:"NullabilityGuard",description:"If we have a nullable field, we want to guard against this being an issue in production.",fieldDefTypes:as,onCreateFieldResolver(s){var o,a;if(!((a=(o=s.fieldConfig.extensions)===null||o===void 0?void 0:o.nexus)===null||a===void 0)&&a.config.skipNullGuard)return;let{type:p}=s.fieldConfig,{outerNonNull:u,hasListNonNull:l}=ps(p);if(u||l)return(c,f,m,y,g)=>P.completeValue(g(c,f,m,y),Ti(m,y,ct(p)?p.ofType:p,s,r,u))},onAfterBuild(s){Object.keys(s.getTypeMap()).forEach(o=>{let a=s.getType(o);if(is(a)){if(t[a.name])return;console.error(`No nullability guard was provided for Scalar ${a.name}. Provide one in the nullabilityGuard config to remove this warning.`)}}),n.fallbackValues&&Object.keys(n.fallbackValues).forEach(o=>{if(!s.getType(o))return console.error(`Unknown type ${o} provided in nullabilityGuard fallbackValues config.`)})}})},Sn=n=>n==null||n!==n,Ti=(n,e,t,i,r,s)=>{let{onGuarded:o,fallbackValues:a,shouldGuard:p}=r,u=l=>(o({ctx:n,info:e,type:t,fallback:l}),p?l:null);return l=>{if(ts(t)){if(Sn(l))return s?u([]):null;let y=!1,g=[],E=Ti(n,e,ct(t.ofType)?t.ofType.ofType:t.ofType,i,r,ct(t.ofType));return os(l,w=>{!y&&de(w)&&(y=!0),g.push(P.completeValue(w,E))}),y?Promise.all(g):g}if(!Sn(l)||s===!1)return l;let c=t.name,f=a[c],m=typeof f=="function"?f({type:t,info:e,ctx:n}):null;if(!Sn(m))return u(m);if(ns(t))return u({});if(Zr(t))return u(t.getValues()[0].value);if(rs(t)||es(t)){let y=e.schema.getPossibleTypes(t);return u({__typename:y[0].name})}return l}},ps=n=>{let e=!1,t=!1;for(ct(n)&&(e=!0,n=n.ofType);ss(n);)n=n.ofType,ct(n)&&(t=!0);return{outerNonNull:e,hasListNonNull:t}};var _n={};Fe(_n,{queryComplexityPlugin:()=>Pn});var us=Te({module:"nexus/dist/plugins/queryComplexityPlugin",bindings:["QueryComplexity"]}),ls=U({optional:!0,name:"complexity",description:`
    The complexity for an individual field. Return a number
    or a function that returns a number to specify the
    complexity for this field.
  `,type:"QueryComplexity<TypeName, FieldName>",imports:[us]}),Pn=()=>P({name:"query-complexity",description:`
      The query complexity plugin allows defining field-level complexity values that
      works with the graphql-query-complexity library.
    `,fieldDefTypes:ls,onCreateFieldResolver(n){var e,t,i,r;let s=(t=(e=n.fieldConfig.extensions)===null||e===void 0?void 0:e.nexus)===null||t===void 0?void 0:t.config.complexity;if(s!=null){if(typeof s!="number"&&typeof s!="function"){let o=n.parentTypeConfig.name,a=(r=(i=n.fieldConfig.extensions)===null||i===void 0?void 0:i.nexus)===null||r===void 0?void 0:r.config.name;console.error(new Error(`The complexity property provided to ${o}.${a} should be a number or a function that returns a number, saw ${typeof s}`));return}n.fieldConfig.extensions=Object.assign(Object.assign({},n.fieldConfig.extensions),{complexity:s})}}});var Dn=[U({name:"nullable",type:"boolean",optional:!0,description:`Whether the type can be null
@default (depends on whether nullability is configured in type or schema)
@see declarativeWrappingPlugin
`}),U({name:"list",type:"true | boolean[]",optional:!0,description:`Whether the type is list of values, or just a single value.

If list is true, we assume the type is a list. If list is an array,
we'll assume that it's a list with the depth. The boolean indicates whether
the type is required (non-null), where true = nonNull, false = nullable.

@see declarativeWrappingPlugin
`}),U({name:"required",type:"boolean",optional:!0,description:"Whether the type should be non null, `required: true` = `nullable: false`\n@default (depends on whether nullability is configured in type or schema)\n\n@see declarativeWrappingPlugin\n"})],Kt=(n={})=>{let e=!1;return P({name:"declarativeWrapping",fieldDefTypes:n.disable?void 0:Dn,argTypeDefTypes:n.disable?void 0:Dn,inputFieldDefTypes:n.disable?void 0:Dn,description:"Provides a declarative nullable/list API, available by default pre-0.19",onAddOutputField(i){return Object.assign(Object.assign({},i),{type:t(i,n)})},onAddInputField(i){return Object.assign(Object.assign({},i),{type:t(i,n)})},onAddArg(i){return Object.assign(Object.assign({},i),{type:t(i,n)})}});function t(i,r){if(i.list==null&&i.nullable==null&&i.required==null)return i.type;let s=[];if(i.list!=null&&s.push("list"),i.nullable!=null&&s.push("nullable"),i.required!=null&&s.push("required"),r.disable||r.shouldWarn){let a=i,p=a.configFor==="arg"?`'${a.parentType}.${a.fieldName}' field's '${a.argName}' argument`:`'${a.parentType}.${a.type}' field`;if(r.disable)throw new Error(pe.removedDeclarativeWrapping(p,s));console.warn(e?pe.removedDeclarativeWrappingShort(p,s):pe.removedDeclarativeWrapping(p,s))}if(W(i.type)&&(i.list!=null||i.nullable!=null||i.required!=null)){let a=i.configFor==="arg"?`the arg '${i.argName}' of the field '${i.parentType}.${i.fieldName}'.`:`the field '${i.parentType}.${i.name}'.`,p=i.list!=null?"list":i.nullable!=null?"nullable":"required";throw new Error(`[declarativeWrappingPlugin] It looks like you used \`${p}\` and wrapped the type of `+a+" You should only do one or the other")}let o=i.type;if(i.list===!0)(i.nullable===!1||i.required===!0)&&(o=B(o)),o=fe(o);else if(Array.isArray(i.list))for(let a of i.list)a===!0?o=fe(B(o)):o=fe(q(o));if(i.required!=null&&i.nullable!=null){let a=i.configFor==="arg"?` on ${i.parentType}.${i.fieldName} arg ${i.argName}`:` on ${i.parentType}.${i.name}`;throw new Error(`Cannot set both required & nullable wrapping modifiers on ${a}`)}return i.nullable===!0||i.required===!1?o=q(o):(i.nullable===!1||i.required===!0)&&(o=B(o)),o}};import{__rest as hs}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{isEnumType as ms,isInputObjectType as ys,isInterfaceType as gs,isObjectType as Ts,isScalarType as xs,isUnionType as bs,defaultTypeResolver as bi}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{assertValidName as cs}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var dt=class{constructor(e,t){this.name=e,this.config=t,cs(e)}get value(){return this.config}asArg(e){return A(Object.assign(Object.assign({},e),{type:this}))}};N(dt,d.Enum);function Zt(n){return new dt(n.name,n)}import{assertValidName as ds}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var ft=class{constructor(e,t){this.name=e,this.config=t,ds(e)}get value(){return this.config}asArg(e){return A(Object.assign(Object.assign({},e),{type:this}))}};N(ft,d.InputObject);function en(n){return new ft(n.name,n)}import{assertValidName as fs}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var ht=class{constructor(e,t){this.name=e,this.config=t,fs(e)}get value(){return this.config}};N(ht,d.Scalar);function tn(n){return new ht(n.name,n)}function xi(n,e,t){return $e(n,{asNexusMethod:e,sourceType:t})}function Gn(n,e){if(Ts(n))return Ii(n,e);if(ys(n))return Ni(n,e);if(gs(n))return ji(n,e);if(bs(n))return vi(n,e);if(xs(n))return Oi(n,e);if(ms(n))return wi(n,e);throw new Y(n)}function Ni(n,e){let{name:t,fields:i,description:r,extensions:s}=n.toConfig();return en({name:t,description:r,definition:o=>{Ei(t,o,i,e)},extensions:s,nonNullDefaults:{output:!1,input:!1}})}function vi(n,e){let{name:t,types:i,description:r,resolveType:s,extensions:o}=n.toConfig();return Ot({name:t,description:r,resolveType:s??bi,definition(a){a.members(...i.map(p=>{var u;return(u=e.captureLeafType)===null||u===void 0||u.call(e,p),p.name}))},extensions:o})}function Oi(n,e){return tn(Object.assign(Object.assign({},n.toConfig()),{sourceType:e.sourceType,asNexusMethod:e.asNexusMethod}))}function wi(n,{sourceType:e,asNexusMethod:t}){let i=n.toConfig(),{name:r,values:s}=i,o=hs(i,["name","values"]);return Zt(Object.assign(Object.assign({name:r},o),{members:Object.entries(s).map(([a,p])=>Object.assign({name:a,deprecation:p.deprecationReason},p)),sourceType:e,asNexusMethod:t}))}function ji(n,e){let{name:t,fields:i,description:r,interfaces:s,extensions:o,resolveType:a}=mn(n.toConfig());return vt({name:t,description:r,resolveType:a??bi,definition:p=>{Cn(t,p,i,s,e)},nonNullDefaults:{output:!1,input:!1},extensions:o,sourceType:e.sourceType,asNexusMethod:e.asNexusMethod})}function Ii(n,e){let{name:t,fields:i,interfaces:r,description:s,extensions:o}=n.toConfig();return k({name:t,description:s,definition:a=>{Cn(t,a,i,r,e)},nonNullDefaults:{output:!1,input:!1},extensions:o,sourceType:e.sourceType,asNexusMethod:e.asNexusMethod})}function Cn(n,e,t,i,r){var s,o,a,p;e.implements(...i.map(u=>{var l;return(l=r.captureLeafType)===null||l===void 0||l.call(r,u),u.name}));for(let[u,l]of Object.entries(t)){if(!((s=r.skipFields)===null||s===void 0)&&s[n]&&(!((o=r.skipFields)===null||o===void 0)&&o[n].includes(u)))continue;let{namedType:c,wrapping:f}=X(l.type);(a=r.captureLeafType)===null||a===void 0||a.call(r,c),e.field(u,{type:re(c.name,f),description:l.description,deprecation:l.deprecationReason,extensions:l.extensions,args:Fi(n,u,(p=l.args)!==null&&p!==void 0?p:{},r),resolve:l.resolve})}}function Ei(n,e,t,i){var r,s,o;for(let[a,p]of Object.entries(t)){if(!((r=i.skipFields)===null||r===void 0)&&r[n]&&(!((s=i.skipFields)===null||s===void 0)&&s[n].includes(a)))continue;let{namedType:u,wrapping:l}=X(p.type);(o=i.captureLeafType)===null||o===void 0||o.call(i,u),e.field(a,{type:re(u.name,l),description:p.description,default:p.defaultValue,extensions:p.extensions})}}function Fi(n,e,t,i){var r,s,o;if(!t)return null;let a={};for(let[p,u]of Object.entries(t)){if(!((s=(r=i.skipArgs)===null||r===void 0?void 0:r[n])===null||s===void 0)&&s[e])continue;let{namedType:l,wrapping:c}=X(u.type);(o=i.captureLeafType)===null||o===void 0||o.call(i,l),a[p]=A({type:re(l.name,c),default:u.defaultValue,description:u.description,extensions:u.extensions})}return a}var Mi={String:Ps,Int:Fs,Float:js,ID:Is,Boolean:Pi},nn=class{constructor(e){this.nexusMetaObjects=new Set,this.buildingTypes=new Set,this.finalTypeMap={},this.definedTypeMap={},this.pendingTypeMap={},this.typeExtendMap={},this.inputTypeExtendMap={},this.graphqlNamedTypeMap={},this.graphqlMergeSchemaMap={},this.dynamicInputFields={},this.dynamicOutputFields={},this.dynamicOutputProperties={},this.plugins=[],this.typesToWalk=[],this.sourceTypings={},this.missingTypes={},this.onMissingTypeFns=[],this.onBeforeBuildFns=[],this.onCreateResolverFns=[],this.onCreateSubscribeFns=[],this.onAfterBuildFns=[],this.onObjectDefinitionFns=[],this.onInputObjectDefinitionFns=[],this.onAddArgFns=[],this.onAddOutputFieldFns=[],this.onAddInputFieldFns=[],this.setConfigOption=(t,i)=>{this.config=Object.assign(Object.assign({},this.config),{[t]:i})},this.hasConfigOption=t=>this.config.hasOwnProperty(t),this.getConfigOption=t=>this.config[t],this.hasType=t=>!!(this.pendingTypeMap[t]||this.finalTypeMap[t]||this.graphqlNamedTypeMap[t]||this.graphqlMergeSchemaMap[t]),this.addType=t=>{var i,r,s;if(kt(t)){this.dynamicInputFields[t.name]=t;return}if(Ct(t)){this.dynamicOutputFields[t.name]=t;return}if(Gt(t)){this.dynamicOutputProperties[t.name]=t;return}if(H(t)){this.addToNexusMeta(t);return}if(!((i=t.name)===null||i===void 0)&&i.startsWith("__"))return;if(_t(t)){(this.typeExtendMap[t.name]=this.typeExtendMap[t.name]||[]).push(t.value),this.typesToWalk.push({type:"object",value:t.value});return}if(Pt(t)){(this.inputTypeExtendMap[t.name]=this.inputTypeExtendMap[t.name]||[]).push(t.value),this.typesToWalk.push({type:"input",value:t.value});return}let o=this.pendingTypeMap[t.name];if(o){if(o!==t)throw Ai(t.name);return}if(se(t)&&(vn(t)&&t.value.asNexusMethod&&(this.dynamicOutputFields[t.value.asNexusMethod]=t.name),On(t)&&t.value.asNexusMethod&&(this.dynamicInputFields[t.value.asNexusMethod]=t.name),Dt(t)&&t.value.sourceType&&(this.sourceTypings[t.name]=t.value.sourceType)),kn(t)){if(this.graphqlNamedTypeMap[t.name])return;if(!((r=t.extensions)===null||r===void 0)&&r.nexus){let{asNexusMethod:a,sourceType:p}=Object(t.extensions.nexus);a&&(Gs(t)&&(this.dynamicInputFields[a]=t.name),Si(t)&&(this.dynamicOutputFields[a]=t.name)),p&&(this.sourceTypings[t.name]=p)}this.graphqlNamedTypeMap[t.name]=this.handleNativeType(t,{captureLeafType:a=>{!this.graphqlNamedTypeMap[a.name]&&a.name!==t.name&&this.addType(a)}}),!((s=t.extensions)===null||s===void 0)&&s.nexus&&this.addType(this.graphqlNamedTypeMap[t.name]);return}this.pendingTypeMap[t.name]=t,Ce(t)&&this.typesToWalk.push({type:"input",value:t.value}),ne(t)&&this.typesToWalk.push({type:"object",value:t.value}),ie(t)&&this.typesToWalk.push({type:"interface",value:t.value})},this.config=_i(e),this.plugins=this.config.plugins.length>0?this.config.plugins:[ke()],this.plugins.find(t=>t.config.name==="declarativeWrapping")||this.plugins.push(Kt({disable:!0})),this.builderLens=Object.freeze({hasType:this.hasType,addType:this.addType,setConfigOption:this.setConfigOption,hasConfigOption:this.hasConfigOption,getConfigOption:this.getConfigOption}),e.mergeSchema&&(this.graphqlMergeSchemaMap=this.handleMergeSchema(e.mergeSchema))}get schemaExtension(){if(!this._schemaExtension)throw new Error("Cannot reference schemaExtension before it is created");return this._schemaExtension}addTypes(e){var t,i;if(e){if(Rs(e)){if(((t=this.config.mergeSchema)===null||t===void 0?void 0:t.schema)===e)return;this.config.mergeSchema?this.addTypes(e.getTypeMap()):(Object.keys(this.graphqlMergeSchemaMap).length&&console.error(new Error(`It looks like you're trying to merge multiple GraphQL schemas.
 Please open a GitHub ticket with more info about your use case.`)),this.graphqlMergeSchemaMap=this.handleMergeSchema({schema:e}));return}if(Lt(e)){if(!(!((i=this.plugins)===null||i===void 0)&&i.includes(e)))throw new Error(`Nexus plugin ${e.config.name} was seen in the "types" config, but should instead be provided to the "plugins" array.`);return}se(e)||_t(e)||Pt(e)||kn(e)||kt(e)||Ct(e)||Gt(e)||H(e)?this.addType(e):Array.isArray(e)?e.forEach(r=>this.addTypes(r)):cn(e)&&Object.keys(e).forEach(r=>this.addTypes(e[r]))}}addToNexusMeta(e){if(!this.nexusMetaObjects.has(e)){if(this.nexusMetaObjects.add(e),jt(e)){let t=e[wt]();this.addTypes(t)}V(e)&&this.addType(ge(e))}}walkTypes(){let e;for(;e=this.typesToWalk.shift();)switch(e.type){case"input":this.walkInputType(e.value);break;case"interface":this.walkInterfaceType(e.value);break;case"object":this.walkOutputType(e.value);break;default:Ye(e)}}beforeWalkTypes(){this.plugins.forEach((e,t)=>{if(!Lt(e))throw new Error(`Expected a plugin in plugins[${t}], saw ${e}`);let{config:i}=e;if(i.onInstall){let r=i.onInstall(this.builderLens);if(Array.isArray(r?.types))throw new Error(`Nexus no longer supports a return value from onInstall, you should instead use the hasType/addType api (seen in plugin ${i.name}). `)}i.onCreateFieldResolver&&this.onCreateResolverFns.push(i.onCreateFieldResolver),i.onCreateFieldSubscribe&&this.onCreateSubscribeFns.push(i.onCreateFieldSubscribe),i.onBeforeBuild&&this.onBeforeBuildFns.push(i.onBeforeBuild),i.onMissingType&&this.onMissingTypeFns.push(i.onMissingType),i.onAfterBuild&&this.onAfterBuildFns.push(i.onAfterBuild),i.onObjectDefinition&&this.onObjectDefinitionFns.push(i.onObjectDefinition),i.onAddOutputField&&this.onAddOutputFieldFns.push(i.onAddOutputField),i.onAddInputField&&this.onAddInputFieldFns.push(i.onAddInputField),i.onAddArg&&this.onAddArgFns.push(i.onAddArg),i.onInputObjectDefinition&&this.onInputObjectDefinitionFns.push(i.onInputObjectDefinition)})}beforeBuildTypes(){this.onBeforeBuildFns.forEach(e=>{e(this.builderLens),this.typesToWalk.length>0&&this.walkTypes()})}checkForInterfaceCircularDependencies(){let e={};Object.keys(this.pendingTypeMap).map(r=>this.pendingTypeMap[r]).filter(ie).forEach(r=>{e[r.name]=r.value});let t={},i=(r,s,o)=>{if(t[r.name])return;if(o[r.name])throw r.name===s[s.length-1]?new Error(`GraphQL Nexus: Interface ${r.name} can't implement itself`):new Error(`GraphQL Nexus: Interface circular dependency detected ${[...s.slice(s.lastIndexOf(r.name)),r.name].join(" -> ")}`);let a=new ee({typeName:r.name,addInterfaces:p=>p.forEach(u=>{let l=typeof u=="string"?u:u.value.name;i(e[l],[...s,r.name],Object.assign(Object.assign({},o),{[r.name]:!0}))}),addModification:()=>{},addField:()=>{},addDynamicOutputMembers:(p,u)=>this.addDynamicOutputMembers(p,"walk",u),warn:()=>{}});r.definition(a),t[r.name]=!0};Object.keys(e).forEach(r=>{i(e[r],[],{})})}buildNexusTypes(){var e;!this.pendingTypeMap.Query&&!(!((e=this.config.schemaRoots)===null||e===void 0)&&e.query)&&!this.typeExtendMap.Query&&(this.pendingTypeMap.Query=null),Object.keys(this.pendingTypeMap).forEach(t=>{if(this.typesToWalk.length>0&&this.walkTypes(),!this.finalTypeMap[t]){if(this.definedTypeMap[t])throw Ai(t);this.finalTypeMap[t]=this.getOrBuildType(t),this.buildingTypes.clear()}}),Object.keys(this.typeExtendMap).forEach(t=>{this.typeExtendMap[t]!==null&&!this.hasType(t)&&this.buildObjectType({name:t,definition(){}})}),Object.keys(this.inputTypeExtendMap).forEach(t=>{this.inputTypeExtendMap[t]!==null&&!this.hasType(t)&&this.buildInputObjectType({name:t,definition(){}})})}createSchemaExtension(){this._schemaExtension=new Ut(Object.assign(Object.assign({},this.config),{dynamicFields:{dynamicInputFields:this.dynamicInputFields,dynamicOutputFields:this.dynamicOutputFields,dynamicOutputProperties:this.dynamicOutputProperties},sourceTypings:this.sourceTypings}))}getFinalTypeMap(){return this.beforeWalkTypes(),this.createSchemaExtension(),this.walkTypes(),this.beforeBuildTypes(),this.checkForInterfaceCircularDependencies(),this.buildNexusTypes(),{finalConfig:this.config,typeMap:this.finalTypeMap,schemaExtension:this.schemaExtension,missingTypes:this.missingTypes,onAfterBuildFns:this.onAfterBuildFns}}shouldMerge(e){if(!this.config.mergeSchema)return!1;let{mergeTypes:t=["Query","Mutation"]}=this.config.mergeSchema;return!!(t===!0||t.includes(e))}buildInputObjectType(e){let t=[],i=new ue({typeName:e.name,addField:a=>t.push(this.addInputField(a)),addDynamicInputFields:(a,p)=>this.addDynamicInputFields(a,p),warn:Ke}),r=this.graphqlMergeSchemaMap[e.name];this.shouldMerge(e.name)&&Ce(r)&&r.value.definition(i),e.definition(i),this.onInputObjectDefinitionFns.forEach(a=>{a(i,e)});let s=this.inputTypeExtendMap[e.name];s&&s.forEach(a=>{a.definition(i)}),this.inputTypeExtendMap[e.name]=null;let o={name:e.name,fields:()=>this.buildInputObjectFields(t,o),description:e.description,extensions:Object.assign(Object.assign({},e.extensions),{nexus:new Bt(e)})};return this.finalize(new Es(o))}buildObjectType(e){let t=[],i=[],r={},s=new le({typeName:e.name,addField:u=>t.push(this.addOutputField(u)),addInterfaces:u=>i.push(...u),addModification:u=>r[u.field]=u,addDynamicOutputMembers:(u,l)=>this.addDynamicOutputMembers(u,"build",l),warn:Ke}),o=this.graphqlMergeSchemaMap[e.name];this.shouldMerge(e.name)&&ne(o)&&o.value.definition(s),e.definition(s),this.onObjectDefinitionFns.forEach(u=>{u(s,e)});let a=this.typeExtendMap[e.name];a&&a.forEach(u=>{u.definition(s)}),this.typeExtendMap[e.name]=null,e.sourceType&&(this.sourceTypings[e.name]=e.sourceType);let p={name:e.name,interfaces:()=>this.buildInterfaceList(i),description:e.description,fields:()=>this.buildOutputFields(t,p,this.buildInterfaceFields(p,i,r)),isTypeOf:e.isTypeOf,extensions:Object.assign(Object.assign({},e.extensions),{nexus:new qt(e)})};return this.finalize(new $i(p))}buildInterfaceType(e){let{name:t,description:i}=e,r=e.resolveType,s=[],o=[],a={},p=new ee({typeName:e.name,addField:c=>s.push(this.addOutputField(c)),addInterfaces:c=>o.push(...c),addModification:c=>a[c.field]=c,addDynamicOutputMembers:(c,f)=>this.addDynamicOutputMembers(c,"build",f),warn:Ke}),u=this.graphqlMergeSchemaMap[e.name];this.shouldMerge(e.name)&&ie(u)&&u.value.definition(p),e.definition(p),e.sourceType&&(this.sourceTypings[e.name]=e.sourceType);let l={name:t,interfaces:()=>this.buildInterfaceList(o),resolveType:r,description:i,fields:()=>this.buildOutputFields(s,l,this.buildInterfaceFields(l,o,a)),extensions:Object.assign(Object.assign({},e.extensions),{nexus:new Wt(e)})};return this.finalize(new $s(l))}addOutputField(e){return this.onAddOutputFieldFns.forEach(t=>{let i=t(e);i&&(e=i)}),e}addInputField(e){return this.onAddInputFieldFns.forEach(t=>{let i=t(e);i&&(e=i)}),e}buildEnumType(e){var t,i;let{members:r}=e,s={};if(yn(r)?r.forEach(o=>{var a,p;typeof o=="string"?s[o]={value:o}:s[o.name]={value:typeof o.value>"u"?o.name:o.value,deprecationReason:o.deprecation,description:o.description,extensions:Object.assign(Object.assign({},o.extensions),{nexus:(p=(a=o.extensions)===null||a===void 0?void 0:a.nexus)!==null&&p!==void 0?p:{}})}}):Object.keys(r).filter(o=>isNaN(+o)).forEach(o=>{vs(o),s[o]={value:r[o]}}),!Object.keys(s).length)throw new Error(`GraphQL Nexus: Enum ${e.name} must have at least one member`);return e.sourceType&&(this.sourceTypings[e.name]=e.sourceType),this.finalize(new ws({name:e.name,values:s,description:e.description,extensions:Object.assign(Object.assign({},e.extensions),{nexus:(i=(t=e.extensions)===null||t===void 0?void 0:t.nexus)!==null&&i!==void 0?i:{}})}))}buildUnionType(e){var t,i;let r,s=e.resolveType;return e.definition(new me({typeName:e.name,addUnionMembers:o=>r=o})),e.sourceType&&(this.sourceTypings[e.name]=e.sourceType),this.finalize(new _s({name:e.name,resolveType:s,description:e.description,types:()=>this.buildUnionMembers(e.name,r),extensions:Object.assign(Object.assign({},e.extensions),{nexus:(i=(t=e.extensions)===null||t===void 0?void 0:t.nexus)!==null&&i!==void 0?i:{}})}))}buildScalarType(e){var t,i;return e.sourceType&&(this.sourceTypings[e.name]=e.sourceType),this.finalize(new Ms(Object.assign(Object.assign({},e),{extensions:Object.assign(Object.assign({},e.extensions),{nexus:(i=(t=e.extensions)===null||t===void 0?void 0:t.nexus)!==null&&i!==void 0?i:{}})})))}finalize(e){return this.finalTypeMap[e.name]=e,e}missingType(e,t=!1){if(At(e),this.onMissingTypeFns.length)for(let i=0;i<this.onMissingTypeFns.length;i++){let r=this.onMissingTypeFns[i],s=r(e,this.builderLens);if(s&&s.name)return this.addType(s),this.getOrBuildType(s)}return e==="Query"?new $i({name:"Query",fields:{ok:{type:new Ss(Pi),resolve:()=>!0}}}):(this.missingTypes[e]||(this.missingTypes[e]={fromObject:t}),this.addType(Ze),this.getOrBuildType(Ze))}buildUnionMembers(e,t){let i=[];if(!t)throw new Error(`Missing Union members for ${e}.Make sure to call the t.members(...) method in the union blocks`);if(t.forEach(r=>{i.push(this.getObjectType(r))}),!i.length)throw new Error(`GraphQL Nexus: Union ${e} must have at least one member type`);return i}buildInterfaceList(e){let t=[];return e.forEach(i=>{let r=this.getInterface(i);t.push(r,...tt(r).getInterfaces())}),Array.from(new Set(t))}buildInterfaceFields(e,t,i){let r={};return t.forEach(s=>{let o=this.getInterface(s).toConfig();Object.keys(o.fields).forEach(a=>{var p,u,l,c,f;let m=o.fields[a];if(r[a]=m,i[a]){let y=i[a],{type:g,field:E,args:w,extensions:_}=y,b=Ns(y,["type","field","args","extensions"]),h=at(_?.nexus)?(u=(p=_?.nexus)===null||p===void 0?void 0:p.config)!==null&&u!==void 0?u:{}:{};if(r[a]=Object.assign(Object.assign(Object.assign({},r[a]),b),{extensions:Object.assign(Object.assign(Object.assign({},m.extensions),_),{nexus:at((l=m.extensions)===null||l===void 0?void 0:l.nexus)?(f=(c=m.extensions)===null||c===void 0?void 0:c.nexus)===null||f===void 0?void 0:f.modify(h):new ot(h)})}),typeof g<"u"){let T;if(W(g)){let{wrapping:j,namedType:x}=ve(g);T=Oe(this.getOrBuildType(x),j)}else{let{wrapping:j}=X(o.fields[a].type);T=Oe(this.getOutputType(g),j)}r[a].type=T}typeof w<"u"&&(r[a].args=Object.assign(Object.assign({},this.buildArgs(w??{},e,a)),r[a].args))}})}),r}buildOutputFields(e,t,i){return e.forEach(r=>{i[r.name]=this.buildOutputField(r,t)}),i}buildInputObjectFields(e,t){let i={};return e.forEach(r=>{i[r.name]=this.buildInputObjectField(r,t)}),i}getNonNullDefault(e,t){var i,r;let{nonNullDefaults:s={}}=e??{};return(r=(i=s[t])!==null&&i!==void 0?i:this.config.nonNullDefaults[t])!==null&&r!==void 0?r:!1}buildOutputField(e,t){var i,r;if(!e.type)throw new Error(`Missing required "type" field for ${t.name}.${e.name}`);let s=new ot(e),o=this.getNonNullDefault((r=(i=t.extensions)===null||i===void 0?void 0:i.nexus)===null||r===void 0?void 0:r.config,"output"),{namedType:a,wrapping:p}=ve(e.type),u=st(o,p,e.wrapping),l={name:e.name,type:Oe(this.getOutputType(a),u),args:this.buildArgs(e.args||{},t,e.name),description:e.description,deprecationReason:e.deprecation,extensions:Object.assign(Object.assign({},e.extensions),{nexus:s})};return Object.assign({resolve:this.makeFinalResolver({builder:this.builderLens,fieldConfig:l,parentTypeConfig:t,schemaConfig:this.config,schemaExtension:this.schemaExtension},e.resolve),subscribe:e.subscribe},l)}makeFinalResolver(e,t){let i=t||Os;if(this.onCreateResolverFns.length){let r=this.onCreateResolverFns.map(s=>s(e)).filter(s=>s);if(r.length)return In(r,i)}return i}buildInputObjectField(e,t){var i,r,s,o;let a=this.getNonNullDefault((r=(i=t.extensions)===null||i===void 0?void 0:i.nexus)===null||r===void 0?void 0:r.config,"input"),{namedType:p,wrapping:u}=ve(e.type),l=st(a,u,e.wrapping);return{type:Oe(this.getInputType(p),l),defaultValue:e.default,description:e.description,extensions:Object.assign(Object.assign({},e.extensions),{nexus:(o=(s=e.extensions)===null||s===void 0?void 0:s.nexus)!==null&&o!==void 0?o:{}})}}buildArgs(e,t,i){var r,s,o,a;let p={};for(let[u,l]of Object.entries(e)){let c=this.getNonNullDefault((s=(r=t.extensions)===null||r===void 0?void 0:r.nexus)===null||s===void 0?void 0:s.config,"input"),f=Object.assign(Object.assign({},jn(l).value),{fieldName:i,argName:u,parentType:t.name,configFor:"arg"});for(let E of this.onAddArgFns){let w=E(f);w!=null&&(f=w)}let{namedType:m,wrapping:y}=ve(f.type),g=st(c,y);p[u]={type:Oe(this.getInputType(m),g),description:f.description,defaultValue:f.default,extensions:Object.assign(Object.assign({},f.extensions),{nexus:(a=(o=f.extensions)===null||o===void 0?void 0:o.nexus)!==null&&a!==void 0?a:{}})}}return p}getInterface(e){let t=this.getOrBuildType(e);if(!Cs(t))throw new Error(`Expected ${e} to be an interfaceType, saw ${t.constructor.name}(${t.name})`);return t}getInputType(e){let t=_e(e),i=this.getOrBuildType(t);if(!Ds(i)&&!ks(i))throw new Error(`Expected ${t} to be a possible input type, saw ${i.constructor.name}(${i.name})`);return i}getOutputType(e){let t=this.getOrBuildType(e);if(!Si(t))throw new Error(`Expected ${e} to be a valid output type, saw ${t.constructor.name}`);return t}getObjectType(e){if(se(e))return this.getObjectType(e.name);let t=this.getOrBuildType(e);if(!Rn(t))throw new Error(`Expected ${e} to be a objectType, saw ${t.constructor.name}`);return t}getOrBuildType(e,t=!1){var i,r;if(At(e),kn(e))return e;if(se(e))return this.getOrBuildType(e.name,!0);if(Mi[e])return Mi[e];if(this.finalTypeMap[e])return this.finalTypeMap[e];if(this.buildingTypes.has(e))throw new Error(`GraphQL Nexus: Circular dependency detected, while building types ${Array.from(this.buildingTypes)}`);let s=(r=(i=this.pendingTypeMap[e])!==null&&i!==void 0?i:this.graphqlNamedTypeMap[e])!==null&&r!==void 0?r:this.graphqlMergeSchemaMap[e];if(se(s)){if(this.buildingTypes.add(s.name),ne(s))return this.buildObjectType(s.value);if(ie(s))return this.buildInterfaceType(s.value);if(bn(s))return this.buildEnumType(s.value);if(Dt(s))return this.buildScalarType(s.value);if(Ce(s))return this.buildInputObjectType(s.value);if(Nn(s))return this.buildUnionType(s.value);console.warn("Unknown kind of type def to build. It will be ignored. The type def was: %j",e)}return this.missingType(e,t)}walkInputType(e){let t=new ue({typeName:e.name,addField:i=>this.maybeTraverseInputFieldType(i),addDynamicInputFields:(i,r)=>this.addDynamicInputFields(i,r),warn:()=>{}});return e.definition(t),e}addDynamicInputFields(e,t){O(this.dynamicInputFields,(i,r)=>{if(typeof i=="string")return this.addDynamicField(r,i,e);e[r]=(...s)=>i.value.factory({args:s,typeDef:e,builder:this.builderLens,typeName:e.typeName,wrapping:t})})}addDynamicOutputMembers(e,t,i){O(this.dynamicOutputFields,(r,s)=>{if(typeof r=="string")return this.addDynamicField(s,r,e);e[s]=(...o)=>r.value.factory({args:o,typeDef:e,builder:this.builderLens,typeName:e.typeName,stage:t,wrapping:i})}),O(this.dynamicOutputProperties,(r,s)=>{Object.defineProperty(e,s,{get(){return r.value.factory({typeDef:e,builder:this.builderLens,typeName:e.typeName,stage:t})},enumerable:!0})})}addDynamicField(e,t,i){i[e]=(r,s)=>{let o={type:t};if(typeof s=="function")throw new Error(pe.removedFunctionShorthand(i.typeName,r));o=Object.assign(Object.assign({},o),s),i.field(r,o)}}walkOutputType(e){let t=new le({typeName:e.name,addInterfaces:i=>{i.forEach(r=>{typeof r!="string"&&this.addType(r)})},addField:i=>this.maybeTraverseOutputFieldType(i),addDynamicOutputMembers:(i,r)=>this.addDynamicOutputMembers(i,"walk",r),addModification:i=>this.maybeTraverseModification(i),warn:()=>{}});return e.definition(t),e}walkInterfaceType(e){let t=new ee({typeName:e.name,addModification:i=>this.maybeTraverseModification(i),addInterfaces:i=>{i.forEach(r=>{typeof r!="string"&&this.addType(r)})},addField:i=>this.maybeTraverseOutputFieldType(i),addDynamicOutputMembers:(i,r)=>this.addDynamicOutputMembers(i,"walk",r),warn:()=>{}});return e.definition(t),e}maybeTraverseModification(e){let{type:t,args:i}=e;if(t){let r=_e(e.type);typeof r!="string"&&this.addType(r)}i&&this.traverseArgs(i)}maybeTraverseOutputFieldType(e){let{args:t,type:i}=e,r=_e(i);typeof r!="string"&&this.addType(r),t&&this.traverseArgs(t)}traverseArgs(e){O(e,t=>{let i=hn(t);typeof i!="string"&&this.addType(i)})}maybeTraverseInputFieldType(e){let{type:t}=e,i=_e(t);typeof i!="string"&&this.addType(i)}handleMergeSchema(e){var t;let{types:i}=e.schema.toConfig(),r={};for(let s of i)s.name.startsWith("__")||!((t=e.skipTypes)===null||t===void 0)&&t.includes(s.name)||(r[s.name]=this.handleNativeType(s,e));return r}handleNativeType(e,t){for(var i,r,s;Ls(e);)e=e.ofType;return(i=(r=this.pendingTypeMap)[s=e.name])!==null&&i!==void 0||(r[s]=null),Gn(e,t)}};function Ai(n){return new Error(`${n} was already defined and imported as a type, check the docs for extending types`)}function mt(n){let e=new nn(n);e.addTypes(n.types),n.schemaRoots&&e.addTypes(n.schemaRoots);let{finalConfig:t,typeMap:i,missingTypes:r,schemaExtension:s,onAfterBuildFns:o}=e.getFinalTypeMap();function a(u,l){var c,f;let m=(f=(c=n.schemaRoots)===null||c===void 0?void 0:c[u])!==null&&f!==void 0?f:l,y=null;if(typeof m=="string"?y=i[m]:m&&(ne(m)||Rn(m))&&(y=i[m.name]),y&&!Rn(y))throw new Error(`Expected ${u} to be a objectType, saw ${y.constructor.name}`);return y}let p=new As({query:a("query","Query"),mutation:a("mutation","Mutation"),subscription:a("subscription","Subscription"),types:ce(i),extensions:Object.assign(Object.assign({},n.extensions),{nexus:s})});return o.forEach(u=>u(p)),{schema:p,missingTypes:r,finalConfig:t}}function _i(n){var e,t,i,r,s;let o={features:{abstractTypeRuntimeChecks:!0,abstractTypeStrategies:{isTypeOf:!1,resolveType:!0,__typename:!1}},nonNullDefaults:{input:!1,output:!1},plugins:[ke()]};return n.features?(n.features.abstractTypeStrategies?(n.features.abstractTypeStrategies.__typename=(e=n.features.abstractTypeStrategies.__typename)!==null&&e!==void 0?e:!1,n.features.abstractTypeStrategies.isTypeOf=(t=n.features.abstractTypeStrategies.isTypeOf)!==null&&t!==void 0?t:!1,n.features.abstractTypeStrategies.resolveType=(i=n.features.abstractTypeStrategies.resolveType)!==null&&i!==void 0?i:!1):n.features.abstractTypeStrategies=o.features.abstractTypeStrategies,n.features.abstractTypeStrategies.__typename===!0&&(n.features.abstractTypeRuntimeChecks=!1),n.features.abstractTypeRuntimeChecks===void 0&&(n.features.abstractTypeRuntimeChecks=o.features.abstractTypeRuntimeChecks)):n.features=o.features,n.plugins=(r=n.plugins)!==null&&r!==void 0?r:[],n.nonNullDefaults=Object.assign(Object.assign({},o.nonNullDefaults),(s=n.nonNullDefaults)!==null&&s!==void 0?s:{}),n}import{__awaiter as Vi}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{__awaiter as Be}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{lexicographicSortSchema as zi,printSchema as Xs}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import*as rn from"node:path";var Di=`### This file was generated by Nexus Schema
### Do not make changes to this file directly
`,Re=`/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */
`;import{__awaiter as Gi}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{isOutputType as Bs}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import*as we from"node:path";var Ln={Int:"number",String:"string",ID:"string",Float:"number",Boolean:"boolean"};function Bn(n,e){return(t,i)=>Gi(this,void 0,void 0,function*(){let{headers:r,skipTypes:s=["Query","Mutation","Subscription"],mapping:o,debug:a}=n,p=t.getTypeMap(),u=new Set,l=[],c={},f={},m=Object.assign(Object.assign({},Ln),o),y=new Set(ce(m).concat(typeof e=="string"&&e||"").map(b=>{let h=b.match(/^(\w+)\./);return h?h[1]:null}).filter(b=>b));s.forEach(b=>{if(typeof b=="string")u.add(b);else if(b instanceof RegExp)l.push(b);else throw new Error("Invalid type for options.skipTypes, expected string or RegExp")});let g=yield Promise.all(n.modules.map(b=>Gi(this,void 0,void 0,function*(){let h=Ee("fs"),j=Ee("util").promisify(h.readFile),{module:x,glob:$=!0,onlyTypes:D,alias:M,typeMatch:qe}=b;if(we.isAbsolute(x)&&we.extname(x)!==".ts")return console.warn(`Nexus Schema Typegen: Expected module ${x} to be an absolute path to a TypeScript module, skipping.`);let C,z;try{C=__rResolve$(x,{paths:[__Process$.cwd()]}),we.extname(C)!==".ts"&&(C=qs(C,x)),z=yield j(C,"utf-8")}catch(oe){return oe instanceof Error&&oe.message.indexOf("Cannot find module")!==-1?console.error(`GraphQL Nexus: Unable to find file or module ${x}, skipping`):console.error(oe.message),null}let L=(we.isAbsolute(x)?Pe(C,i):x).replace(Ft,"");return c[M]&&c[M]!==L?console.warn(`Nexus Schema Typegen: Cannot have multiple type sources ${f[M]} and ${x} with the same alias ${M}, skipping`):(c[M]=L,y.has(M)&&(f[M]=[L,$],y.delete(M)),{alias:M,glob:$,importPath:L,fileContents:z,onlyTypes:D,typeMatch:qe||Ci})}))),E=new Set(Object.keys(Ln));Object.keys(p).forEach(b=>{if(b.startsWith("__")||u.has(b)||l.some(T=>T.test(b))||m[b]||E.has(b))return;let h=t.getType(b);if(Bs(h))for(let T=0;T<g.length;T++){let j=g[T];if(!j||j.onlyTypes&&!j.onlyTypes.some(L=>L instanceof RegExp?L.test(b):L===b))continue;let{fileContents:x,importPath:$,glob:D,alias:M,typeMatch:qe}=j,C=qe(h,Ci(h)[0]),z=Ws(x,Array.isArray(C)?C:[C]);z?(a&&$t(`Matched type - ${b} in "${$}" - ${M}.${z[1]}`),f[M]=[$,D],m[b]=`${M}.${z[1]}`):a&&$t(`No match for ${b} in "${$}" using ${C}`)}}),y.size>0&&console.error(`Missing required typegen import: ${Array.from(y)}`);let w=[];return Object.keys(f).sort().forEach(b=>{let[h,T]=f[b],j=h.replace(/\\+/g,"/");w.push(`import type ${T?"* as ":""}${b} from "${j}"`)}),{headers:r||[Re],sourceTypeMap:m,imports:w,contextTypeImport:e,nexusSchemaImportId:J().name}})}function qs(n,e){try{let t=n.replace(we.extname(n),".d.ts");return __rResolve$(t),t}catch(t){console.error(t)}throw new Error(`Unable to find typings associated with ${e}, skipping`)}var Ws=(n,e)=>{for(let t=0;t<e.length;t++){let r=e[t].exec(n);if(r)return r}return null},Ci=n=>[new RegExp(`(?:interface|type|class|enum)\\s+(${n.name})\\W`,"g")];import{__awaiter as Us}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import*as ki from"node:path";function qn(n){return function(t,i){return Us(this,void 0,void 0,function*(){let r;try{r=Ee("prettier")}catch{return console.warn("It looks like you provided a `prettierConfig` option to GraphQL Nexus, but you do not have prettier installed as a dependency in your project. Please add it as a peerDependency of nexus to use this feature. Skipping formatting."),t}let s;if(typeof n=="string"){if(!ki.isAbsolute(n))return console.error(new Error(`Expected prettierrc path to be absolute, saw ${n}. Skipping formatting.`)),t;s=yield r.resolveConfig("ignore_this",{config:n})}else s=n;return r.format(t,Object.assign(Object.assign({},s),{parser:i==="types"?"typescript":"graphql"}))})}}import{__rest as zs}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import{getNamedType as Qs,isEnumType as Ri,isInputObjectType as Vs,isInterfaceType as Wn,isListType as Li,isNonNullType as Un,isObjectType as Hs,isScalarType as Bi,isSpecifiedScalarType as qi,isUnionType as Wi}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var Ui={ID:"string",String:"string",Float:"number",Int:"number",Boolean:"boolean"},Le=class{constructor(e,t){this.schema=e,this.typegenInfo=t,this.printObj=(i,r)=>(s,o)=>[`${i}${o}: { // ${r}`].concat(S(s,(a,p)=>`${i}  ${p}${a[0]} ${a[1]}`)).concat(`${i}}`).join(`
`),this.groupedTypes=Ae(e),this.printImports={},this.hasDiscriminatedTypes=!1}print(){let e=[this.printCommon(),this.printPlugins()].join(`

`);return[this.printHeaders(),e].join(`

`)}printConfigured(){if(this.typegenInfo.globalsPath){let e=this.printPlugins(),t=[this.printHeadersGlobal(),this.printDynamicImport(!0),e].join(`

`);this.printImports={};let i=this.printCommon();return{tsTypes:[this.printHeadersCommon(),i].join(`

`),globalTypes:t}}return{tsTypes:this.print(),globalTypes:null}}printCommon(){return[this.printInputTypeMap(),this.printEnumTypeMap(),this.printScalarTypeMap(),this.printObjectTypeMap(),this.printInterfaceTypeMap(),this.printUnionTypeMap(),this.printRootTypeDef(),this.printAllTypesMap(),this.printFieldTypesMap(),this.printFieldTypeNamesMap(),this.printArgTypeMap(),this.printAbstractTypeMembers(),this.printInheritedFieldMap(),this.printTypeNames("object","NexusGenObjectNames","NexusGenObjects"),this.printTypeNames("input","NexusGenInputNames","NexusGenInputs"),this.printTypeNames("enum","NexusGenEnumNames","NexusGenEnums"),this.printTypeNames("interface","NexusGenInterfaceNames","NexusGenInterfaces"),this.printTypeNames("scalar","NexusGenScalarNames","NexusGenScalars"),this.printTypeNames("union","NexusGenUnionNames","NexusGenUnions"),this.printIsTypeOfObjectTypeNames("NexusGenObjectsUsingAbstractStrategyIsTypeOf"),this.printResolveTypeAbstractTypes("NexusGenAbstractsUsingStrategyResolveType"),this.printFeaturesConfig("NexusGenFeaturesConfig"),this.printGenTypeMap()].join(`

`)}printHeaders(){return[this.printHeadersCommon(),this.printHeadersGlobal()].join(`
`)}printHeadersCommon(){return[this.typegenInfo.headers.join(`
`),this.typegenInfo.imports.join(`
`),this.printDynamicImport()].join(`
`)}printHeadersGlobal(){var e,t;let i=[this.printDynamicInputFieldDefinitions(),this.printDynamicOutputFieldDefinitions(),this.printDynamicOutputPropertyDefinitions(),Ys];return this.typegenInfo.globalsPath&&(i.unshift(`import type { NexusGenTypes } from '${Pe(this.typegenInfo.typegenPath,(e=this.typegenInfo.globalsPath)!==null&&e!==void 0?e:"")}'`),i.unshift(...(t=this.typegenInfo.globalsHeaders)!==null&&t!==void 0?t:[]),i.unshift(Re)),i.join(`
`)}printGenTypeMap(){return["export interface NexusGenTypes {"].concat([`  context: ${this.printContext()};`,"  inputTypes: NexusGenInputs;","  rootTypes: NexusGenRootTypes;","  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;","  argTypes: NexusGenArgTypes;","  fieldTypes: NexusGenFieldTypes;","  fieldTypeNames: NexusGenFieldTypeNames;","  allTypes: NexusGenAllTypes;","  typeInterfaces: NexusGenTypeInterfaces;","  objectNames: NexusGenObjectNames;","  inputNames: NexusGenInputNames;","  enumNames: NexusGenEnumNames;","  interfaceNames: NexusGenInterfaceNames;","  scalarNames: NexusGenScalarNames;","  unionNames: NexusGenUnionNames;","  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];","  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];","  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']","  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];","  abstractTypeMembers: NexusGenAbstractTypeMembers;","  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;","  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;","  features: NexusGenFeaturesConfig;"]).concat("}").join(`
`)}printDynamicImport(e=!1){var t;let{sourceTypings:i}=this.schema.extensions.nexus.config,{contextTypeImport:r}=this.typegenInfo,s=[],o={},a=this.typegenInfo.typegenPath,p=(t=this.typegenInfo.nexusSchemaImportId)!==null&&t!==void 0?t:J().name;if(this.printImports[p]||this.maybeAddCoreImport(e),!e){if(r){let u=Mt(r,"context",a);o[u]=o[u]||new Set,o[u].add(r.alias?`${r.export} as ${r.alias}`:r.export)}O(i,(u,l)=>{if(typeof u!="string"){let c=Mt(u,l,a);o[c]=o[c]||new Set,o[c].add(u.alias?`${u.export} as ${u.alias}`:u.export)}}),O(o,(u,l)=>{s.push(`import type { ${Array.from(u).join(", ")} } from ${JSON.stringify(l)}`)})}return O(this.printImports,(u,l)=>{let{default:c}=u,f=zs(u,["default"]),m=[];c&&m.push(c);let y=[];O(f,(g,E)=>{y.push(g!==!0?`${E} as ${g}`:`${E}`)}),y.length&&m.push(`{ ${y.join(", ")} }`),s.push(`import type ${m.join(", ")} from ${JSON.stringify(l)}`)}),s.join(`
`)}maybeAddCoreImport(e=!1){var t;let i=(t=this.typegenInfo.nexusSchemaImportId)!==null&&t!==void 0?t:J().name,{dynamicFields:{dynamicInputFields:r,dynamicOutputFields:s}}=this.schema.extensions.nexus.config,o=!1,a=[r,s].some(p=>Object.keys(p).length>0);this.typegenInfo.globalsPath?o=e?a:this.hasDiscriminatedTypes:o=a||this.hasDiscriminatedTypes,o&&(this.printImports[i]={core:!0})}printDynamicInputFieldDefinitions(){let{dynamicInputFields:e}=this.schema.extensions.nexus.config.dynamicFields;return Object.keys(e).length?["declare global {","  interface NexusGenCustomInputMethods<TypeName extends string> {"].concat(S(e,(t,i)=>{if(typeof t=="string"){let r=this.schema.getType(t);return this.prependDoc(`    ${i}<FieldName extends string>(fieldName: FieldName, opts?: core.CommonInputFieldConfig<TypeName, FieldName>): void // ${JSON.stringify(t)};`,r?.description)}return this.prependDoc(`    ${i}${t.value.typeDefinition||"(...args: any): void"}`,t.value.typeDescription)})).concat(["  }","}"]).join(`
`):[]}printDynamicOutputFieldDefinitions(){let{dynamicOutputFields:e}=this.schema.extensions.nexus.config.dynamicFields;return Object.keys(e).length?["declare global {","  interface NexusGenCustomOutputMethods<TypeName extends string> {"].concat(S(e,(t,i)=>{if(typeof t=="string"){let r=this.schema.getType(t);return this.prependDoc(`    ${i}<FieldName extends string>(fieldName: FieldName, ...opts: core.ScalarOutSpread<TypeName, FieldName>): void // ${JSON.stringify(t)};`,r?.description)}return this.prependDoc(`    ${i}${t.value.typeDefinition||"(...args: any): void"}`,t.value.typeDescription)})).concat(["  }","}"]).join(`
`):[]}prependDoc(e,t){let i="";if(t){let r=t.split(`
`).map(s=>s.trimLeft());r[0]===""&&(r=r.slice(1)),r[r.length-1]===""&&(r=r.slice(0,-1)),i=["    /**",...r.map(s=>`     *${s?` ${s}`:""}`),"     */"].join(`
`)+`
`}return`${i}${e}`}printDynamicOutputPropertyDefinitions(){let{dynamicOutputProperties:e}=this.schema.extensions.nexus.config.dynamicFields;return Object.keys(e).length?["declare global {","  interface NexusGenCustomOutputProperties<TypeName extends string> {"].concat(S(e,(t,i)=>this.prependDoc(`    ${i}${t.value.typeDefinition||": any"}`,t.value.typeDescription))).concat(["  }","}"]).join(`
`):[]}printInheritedFieldMap(){let t=[].concat(this.groupedTypes.object,this.groupedTypes.interface.map(tt)).map(i=>i.getInterfaces().length?[i.name,i.getInterfaces().map(r=>r.name)]:null).filter(i=>i);return["export interface NexusGenTypeInterfaces {"].concat(t.map(([i,r])=>`  ${i}: ${r.map(s=>JSON.stringify(s)).join(" | ")}`)).concat("}").join(`
`)}printContext(){var e,t;return((e=this.typegenInfo.contextTypeImport)===null||e===void 0?void 0:e.alias)||((t=this.typegenInfo.contextTypeImport)===null||t===void 0?void 0:t.export)||"any"}printAbstractTypeMembers(){return this.printTypeInterface("NexusGenAbstractTypeMembers",this.buildAbstractTypeMembers())}buildAbstractTypeMembers(){let e={};return[].concat(this.groupedTypes.union).concat(this.groupedTypes.interface).forEach(i=>{if(Wn(i)){let r=this.schema.getPossibleTypes(i).map(s=>s.name);r.length>0&&(e[i.name]=r.map(s=>JSON.stringify(s)).join(" | "))}else e[i.name]=i.getTypes().map(r=>JSON.stringify(r.name)).join(" | ")}),e}printTypeNames(e,t,i){let s=this.groupedTypes[e].length===0?"never":`keyof ${i}`;return`export type ${t} = ${s};`}printIsTypeOfObjectTypeNames(e){let t=this.groupedTypes.object.filter(r=>r.isTypeOf!==void 0),i=t.length===0?"never":t.map(r=>JSON.stringify(r.name)).sort().join(" | ");return`export type ${e} = ${i};`}printResolveTypeAbstractTypes(e){let t=[...this.groupedTypes.interface,...this.groupedTypes.union].filter(r=>r.resolveType!==void 0),i=t.length===0?"never":t.map(r=>JSON.stringify(r.name)).sort().join(" | ");return`export type ${e} = ${i};`}printFeaturesConfig(e){var t,i;let r=(i=(t=this.schema.extensions.nexus.config.features)===null||t===void 0?void 0:t.abstractTypeStrategies)!==null&&i!==void 0?i:{},s=Js(ln(r,o=>o??!1));return[`export type ${e} = {`].concat(`  abstractTypeStrategies: ${s}`).concat("}").join(`
`)}buildEnumTypeMap(){let e={};return this.groupedTypes.enum.forEach(t=>{let i=this.resolveSourceType(t.name);if(i)e[t.name]=i;else{let r=t.getValues().map(s=>JSON.stringify(s.value));e[t.name]=r.join(" | ")}}),e}buildInputTypeMap(){let e={};return this.groupedTypes.input.forEach(t=>{O(t.getFields(),i=>{e[t.name]=e[t.name]||{},e[t.name][i.name]=this.normalizeArg(i)})}),e}buildScalarTypeMap(){let e={};return this.groupedTypes.scalar.forEach(t=>{var i;if(qi(t)){e[t.name]=(i=this.resolveSourceType(t.name))!==null&&i!==void 0?i:Ui[t.name];return}let r=this.resolveSourceType(t.name);r?e[t.name]=r:e[t.name]="any"}),e}printInputTypeMap(){let e=this.buildInputTypeMap();return this.typegenInfo.declareInputs?[...S(e,(i,r)=>this.printNamedObj(r,i)),this.printNamedMap("NexusGenInputs",e)].join(`

`):this.printTypeFieldInterface("NexusGenInputs",e,"input type")}printEnumTypeMap(){let e=this.buildEnumTypeMap();return this.typegenInfo.declareInputs?[...S(e,(t,i)=>`export type ${i} = ${t}`),this.printNamedMap("NexusGenEnums",e)].join(`

`):this.printTypeInterface("NexusGenEnums",e)}printScalarTypeMap(){return this.printTypeInterface("NexusGenScalars",this.buildScalarTypeMap())}shouldDiscriminateType(e,t){var i,r;return!((r=(i=this.schema.extensions.nexus.config.features)===null||i===void 0?void 0:i.abstractTypeStrategies)===null||r===void 0)&&r.__typename?e.resolveType!==void 0||t.isTypeOf!==void 0?"optional":"required":!1}maybeDiscriminate(e,t){let i=this.shouldDiscriminateType(e,t);return i===!1?`NexusGenRootTypes['${t.name}']`:(this.hasDiscriminatedTypes=!0,`core.Discriminate<'${t.name}', '${i}'>`)}buildRootTypeMap(e){let t={};return e.forEach(i=>{let r=this.resolveSourceType(i.name);if(r){t[i.name]=r;return}if(Wi(i))t[i.name]=i.getTypes().map(s=>this.maybeDiscriminate(i,s)).join(" | ");else if(Wn(i)){let s=this.schema.getPossibleTypes(i).map(o=>this.maybeDiscriminate(i,o));s.length>0?t[i.name]=s.join(" | "):t[i.name]="any"}else i.name==="Query"||i.name==="Mutation"?t[i.name]="{}":O(i.getFields(),s=>{let o=t[i.name]=t[i.name]||{};this.hasResolver(s,i)||typeof o!="string"&&(o[s.name]=[this.argSeparator(s.type,!1),this.printOutputType(s.type)])})}),t}resolveSourceType(e){let t=this.schema.extensions.nexus.config.sourceTypings[e];return t?typeof t=="string"?t:t.export:this.typegenInfo.sourceTypeMap[e]}hasResolver(e,t){return e.extensions&&at(e.extensions.nexus)?e.extensions.nexus.hasDefinedResolver:!!e.resolve}printObjectTypeMap(){return this.printRootTypeFieldInterface("NexusGenObjects",this.buildRootTypeMap(this.groupedTypes.object))}printInterfaceTypeMap(){return this.printRootTypeFieldInterface("NexusGenInterfaces",this.buildRootTypeMap(this.groupedTypes.interface))}printUnionTypeMap(){return this.printRootTypeFieldInterface("NexusGenUnions",this.buildRootTypeMap(this.groupedTypes.union))}printRootTypeDef(){let e=[];return this.groupedTypes.interface.length&&e.push("NexusGenInterfaces"),this.groupedTypes.object.length&&e.push("NexusGenObjects"),this.groupedTypes.union.length&&e.push("NexusGenUnions"),`export type NexusGenRootTypes = ${e.join(" & ")}`}printAllTypesMap(){let e=["NexusGenRootTypes"];return this.groupedTypes.scalar.length&&e.push("NexusGenScalars"),this.groupedTypes.enum.length&&e.push("NexusGenEnums"),`export type NexusGenAllTypes = ${e.join(" & ")}`}buildArgTypeMap(){let e={};return[].concat(this.groupedTypes.object).concat(this.groupedTypes.interface).forEach(i=>{O(i.getFields(),r=>{r.args.length>0&&(e[i.name]=e[i.name]||{},e[i.name][r.name]=r.args.reduce((s,o)=>(s[o.name]=this.normalizeArg(o),s),{}))})}),e}printArgTypeMap(){let e=this.buildArgTypeMap();if(this.typegenInfo.declareInputs){let t=[];return O(e,(i,r)=>{O(i,(s,o)=>{t.push(this.printNamedObj(this.getArgsName(r,o),s))})}),[...t,this.printArgTypeFieldInterface(e)].join(`

`)}return this.printArgTypeFieldInterface(e)}getArgsName(e,t){return`${e}${t.slice(0,1).toUpperCase().concat(t.slice(1))}Args`}printNamedObj(e,t){return[`export interface ${e} {`,...S(t,(i,r)=>`  ${r}${i[0]} ${i[1]}`),"}"].join(`
`)}printNamedMap(e,t){return[`export interface ${e} {`,...S(t,(i,r)=>`  ${r}: ${r}`),"}"].join(`
`)}buildReturnTypeMap(){let e={};return[].concat(this.groupedTypes.object).concat(this.groupedTypes.interface).forEach(i=>{O(i.getFields(),r=>{e[i.name]=e[i.name]||{},e[i.name][r.name]=[":",this.printOutputType(r.type)]})}),e}buildReturnTypeNamesMap(){let e={};return[].concat(this.groupedTypes.object).concat(this.groupedTypes.interface).forEach(i=>{O(i.getFields(),r=>{e[i.name]=e[i.name]||{},e[i.name][r.name]=[":",`'${Qs(r.type).name}'`]})}),e}printOutputType(e){let t=this.typeToArr(e);function i(r){if(r.length===1){if(Array.isArray(r[0])){let s=i(r[0]);return s.indexOf("null")===-1?`${s}[]`:`Array<${s}>`}return r[0]}if(Array.isArray(r[1])){let s=i(r[1]);return s.indexOf("null")===-1?`${s}[] | null`:`Array<${s}> | null`}return`${r[1]} | null`}return`${i(t)}; // ${e}`}typeToArr(e){let t=[];return Un(e)?e=e.ofType:t.push(null),Li(e)?t.push(this.typeToArr(e.ofType)):Bi(e)?t.push(this.printScalar(e)):Ri(e)?this.typegenInfo.declareInputs?t.push(e.name):t.push(`NexusGenEnums['${e.name}']`):(Hs(e)||Wn(e)||Wi(e))&&t.push(`NexusGenRootTypes['${e.name}']`),t}printFieldTypesMap(){return this.printTypeFieldInterface("NexusGenFieldTypes",this.buildReturnTypeMap(),"field return type")}printFieldTypeNamesMap(){return this.printTypeFieldInterface("NexusGenFieldTypeNames",this.buildReturnTypeNamesMap(),"field return type name")}normalizeArg(e){return[this.argSeparator(e.type,!!e.defaultValue),this.argTypeRepresentation(e.type)]}argSeparator(e,t){return t||Un(e)?":":"?:"}argTypeRepresentation(e){let t=this.argTypeArr(e);function i(r){if(r.length===1){if(Array.isArray(r[0])){let s=i(r[0]);return s.indexOf("null")===-1?`${s}[]`:`Array<${s}>`}return r[0]}if(Array.isArray(r[1])){let s=i(r[1]);return s.indexOf("null")===-1?`${s}[] | null`:`Array<${s}> | null`}return`${r[1]} | null`}return`${i(t)}; // ${e}`}argTypeArr(e){let t=[];return Un(e)?e=e.ofType:t.push(null),Li(e)?t.push(this.argTypeArr(e.ofType)):Bi(e)?t.push(this.printScalar(e)):Ri(e)?this.typegenInfo.declareInputs?t.push(e.name):t.push(`NexusGenEnums['${e.name}']`):Vs(e)&&(this.typegenInfo.declareInputs?t.push(e.name):t.push(`NexusGenInputs['${e.name}']`)),t}printTypeInterface(e,t){return[`export interface ${e} {`].concat(S(t,(i,r)=>`  ${r}: ${i}`)).concat("}").join(`
`)}printRootTypeFieldInterface(e,t){return[`export interface ${e} {`].concat(S(t,(i,r)=>typeof i=="string"?`  ${r}: ${i};`:Object.keys(i).length===0?`  ${r}: {};`:this.printObj("  ","root type")(i,r))).concat("}").join(`
`)}printTypeFieldInterface(e,t,i){return[`export interface ${e} {`].concat(S(t,this.printObj("  ",i))).concat("}").join(`
`)}printArgTypeFieldInterface(e){return["export interface NexusGenArgTypes {"].concat(S(e,(t,i)=>this.typegenInfo.declareInputs?[`  ${i}: {`].concat(S(t,(r,s)=>`    ${s}: ${this.getArgsName(i,s)}`)).concat("  }").join(`
`):[`  ${i}: {`].concat(S(t,this.printObj("    ","args"))).concat("  }").join(`
`))).concat("}").join(`
`)}printScalar(e){var t;return qi(e)?(t=this.resolveSourceType(e.name))!==null&&t!==void 0?t:Ui[e.name]:`NexusGenScalars['${e.name}']`}printPlugins(){let e=["  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {"],t=["  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {"],i=["  interface NexusGenPluginArgConfig {"],r=["  interface NexusGenPluginSchemaConfig {"],s=["  interface NexusGenPluginTypeConfig<TypeName extends string> {"],o=["  interface NexusGenPluginInputTypeConfig<TypeName extends string> {"],a=[];return(this.schema.extensions.nexus.config.plugins||[]).forEach(u=>{u.config.fieldDefTypes&&e.push(yt(this.printType(u.config.fieldDefTypes),"    ")),u.config.inputFieldDefTypes&&t.push(yt(this.printType(u.config.inputFieldDefTypes),"    ")),u.config.objectTypeDefTypes&&s.push(yt(this.printType(u.config.objectTypeDefTypes),"    ")),u.config.inputObjectTypeDefTypes&&o.push(yt(this.printType(u.config.inputObjectTypeDefTypes),"    ")),u.config.argTypeDefTypes&&i.push(yt(this.printType(u.config.argTypeDefTypes),"    "))}),[a.join(`
`),["declare global {",[s.concat("  }").join(`
`),o.concat("  }").join(`
`),e.concat("  }").join(`
`),t.concat("  }").join(`
`),r.concat("  }").join(`
`),i.concat("  }").join(`
`)].join(`
`),"}"].join(`
`)].join(`
`)}printType(e){return Array.isArray(e)?e.map(t=>this.printType(t)).join(`
`):wn(e)?(e.imports.forEach(t=>{this.addImport(t)}),e.toString()):Rt(e)?(this.addImport(e),""):e}addImport(e){if(!Rt(e)){console.warn(`Expected printedGenTypingImport, saw ${e}`);return}this.printImports[e.config.module]=this.printImports[e.config.module]||{},e.config.default&&(this.printImports[e.config.module].default=e.config.default),e.config.bindings&&e.config.bindings.forEach(t=>{typeof t=="string"?this.printImports[e.config.module][t]=!0:this.printImports[e.config.module][t[0]]=t[1]})}};function yt(n,e){return n.split(`
`).map(t=>`${e}${t}`).join(`
`)}var Ys=`
declare global {
  interface NexusGen extends NexusGenTypes {}
}`;function Js(n){return["{",S(n,(e,t)=>`    ${t}: ${e}`).join(`
`),"  }"].join(`
`)}var je=class{constructor(e){this.config=e}generateArtifacts(e){return Be(this,void 0,void 0,function*(){let t=this.sortSchema(e),{typegen:i}=this.config.outputs;if(this.config.outputs.schema||i){let{schemaTypes:r,tsTypes:s,globalTypes:o}=yield this.generateArtifactContents(t,i);this.config.outputs.schema&&(yield this.writeFile("schema",r,this.config.outputs.schema)),i&&(typeof i=="string"?yield this.writeFile("types",s,i):(yield this.writeFile("types",s,i.outputPath),typeof i.globalsPath=="string"&&(yield this.writeFile("types",o??"",i.globalsPath))))}})}generateArtifactContents(e,t){return Be(this,void 0,void 0,function*(){let i={schemaTypes:this.generateSchemaFile(e),tsTypes:"",globalTypes:null};if(!t)return i;if(typeof t=="string")i.tsTypes=yield this.generateTypesFile(e,t);else{let r=yield this.generateConfiguredTypes(e,t);i.tsTypes=r.tsTypes,i.globalTypes=r.globalTypes}return i})}sortSchema(e){let t=e;return typeof zi<"u"&&(t=zi(e)),t}writeFile(e,t,i){return Be(this,void 0,void 0,function*(){if(typeof i!="string"||!rn.isAbsolute(i))return Promise.reject(new Error(`Expected an absolute path to output the Nexus ${e}, saw ${i}`));let r=Ee("fs"),s=Ee("util"),[o,a,p,u]=[s.promisify(r.readFile),s.promisify(r.writeFile),s.promisify(r.unlink),s.promisify(r.mkdir)],l=null;typeof this.config.formatTypegen=="function"?l=this.config.formatTypegen:this.config.prettierConfig&&(l=qn(this.config.prettierConfig));let c=typeof l=="function"?yield l(t,e):t,[f,m]=yield Promise.all([c,o(i,"utf8").catch(()=>"")]);if(f!==m){let y=rn.dirname(i);try{yield u(y,{recursive:!0})}catch(g){if(g.code!=="EEXIST")throw g}try{yield p(i)}catch(g){if(g.code!=="ENOENT"&&g.code!=="ENOTDIR")throw g}return a(i,f)}})}generateSchemaFile(e){let t=this.config.customPrintSchemaFn?this.config.customPrintSchemaFn(e):Xs(e);return[Di,t].join(`

`)}generateTypesFile(e,t){return Be(this,void 0,void 0,function*(){let i=yield this.getTypegenInfo(e,t);return new Le(e,Object.assign(Object.assign({declareInputs:!1},i),{typegenPath:t})).print()})}generateConfiguredTypes(e,t){return Be(this,void 0,void 0,function*(){let{outputPath:i,globalsPath:r,globalsHeaders:s,declareInputs:o=!1}=t,a=yield this.getTypegenInfo(e,i);return new Le(e,Object.assign(Object.assign({},a),{typegenPath:i,globalsPath:r,globalsHeaders:s,declareInputs:o})).printConfigured()})}getTypegenInfo(e,t){var i;return Be(this,void 0,void 0,function*(){if("typegenConfig"in this.config)throw new Error("Error: typegenConfig was removed from the API. Please open an issue if you were using it.");return this.config.sourceTypes?Bn(this.config.sourceTypes,this.config.contextType)(e,t||((i=this.config.outputs.typegen)===null||i===void 0?void 0:i.outputPath)||""):{nexusSchemaImportId:this.config.nexusSchemaImportId,headers:[Re],imports:[],contextTypeImport:this.config.contextType,sourceTypeMap:{}}})}};import{__rest as Ks}from"/v135/tslib@2.6.2/denonext/tslib.mjs";import*as Qi from"node:path";function gt(n){let{outputs:e,shouldGenerateArtifacts:t=!1}=n,i=Ks(n,["outputs","shouldGenerateArtifacts"]),r=Qi.join(__Process$.cwd(),"schema.graphql"),s=null,o=null;return e===void 0?et()&&(o=r):e===!0?o=r:typeof e=="object"?(e.schema===!0?o=r:typeof e.schema=="string"?o=Me(e.schema,"outputs.schema"):e.schema===void 0&&et(),typeof e.typegen=="string"?s={outputPath:Me(e.typegen,"outputs.typegen")}:typeof e.typegen=="object"&&(s=Object.assign(Object.assign({},e.typegen),{outputPath:Me(e.typegen.outputPath,"outputs.typegen.outputPath")}),e.typegen.globalsPath&&(s.globalsPath=Me(e.typegen.globalsPath,"outputs.typegen.globalsPath")))):e!==!1&&console.warn("You should specify a configuration value for outputs in Nexus' makeSchema. Provide one to remove this warning."),Object.assign(Object.assign({},i),{nexusSchemaImportId:J().name,outputs:{typegen:t?s:null,schema:t?o:null}})}function Hi(n){let{schema:e,missingTypes:t,finalConfig:i}=mt(n),r=gt(i),s=r.outputs.schema,o=r.outputs.typegen;if(s||o){let a=new je(r).generateArtifacts(e);if(n.shouldExitAfterGenerateArtifacts){let p="(not enabled)";r.outputs.typegen&&(p=r.outputs.typegen.outputPath,r.outputs.typegen.globalsPath&&(p+=` / ${r.outputs.typegen.globalsPath}`)),a.then(()=>{console.log(`Generated Artifacts:
          TypeScript Types  ==> ${p}
          GraphQL Schema    ==> ${r.outputs.schema||"(not enabled)"}`),__Process$.exit(0)}).catch(u=>{console.error(u),__Process$.exit(1)})}else a.catch(p=>{console.error(p)})}return Je(e,t),Xe(e,i.features),e}function Yi(n){return Vi(this,void 0,void 0,function*(){let{schema:e,missingTypes:t,finalConfig:i}=mt(n),r=gt(i);return yield new je(r).generateArtifacts(e),Je(e,t),Xe(e,i.features),e})}Yi.withArtifacts=(n,e=null)=>Vi(void 0,void 0,void 0,function*(){let{schema:t,missingTypes:i,finalConfig:r}=mt(n),s=gt(r),{schemaTypes:o,tsTypes:a,globalTypes:p}=yield new je(s).generateArtifactContents(t,e);return Je(t,i),Xe(t,r.features),{schema:t,schemaTypes:o,tsTypes:a,globalTypes:p}});import{assertValidName as Zs}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var Tt=class{constructor(e,t){this.name=e,this.config=t,Zs(e)}get value(){return this.config}};N(Tt,d.ExtendInputObject);function Ji(n){return new Tt(n.type,Object.assign(Object.assign({},n),{name:n.type}))}import{assertValidName as eo}from"/v135/graphql@16.8.1/denonext/graphql.mjs";var xt=class{constructor(e,t){this.name=e,this.config=t,eo(e)}get value(){return this.config}};N(xt,d.ExtendObject);function he(n){return new xt(n.type,Object.assign(Object.assign({},n),{name:n.type}))}function Xi(...n){return he({type:"Mutation",definition(e){if(typeof n[0]=="function")return n[0](e);let[t,i]=n,r=typeof i=="function"?i():i;e.field(t,r)}})}function Ki(n){return k(Object.assign(Object.assign({},n),{name:"Mutation"}))}function Zi(...n){return he({type:"Query",definition(e){if(typeof n[0]=="function")return n[0](e);let[t,i]=n,r=typeof i=="function"?i():i;e.field(t,r)}})}function er(n){return k(Object.assign(Object.assign({},n),{name:"Query"}))}function tr(...n){return he({type:"Subscription",definition(e){if(typeof n[0]=="function")return n[0](e);let[t,i]=n,r=typeof i=="function"?i():i;e.field(t,r)}})}function nr(n){return k(Object.assign(Object.assign({},n),{name:"Subscription"}))}import{buildSchema as to,isObjectType as no,isScalarType as io,isSpecifiedScalarType as zn}from"/v135/graphql@16.8.1/denonext/graphql.mjs";function rr(n,e=!1,t=JSON){try{return new sn(n,e,t).print()}catch(i){return`Error Parsing SDL into Schema: ${i.stack}`}}var sn=class{constructor(e,t=!1,i=JSON){this.commonjs=t,this.json=i,this.usedImports=new Set,this.exports=new Set,this.export=t===null||t?"const ":"export const ",this.schema=to(e),this.groupedTypes=Ae(this.schema)}print(){let e=[this.printObjectTypes(),this.printInterfaceTypes(),this.printInputObjectTypes(),this.printUnionTypes(),this.printEnumTypes(),this.printScalarTypes(),this.printExports()];return[this.printUsedImports()].concat(e).filter(t=>t).join(`

`)}printUsedImports(){return this.commonjs?`const { ${Array.from(this.usedImports).join(", ")} } = require('nexus');`:`import { ${Array.from(this.usedImports).join(", ")} } from 'nexus';`}printObjectTypes(){return this.groupedTypes.object.length>0?(this.usedImports.add("objectType"),this.groupedTypes.object.map(e=>this.printObjectType(e)).join(`
`)):""}printObjectType(e){let t=e.getInterfaces().map(r=>r.name),i=t.length>0?`    t.implements(${t.join(", ")})`:"";return this.exports.add(e.name),this.printBlock([`${this.export}${e.name} = objectType({`,`  name: "${e.name}",`,this.maybeDescription(e),"  definition(t) {",i,this.printObjectFields(e),"  }","})"])}printObjectFields(e){return ce(e.getFields()).map(t=>{if(!(no(e)&&un(e,t.name)))return this.printField("output",t)}).filter(t=>t).join(`
`)}printInputObjectFields(e){return ce(e.getFields()).map(t=>this.printField("input",t)).filter(t=>t).join(`
`)}printField(e,t){let{namedType:i,wrapping:r}=X(t.type),s="t.",o;return[...r].reverse().forEach(a=>{a==="List"?s+="list.":s+="nonNull."}),`    ${s}${this.printFieldMethod(e,t,i,o)}`}printFieldMethod(e,t,i,r){let s={},o="";if(ir(i)&&!r?o+=`${i.name.toLowerCase()}("${t.name}"`:(s.type=r??i,o+=`field("${t.name}"`),"deprecationReason"in t&&t.deprecationReason&&(s.deprecation=t.deprecationReason),t.description&&(s.description=t.description),e==="output"){let p=t;p.args.length&&(s.args=p.args)}else{let p=t;p.defaultValue!==void 0&&(s.default=p.defaultValue)}let a=Object.keys(s);if(a.length>0)if(a.length===1&&!s.args){let p=a[0];o+=`, { ${p}: ${this.printMeta(s[p],p)} }`}else o+=`, {
`,O(s,(p,u)=>{o+=`      ${u}: ${this.printMeta(p,u)},
`}),o+="    }";return`${o})`}printMeta(e,t){if(t==="type")return e;if(t==="args"){let i=`{
`;return e.forEach(r=>{i+=`        ${r.name}: ${this.printArg(r)},
`}),i+="      }",i}return this.json.stringify(e)}printArg(e){let t=e.description,i=e.defaultValue,{namedType:r,wrapping:s}=X(e.type),o=!zn(r),a="";o?(this.usedImports.add("arg"),a+="arg("):(this.usedImports.add(`${r.toString().toLowerCase()}Arg`),a+=`${r.toString().toLowerCase()}Arg(`);let p=[],u=r.name;return o&&p.push(`type: ${this.addWrapping(u,s)}`),t&&p.push(`description: ${JSON.stringify(t)}`),i&&p.push(`default: ${JSON.stringify(i)}`),a+=p.length>1?`{
          ${p.join(`,
          `)}
        })`:p.length?`{ ${p[0]} })`:")",o?a:this.addWrapping(a,s)}addWrapping(e,t){let i=e;return t.forEach(r=>{r==="NonNull"?(this.usedImports.add("nonNull"),i=`nonNull(${i})`):r==="List"&&(this.usedImports.add("list"),i=`list(${i})`)}),i}printInterfaceTypes(){return this.groupedTypes.interface.length?(this.usedImports.add("interfaceType"),this.groupedTypes.interface.map(e=>this.printInterfaceType(e)).join(`
`)):""}printInterfaceType(e){let t=typeof e.getInterfaces=="function"?e.getInterfaces().map(r=>r.name):[],i=t.length>0?`    t.implements(${t.join(", ")})`:"";return this.exports.add(e.name),this.printBlock([`${this.export}${e.name} = interfaceType({`,`  name: "${e.name}",`,this.maybeDescription(e),"  definition(t) {",i,this.printObjectFields(e),"  }","});"])}printEnumTypes(){return this.groupedTypes.enum.length?(this.usedImports.add("enumType"),this.groupedTypes.enum.map(e=>this.printEnumType(e)).join(`
`)):""}printEnumType(e){let t=e.getValues().map(i=>{let{description:r,name:s,deprecationReason:o,value:a}=i;return!r&&!o&&s===a?i.name:{description:r,name:s,deprecation:o,value:a}});return this.exports.add(e.name),this.printBlock([`${this.export}${e.name} = enumType({`,`  name: "${e.name}",`,this.maybeDescription(e),`  members: ${this.json.stringify(t)},`,"});"])}printInputObjectTypes(){return this.groupedTypes.input.length?(this.usedImports.add("inputObjectType"),this.groupedTypes.input.map(e=>this.printInputObjectType(e)).join(`
`)):""}printInputObjectType(e){return this.exports.add(e.name),this.printBlock([`${this.export}${e.name} = inputObjectType({`,`  name: "${e.name}",`,this.maybeDescription(e),"  definition(t) {",this.printInputObjectFields(e),"  }","});"])}printUnionTypes(){return this.groupedTypes.union.length?(this.usedImports.add("unionType"),this.groupedTypes.union.map(e=>this.printUnionType(e)).join(`
`)):""}printUnionType(e){return this.exports.add(e.name),this.printBlock([`${this.export}${e.name} = unionType({`,`  name: "${e.name}",`,this.maybeDescription(e),"  definition(t) {",`    t.members(${e.getTypes().join(", ")})`,"  }","});"])}printScalarTypes(){return this.groupedTypes.scalar.length?(this.usedImports.add("scalarType"),this.groupedTypes.scalar.filter(e=>!zn(e)).map(e=>this.printScalarType(e)).join(`
`)):""}printScalarType(e){return this.exports.add(e.name),this.printBlock([`${this.export}${e.name} = scalarType({`,`  name: "${e.name}",`,this.maybeDescription(e),this.maybeAsNexusType(e),"  serialize() { /* Todo */ },","  parseValue() { /* Todo */ },","  parseLiteral() { /* Todo */ }","});"])}printExports(){if(!this.commonjs||this.exports.size===0)return"";let e=Array.from(this.exports);return this.printBlock(e.map(t=>`exports.${t} = ${t};`))}maybeAsNexusType(e){return ir(e)?`  asNexusMethod: "${e.name.toLowerCase()}",`:null}maybeDescription(e){return e.description?`  description: ${this.json.stringify(e.description)},`:null}printBlock(e){return e.filter(t=>t!==null&&t!=="").join(`
`)}};function ir(n){return io(n)?n.name==="UUID"||n.name==="Date"||zn(n):!1}var on=class{constructor(e,t){this.name=e,this.config=t}get value(){return this.config}};N(on,d.DynamicOutputProperty);function ro(n){return new on(n.name,n)}export{A as arg,xi as asNexusMethod,Qn as blocks,ti as booleanArg,K as connectionPlugin,Fn as connectionPluginCore,rr as convertSDL,sr as core,ii as createPlugin,Kt as declarativeWrappingPlugin,$e as decorateType,ri as dynamicInputMethod,Qt as dynamicOutputMethod,ro as dynamicOutputProperty,Zt as enumType,Ji as extendInputType,he as extendType,ke as fieldAuthorizePlugin,$n as fieldAuthorizePluginCore,Zn as floatArg,Ae as groupTypes,ei as idArg,en as inputObjectType,xe as intArg,vt as interfaceType,fe as list,Hi as makeSchema,Xi as mutationField,Ki as mutationType,B as nonNull,Mn as nullabilityGuardPlugin,An as nullabilityGuardPluginCore,q as nullable,k as objectType,P as plugin,Pn as queryComplexityPlugin,_n as queryComplexityPluginCore,Zi as queryField,er as queryType,tn as scalarType,it as stringArg,tr as subscriptionField,nr as subscriptionType,Ot as unionType};
//# sourceMappingURL=nexus.mjs.map