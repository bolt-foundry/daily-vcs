/* esm.sh - esbuild bundle(graphql-ws@5.14.0/lib/server) denonext production */
import{parse as X,validate as Y,execute as Z,subscribe as k,getOperationAST as ee,GraphQLError as ne}from"/v135/graphql@16.8.1/denonext/graphql.mjs";import{GRAPHQL_TRANSPORT_WS_PROTOCOL as P,CloseCode as m,MessageType as c,stringifyMessage as E,parseMessage as ie}from"/v135/graphql-ws@5.14.0/denonext/lib/common.js";import{isObject as D,isAsyncGenerator as U,isAsyncIterable as te,areGraphQLErrors as ae}from"/v135/graphql-ws@5.14.0/denonext/lib/utils.js";var K=function(a){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var d=a[Symbol.asyncIterator],f;return d?d.call(a):(a=typeof __values=="function"?__values(a):a[Symbol.iterator](),f={},y("next"),y("throw"),y("return"),f[Symbol.asyncIterator]=function(){return this},f);function y(p){f[p]=a[p]&&function(u){return new Promise(function(b,v){u=a[p](u),A(b,v,u.done,u.value)})}}function A(p,u,b,v){Promise.resolve(v).then(function(I){p({value:I,done:b})},u)}};function ce(a){let{schema:d,context:f,roots:y,validate:A,execute:p,subscribe:u,connectionInitWaitTimeout:b=3e3,onConnect:v,onDisconnect:I,onClose:w,onSubscribe:C,onOperation:j,onNext:M,onError:R,onComplete:_,jsonMessageReviver:H,jsonMessageReplacer:T}=a;return{opened(t,J){let e={connectionInitReceived:!1,acknowledged:!1,subscriptions:{},extra:J};if(t.protocol!==P)return t.close(m.SubprotocolNotAcceptable,"Subprotocol not acceptable"),async(O,g)=>{await w?.(e,O,g)};let F=b>0&&isFinite(b)?setTimeout(()=>{e.connectionInitReceived||t.close(m.ConnectionInitialisationTimeout,"Connection initialisation timeout")},b):null;return t.onMessage(async function(g){var h,V,W,z,q;let r;try{r=ie(g,H)}catch{return t.close(m.BadRequest,"Invalid message received")}switch(r.type){case c.ConnectionInit:{if(e.connectionInitReceived)return t.close(m.TooManyInitialisationRequests,"Too many initialisation requests");e.connectionInitReceived=!0,D(r.payload)&&(e.connectionParams=r.payload);let i=await v?.(e);if(i===!1)return t.close(m.Forbidden,"Forbidden");await t.send(E(D(i)?{type:c.ConnectionAck,payload:i}:{type:c.ConnectionAck},T)),e.acknowledged=!0;return}case c.Ping:{if(t.onPing)return await t.onPing(r.payload);await t.send(E(r.payload?{type:c.Pong,payload:r.payload}:{type:c.Pong}));return}case c.Pong:return await((q=t.onPong)===null||q===void 0?void 0:q.call(t,r.payload));case c.Subscribe:{if(!e.acknowledged)return t.close(m.Unauthorized,"Unauthorized");let{id:i,payload:Q}=r;if(i in e.subscriptions)return t.close(m.SubscriberAlreadyExists,`Subscriber for ${i} already exists`);e.subscriptions[i]=null;let x={next:async(n,o)=>{let l={id:i,type:c.Next,payload:n},s=await M?.(e,l,o,n);s&&(l=Object.assign(Object.assign({},l),{payload:s})),await t.send(E(l,T))},error:async n=>{let o={id:i,type:c.Error,payload:n},l=await R?.(e,o,n);l&&(o=Object.assign(Object.assign({},o),{payload:l})),await t.send(E(o,T))},complete:async n=>{let o={id:i,type:c.Complete};await _?.(e,o),n&&await t.send(E(o,T))}};try{let n,o=await C?.(e,r);if(o){if(ae(o))return await x.error(o);if(Array.isArray(o))throw new Error("Invalid return value from onSubscribe hook, expected an array of GraphQLError objects");n=o}else{if(!d)throw new Error("The GraphQL schema is not provided");let S={operationName:Q.operationName,document:X(Q.query),variableValues:Q.variables};n=Object.assign(Object.assign({},S),{schema:typeof d=="function"?await d(e,r,S):d});let B=(A??Y)(n.schema,n.document);if(B.length>0)return await x.error(B)}let l=ee(n.document,n.operationName);if(!l)return await x.error([new ne("Unable to identify operation")]);"rootValue"in n||(n.rootValue=y?.[l.operation]),"contextValue"in n||(n.contextValue=typeof f=="function"?await f(e,r,n):f);let s;l.operation==="subscription"?s=await(u??k)(n):s=await(p??Z)(n);let $=await j?.(e,r,n,s);if($&&(s=$),te(s))if(!(i in e.subscriptions))U(s)&&s.return(void 0);else{e.subscriptions[i]=s;try{for(var N=!0,G=K(s),L;L=await G.next(),h=L.done,!h;N=!0){z=L.value,N=!1;let S=z;await x.next(S,n)}}catch(S){V={error:S}}finally{try{!N&&!h&&(W=G.return)&&await W.call(G)}finally{if(V)throw V.error}}}else i in e.subscriptions&&await x.next(s,n);await x.complete(i in e.subscriptions)}finally{delete e.subscriptions[i]}return}case c.Complete:{let i=e.subscriptions[r.id];delete e.subscriptions[r.id],U(i)&&await i.return(void 0);return}default:throw new Error(`Unexpected message of type ${r.type} received`)}}),async(O,g)=>{F&&clearTimeout(F);for(let h of Object.values(e.subscriptions))U(h)&&await h.return(void 0);e.acknowledged&&await I?.(e,O,g),await w?.(e,O,g)}}}}function le(a){switch(!0){case(a instanceof Set&&a.has(P)):case(Array.isArray(a)&&a.includes(P)):case(typeof a=="string"&&a.split(",").map(d=>d.trim()).includes(P)):return P;default:return!1}}export{le as handleProtocols,ce as makeServer};
//# sourceMappingURL=server.js.map