/* esm.sh - esbuild bundle(@noble/curves@1.4.0/abstract/hash-to-curve) denonext production */
import{mod as k}from"/v135/@noble/curves@1.4.0/denonext/abstract/modular.js";import{bytesToNumberBE as C,abytes as _,concatBytes as m,utf8ToBytes as g,validateObject as L}from"/v135/@noble/curves@1.4.0/denonext/abstract/utils.js";var v=C;function p(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);let n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function M(t,e){let n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function w(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function N(t,e,n,r){_(t),_(e),w(n),e.length>255&&(e=r(m(g("H2C-OVERSIZE-DST-"),e)));let{outputLen:o,blockLen:s}=r,a=Math.ceil(n/o);if(a>255)throw new Error("Invalid xmd length");let i=m(e,p(e.length,1)),c=p(0,s),l=p(n,2),u=new Array(a),d=r(m(c,t,l,p(0,1),i));u[0]=r(m(d,p(1,1),i));for(let f=1;f<=a;f++){let h=[M(d,u[f-1]),p(f+1,1),i];u[f]=r(m(...h))}return m(...u).slice(0,n)}function V(t,e,n,r,o){if(_(t),_(e),w(n),e.length>255){let s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update(g("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(p(n,2)).update(e).update(p(e.length,1)).digest()}function S(t,e,n){L(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:o,m:s,hash:a,expand:i,DST:c}=n;_(t),w(e);let l=typeof c=="string"?g(c):c,u=r.toString(2).length,d=Math.ceil((u+o)/8),y=e*s*d,f;if(i==="xmd")f=N(t,l,y,a);else if(i==="xof")f=V(t,l,y,o,a);else if(i==="_internal_pass")f=t;else throw new Error('expand must be "xmd" or "xof"');let h=new Array(e);for(let b=0;b<e;b++){let E=new Array(s);for(let x=0;x<s;x++){let A=d*(x+b*s),O=f.subarray(A,A+d);E[x]=k(v(O),r)}h[b]=E}return h}function j(t,e){let n=e.map(r=>Array.from(r).reverse());return(r,o)=>{let[s,a,i,c]=n.map(l=>l.reduce((u,d)=>t.add(t.mul(u,r),d)));return r=t.div(s,a),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}function D(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){let s=S(r,2,{...n,DST:n.DST,...o}),a=t.fromAffine(e(s[0])),i=t.fromAffine(e(s[1])),c=a.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){let s=S(r,1,{...n,DST:n.encodeDST,...o}),a=t.fromAffine(e(s[0])).clearCofactor();return a.assertValidity(),a}}}export{D as createHasher,N as expand_message_xmd,V as expand_message_xof,S as hash_to_field,j as isogenyMap};
//# sourceMappingURL=hash-to-curve.js.map