/* esm.sh - esbuild bundle(@noble/curves@1.4.0/abstract/utils) denonext production */
var m=BigInt(0),g=BigInt(1),_=BigInt(2);function d(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function w(t){if(!d(t))throw new Error("Uint8Array expected")}var U=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function E(t){w(t);let e="";for(let o=0;o<t.length;o++)e+=U[t[o]];return e}function $(t){let e=t.toString(16);return e.length&1?`0${e}`:e}function A(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}var c={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function b(t){if(t>=c._0&&t<=c._9)return t-c._0;if(t>=c._A&&t<=c._F)return t-(c._A-10);if(t>=c._a&&t<=c._f)return t-(c._a-10)}function x(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);let e=t.length,o=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(o);for(let r=0,i=0;r<o;r++,i+=2){let l=b(t.charCodeAt(i)),f=b(t.charCodeAt(i+1));if(l===void 0||f===void 0){let s=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}n[r]=l*16+f}return n}function N(t){return A(E(t))}function F(t){return w(t),A(E(Uint8Array.from(t).reverse()))}function T(t,e){return x(t.toString(16).padStart(e*2,"0"))}function k(t,e){return T(t,e).reverse()}function O(t){return x($(t))}function C(t,e,o){let n;if(typeof e=="string")try{n=x(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(d(e))n=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);let r=n.length;if(typeof o=="number"&&r!==o)throw new Error(`${t} expected ${o} bytes, got ${r}`);return n}function I(...t){let e=0;for(let n=0;n<t.length;n++){let r=t[n];w(r),e+=r.length}let o=new Uint8Array(e);for(let n=0,r=0;n<t.length;n++){let i=t[n];o.set(i,r),r+=i.length}return o}function H(t,e){if(t.length!==e.length)return!1;let o=0;for(let n=0;n<t.length;n++)o|=t[n]^e[n];return o===0}function V(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function j(t){let e;for(e=0;t>m;t>>=g,e+=1);return e}function D(t,e){return t>>BigInt(e)&g}function G(t,e,o){return t|(o?g:m)<<BigInt(e)}var M=t=>(_<<BigInt(t-1))-g,y=t=>new Uint8Array(t),h=t=>Uint8Array.from(t);function q(t,e,o){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");let n=y(t),r=y(t),i=0,l=()=>{n.fill(1),r.fill(0),i=0},f=(...u)=>o(r,n,...u),s=(u=y())=>{r=f(h([0]),u),n=f(),u.length!==0&&(r=f(h([1]),u),n=f())},B=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,a=[];for(;u<e;){n=f();let p=n.slice();a.push(p),u+=n.length}return I(...a)};return(u,a)=>{l(),s(u);let p;for(;!(p=a(B()));)s();return l(),p}}var S={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||d(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function z(t,e,o={}){let n=(r,i,l)=>{let f=S[i];if(typeof f!="function")throw new Error(`Invalid validator "${i}", expected function`);let s=t[r];if(!(l&&s===void 0)&&!f(s,t))throw new Error(`Invalid param ${String(r)}=${s} (${typeof s}), expected ${i}`)};for(let[r,i]of Object.entries(e))n(r,i,!1);for(let[r,i]of Object.entries(o))n(r,i,!0);return t}export{w as abytes,D as bitGet,j as bitLen,M as bitMask,G as bitSet,E as bytesToHex,N as bytesToNumberBE,F as bytesToNumberLE,I as concatBytes,q as createHmacDrbg,C as ensureBytes,H as equalBytes,x as hexToBytes,A as hexToNumber,d as isBytes,T as numberToBytesBE,k as numberToBytesLE,$ as numberToHexUnpadded,O as numberToVarBytesBE,V as utf8ToBytes,z as validateObject};
/*! Bundled license information:

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=utils.js.map