/* esm.sh - esbuild bundle(@noble/curves@1.4.0/abstract/modular) denonext production */
import{bitMask as T,numberToBytesBE as m,numberToBytesLE as y,bytesToNumberBE as b,bytesToNumberLE as p,ensureBytes as _,validateObject as $}from"/v135/@noble/curves@1.4.0/denonext/abstract/utils.js";var f=BigInt(0),u=BigInt(1),w=BigInt(2),M=BigInt(3),x=BigInt(4),S=BigInt(5),I=BigInt(8),C=BigInt(9),Z=BigInt(16);function g(t,r){let e=t%r;return e>=f?e:r+e}function j(t,r,e){if(e<=f||r<f)throw new Error("Expected power/modulo > 0");if(e===u)return f;let o=u;for(;r>f;)r&u&&(o=o*t%e),t=t*t%e,r>>=u;return o}function k(t,r,e){let o=t;for(;r-- >f;)o*=o,o%=e;return o}function B(t,r){if(t===f||r<=f)throw new Error(`invert: expected positive integers, got n=${t} mod=${r}`);let e=g(t,r),o=r,s=f,l=u,d=u,i=f;for(;e!==f;){let c=o/e,a=o%e,q=s-d*c,h=l-i*c;o=e,e=a,s=d,l=i,d=q,i=h}if(o!==u)throw new Error("invert: does not exist");return g(s,r)}function A(t){let r=(t-u)/w,e,o,s;for(e=t-u,o=0;e%w===f;e/=w,o++);for(s=w;s<t&&j(s,r,t)!==t-u;s++);if(o===1){let d=(t+u)/x;return function(n,c){let a=n.pow(c,d);if(!n.eql(n.sqr(a),c))throw new Error("Cannot find square root");return a}}let l=(e+u)/w;return function(i,n){if(i.pow(n,r)===i.neg(i.ONE))throw new Error("Cannot find square root");let c=o,a=i.pow(i.mul(i.ONE,s),e),q=i.pow(n,l),h=i.pow(n,e);for(;!i.eql(h,i.ONE);){if(i.eql(h,i.ZERO))return i.ZERO;let v=1;for(let E=i.sqr(h);v<c&&!i.eql(E,i.ONE);v++)E=i.sqr(E);let N=i.pow(a,u<<BigInt(c-v-1));a=i.sqr(N),q=i.mul(q,N),h=i.mul(h,a),c=v}return q}}function H(t){if(t%x===M){let r=(t+u)/x;return function(o,s){let l=o.pow(s,r);if(!o.eql(o.sqr(l),s))throw new Error("Cannot find square root");return l}}if(t%I===S){let r=(t-S)/I;return function(o,s){let l=o.mul(s,w),d=o.pow(l,r),i=o.mul(s,d),n=o.mul(o.mul(i,w),d),c=o.mul(i,o.sub(n,o.ONE));if(!o.eql(o.sqr(c),s))throw new Error("Cannot find square root");return c}}return t%Z,A(t)}var G=(t,r)=>(g(t,r)&u)===u,z=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function J(t){let r={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=z.reduce((o,s)=>(o[s]="function",o),r);return $(t,e)}function K(t,r,e){if(e<f)throw new Error("Expected power > 0");if(e===f)return t.ONE;if(e===u)return r;let o=t.ONE,s=r;for(;e>f;)e&u&&(o=t.mul(o,s)),s=t.sqr(s),e>>=u;return o}function Q(t,r){let e=new Array(r.length),o=r.reduce((l,d,i)=>t.is0(d)?l:(e[i]=l,t.mul(l,d)),t.ONE),s=t.inv(o);return r.reduceRight((l,d,i)=>t.is0(d)?l:(e[i]=t.mul(l,e[i]),t.mul(l,d)),s),e}function U(t,r,e){return t.mul(r,typeof e=="bigint"?B(e,t.ORDER):t.inv(e))}function W(t){let r=(t.ORDER-u)/w;return e=>{let o=t.pow(e,r);return t.eql(o,t.ZERO)||t.eql(o,t.ONE)}}function L(t,r){let e=r!==void 0?r:t.toString(2).length,o=Math.ceil(e/8);return{nBitLength:e,nByteLength:o}}function X(t,r,e=!1,o={}){if(t<=f)throw new Error(`Expected Field ORDER > 0, got ${t}`);let{nBitLength:s,nByteLength:l}=L(t,r);if(l>2048)throw new Error("Field lengths over 2048 bytes are not supported");let d=H(t),i=Object.freeze({ORDER:t,BITS:s,BYTES:l,MASK:T(s),ZERO:f,ONE:u,create:n=>g(n,t),isValid:n=>{if(typeof n!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof n}`);return f<=n&&n<t},is0:n=>n===f,isOdd:n=>(n&u)===u,neg:n=>g(-n,t),eql:(n,c)=>n===c,sqr:n=>g(n*n,t),add:(n,c)=>g(n+c,t),sub:(n,c)=>g(n-c,t),mul:(n,c)=>g(n*c,t),pow:(n,c)=>K(i,n,c),div:(n,c)=>g(n*B(c,t),t),sqrN:n=>n*n,addN:(n,c)=>n+c,subN:(n,c)=>n-c,mulN:(n,c)=>n*c,inv:n=>B(n,t),sqrt:o.sqrt||(n=>d(i,n)),invertBatch:n=>Q(i,n),cmov:(n,c,a)=>a?c:n,toBytes:n=>e?y(n,l):m(n,l),fromBytes:n=>{if(n.length!==l)throw new Error(`Fp.fromBytes: expected ${l}, got ${n.length}`);return e?p(n):b(n)}});return Object.freeze(i)}function P(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");let e=t.sqrt(r);return t.isOdd(e)?e:t.neg(e)}function D(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");let e=t.sqrt(r);return t.isOdd(e)?t.neg(e):e}function R(t,r,e=!1){t=_("privateHash",t);let o=t.length,s=L(r).nByteLength+8;if(s<24||o<s||o>1024)throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${o}`);let l=e?p(t):b(t);return g(l,r-u)+u}function O(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let r=t.toString(2).length;return Math.ceil(r/8)}function V(t){let r=O(t);return r+Math.ceil(r/2)}function F(t,r,e=!1){let o=t.length,s=O(r),l=V(r);if(o<16||o<l||o>1024)throw new Error(`expected ${l}-1024 bytes of input, got ${o}`);let d=e?b(t):p(t),i=g(d,r-u)+u;return e?y(i,s):m(i,s)}export{X as Field,U as FpDiv,Q as FpInvertBatch,W as FpIsSquare,K as FpPow,H as FpSqrt,D as FpSqrtEven,P as FpSqrtOdd,O as getFieldBytesLength,V as getMinHashLength,R as hashToPrivateScalar,B as invert,G as isNegativeLE,F as mapHashToField,g as mod,L as nLength,j as pow,k as pow2,A as tonelliShanks,J as validateField};
/*! Bundled license information:

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=modular.js.map