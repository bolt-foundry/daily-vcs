/* esm.sh - esbuild bundle(langsmith@0.1.40) denonext production */
import __Process$ from "node:process";
import*as M from"/v135/uuid@9.0.1/denonext/uuid.mjs";import se from"/v135/p-retry@4.6.2/denonext/p-retry.mjs";import U from"/v135/p-queue@6.6.2/denonext/p-queue.mjs";var ae=[400,401,403,404,405,406,407,408],ne=[409],P=class{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"onFailedResponseHook",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6,"default"in U?this.queue=new U.default({concurrency:this.maxConcurrency}):this.queue=new U({concurrency:this.maxConcurrency}),this.onFailedResponseHook=e?.onFailedResponseHook}call(e,...t){let i=this.onFailedResponseHook;return this.queue.add(()=>se(()=>e(...t).catch(r=>{throw r instanceof Error?r:new Error(r)}),{async onFailedAttempt(r){if(r.message.startsWith("Cancel")||r.message.startsWith("TimeoutError")||r.message.startsWith("AbortError")||r?.code==="ECONNABORTED")throw r;let s=r?.response,a=s?.status;if(a){if(ae.includes(+a))throw r;if(ne.includes(+a))return;i&&await i(s)}},retries:this.maxRetries,randomize:!0}),{throwOnTimeout:!0})}callWithOptions(e,t,...i){return e.signal?Promise.race([this.call(t,...i),new Promise((r,s)=>{e.signal?.addEventListener("abort",()=>{s(new Error("AbortError"))})})]):this.call(t,...i)}fetch(...e){return this.call(()=>fetch(...e).then(t=>t.ok?t:Promise.reject(t)))}};function k(o){return typeof o?._getType=="function"}function x(o){let e={type:o._getType(),data:{content:o.content}};return o?.additional_kwargs&&Object.keys(o.additional_kwargs).length>0&&(e.data.additional_kwargs={...o.additional_kwargs}),e}var v,oe=()=>typeof window<"u"&&typeof window.document<"u",ue=()=>typeof globalThis=="object"&&globalThis.constructor&&globalThis.constructor.name==="DedicatedWorkerGlobalScope",de=()=>typeof window<"u"&&window.name==="nodejs"||typeof navigator<"u"&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom")),V=()=>typeof Deno<"u",le=()=>typeof __Process$<"u"&&typeof __Process$.versions<"u"&&typeof __Process$.versions.node<"u"&&!V(),ce=()=>v||(oe()?v="browser":le()?v="node":ue()?v="webworker":de()?v="jsdom":V()?v="deno":v="other",v),N;async function C(){if(N===void 0){let o=ce(),e=pe();N={library:"langsmith",runtime:o,sdk:"langsmith-js",sdk_version:j,...e}}return N}function z(){let o=he()||{},e={},t=["LANGCHAIN_API_KEY","LANGCHAIN_ENDPOINT","LANGCHAIN_TRACING_V2","LANGCHAIN_PROJECT","LANGCHAIN_SESSION"];for(let[i,r]of Object.entries(o))i.startsWith("LANGCHAIN_")&&typeof r=="string"&&!t.includes(i)&&!i.toLowerCase().includes("key")&&!i.toLowerCase().includes("secret")&&!i.toLowerCase().includes("token")&&(i==="LANGCHAIN_REVISION_ID"?e.revision_id=r:e[i]=r);return e}function he(){try{return typeof __Process$<"u"&&__Process$.env?Object.entries(__Process$.env).reduce((o,[e,t])=>(o[e]=String(t),o),{}):void 0}catch{return}}function _(o){try{return typeof __Process$<"u"?__Process$.env?.[o]:void 0}catch{return}}var L;function pe(){if(L!==void 0)return L;let o=["VERCEL_GIT_COMMIT_SHA","NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA","COMMIT_REF","RENDER_GIT_COMMIT","CI_COMMIT_SHA","CIRCLE_SHA1","CF_PAGES_COMMIT_SHA","REACT_APP_GIT_SHA","SOURCE_VERSION","GITHUB_SHA","TRAVIS_COMMIT","GIT_COMMIT","BUILD_VCS_NUMBER","bamboo_planRepository_revision","Build.SourceVersion","BITBUCKET_COMMIT","DRONE_COMMIT_SHA","SEMAPHORE_GIT_SHA","BUILDKITE_COMMIT"],e={};for(let t of o){let i=_(t);i!==void 0&&(e[t]=i)}return L=e,e}import*as q from"/v135/uuid@9.0.1/denonext/uuid.mjs";function p(o){if(!q.validate(o))throw new Error(`Invalid UUID: ${o}`)}var W={};function A(o){W[o]||(console.warn(o),W[o]=!0)}import{parse as K}from"/v135/semver@7.6.3/denonext/semver.mjs";function Q(o,e){let t=K(o),i=K(e);if(!t||!i)throw new Error("Invalid version format.");return t.compare(i)>=0}function O(o){if(!o||o.split("/").length>2||o.startsWith("/")||o.endsWith("/")||o.split(":").length>2)throw new Error(`Invalid identifier format: ${o}`);let[e,t]=o.split(":"),i=t||"latest";if(e.includes("/")){let[r,s]=e.split("/",2);if(!r||!s)throw new Error(`Invalid identifier format: ${o}`);return[r,s,i]}else{if(!e)throw new Error(`Invalid identifier format: ${o}`);return["-",e,i]}}async function Y(o){let e=await C(),t=z();return o.map(i=>{let r=i.extra??{},s=r.metadata;return i.extra={...r,runtime:{...e,...r?.runtime},metadata:{...t,...t.revision_id||i.revision_id?{revision_id:i.revision_id??t.revision_id}:{},...s}},i})}var fe=()=>{let o=_("LANGCHAIN_TRACING_SAMPLING_RATE");if(o===void 0)return;let e=parseFloat(o);if(e<0||e>1)throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${e}`);return e},me=o=>{let t=o.replace("http://","").replace("https://","").split("/")[0].split(":")[0];return t==="localhost"||t==="127.0.0.1"||t==="::1"},E=async(o,e)=>{let t=await o.text();if(!o.ok)throw new Error(`Failed to ${e}: ${o.status} ${o.statusText} ${t}`)};async function _e(o){let e=[];for await(let t of o)e.push(t);return e}function H(o){if(o!==void 0)return o.trim().replace(/^"(.*)"$/,"$1").replace(/^'(.*)'$/,"$1")}var we=async o=>{if(o?.status===429){let e=parseInt(o.headers.get("retry-after")??"30",10)*1e3;if(e>0)return await new Promise(t=>setTimeout(t,e)),!0}return!1},D=class{constructor(){Object.defineProperty(this,"items",{enumerable:!0,configurable:!0,writable:!0,value:[]})}get size(){return this.items.length}push(e){return new Promise(t=>{this.items.push([e,t])})}pop(e){if(e<1)throw new Error("Number of items to pop off may not be less than 1.");let t=[];for(;t.length<e&&this.items.length;){let i=this.items.shift();if(i)t.push(i);else break}return[t.map(i=>i[0]),()=>t.forEach(i=>i[1]())]}},ge=20971520,T=class o{constructor(e={}){Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"webUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"batchIngestCaller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"timeout_ms",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_tenantId",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"hideInputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hideOutputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tracingSampleRate",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sampledPostUuids",{enumerable:!0,configurable:!0,writable:!0,value:new Set}),Object.defineProperty(this,"autoBatchTracing",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"batchEndpointSupported",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoBatchQueue",{enumerable:!0,configurable:!0,writable:!0,value:new D}),Object.defineProperty(this,"pendingAutoBatchedRunLimit",{enumerable:!0,configurable:!0,writable:!0,value:100}),Object.defineProperty(this,"autoBatchTimeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoBatchInitialDelayMs",{enumerable:!0,configurable:!0,writable:!0,value:250}),Object.defineProperty(this,"autoBatchAggregationDelayMs",{enumerable:!0,configurable:!0,writable:!0,value:50}),Object.defineProperty(this,"serverInfo",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fetchOptions",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"settings",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=o.getDefaultClientConfig();this.tracingSampleRate=fe(),this.apiUrl=H(e.apiUrl??t.apiUrl)??"",this.apiKey=H(e.apiKey??t.apiKey),this.webUrl=H(e.webUrl??t.webUrl),this.timeout_ms=e.timeout_ms??12e3,this.caller=new P(e.callerOptions??{}),this.batchIngestCaller=new P({...e.callerOptions??{},onFailedResponseHook:we}),this.hideInputs=e.hideInputs??e.anonymizer??t.hideInputs,this.hideOutputs=e.hideOutputs??e.anonymizer??t.hideOutputs,this.autoBatchTracing=e.autoBatchTracing??this.autoBatchTracing,this.pendingAutoBatchedRunLimit=e.pendingAutoBatchedRunLimit??this.pendingAutoBatchedRunLimit,this.fetchOptions=e.fetchOptions||{}}static getDefaultClientConfig(){let e=_("LANGCHAIN_API_KEY"),t=_("LANGCHAIN_ENDPOINT")??"https://api.smith.langchain.com",i=_("LANGCHAIN_HIDE_INPUTS")==="true",r=_("LANGCHAIN_HIDE_OUTPUTS")==="true";return{apiUrl:t,apiKey:e,webUrl:void 0,hideInputs:i,hideOutputs:r}}getHostUrl(){return this.webUrl?this.webUrl:me(this.apiUrl)?(this.webUrl="http://localhost:3000",this.webUrl):this.apiUrl.includes("/api")&&!this.apiUrl.split(".",1)[0].endsWith("api")?(this.webUrl=this.apiUrl.replace("/api",""),this.webUrl):this.apiUrl.split(".",1)[0].includes("dev")?(this.webUrl="https://dev.smith.langchain.com",this.webUrl):this.apiUrl.split(".",1)[0].includes("eu")?(this.webUrl="https://eu.smith.langchain.com",this.webUrl):(this.webUrl="https://smith.langchain.com",this.webUrl)}get headers(){let e={"User-Agent":`langsmith-js/${j}`};return this.apiKey&&(e["x-api-key"]=`${this.apiKey}`),e}processInputs(e){return this.hideInputs===!1?e:this.hideInputs===!0?{}:typeof this.hideInputs=="function"?this.hideInputs(e):e}processOutputs(e){return this.hideOutputs===!1?e:this.hideOutputs===!0?{}:typeof this.hideOutputs=="function"?this.hideOutputs(e):e}prepareRunCreateOrUpdateInputs(e){let t={...e};return t.inputs!==void 0&&(t.inputs=this.processInputs(t.inputs)),t.outputs!==void 0&&(t.outputs=this.processOutputs(t.outputs)),t}async _getResponse(e,t){let i=t?.toString()??"",r=`${this.apiUrl}${e}?${i}`,s=await this.caller.call(fetch,r,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!s.ok)throw new Error(`Failed to fetch ${e}: ${s.status} ${s.statusText}`);return s}async _get(e,t){return(await this._getResponse(e,t)).json()}async*_getPaginated(e,t=new URLSearchParams,i){let r=Number(t.get("offset"))||0,s=Number(t.get("limit"))||100;for(;;){t.set("offset",String(r)),t.set("limit",String(s));let a=`${this.apiUrl}${e}?${t}`,n=await this.caller.call(fetch,a,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!n.ok)throw new Error(`Failed to fetch ${e}: ${n.status} ${n.statusText}`);let u=i?i(await n.json()):await n.json();if(u.length===0||(yield u,u.length<s))break;r+=u.length}}async*_getCursorPaginatedList(e,t=null,i="POST",r="runs"){let s=t?{...t}:{};for(;;){let n=await(await this.caller.call(fetch,`${this.apiUrl}${e}`,{method:i,headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:JSON.stringify(s)})).json();if(!n||!n[r])break;yield n[r];let u=n.cursors;if(!u||!u.next)break;s.cursor=u.next}}_filterForSampling(e,t=!1){if(this.tracingSampleRate===void 0)return e;if(t){let i=[];for(let r of e)this.sampledPostUuids.has(r.id)&&(i.push(r),this.sampledPostUuids.delete(r.id));return i}else{let i=[];for(let r of e)Math.random()<this.tracingSampleRate&&(i.push(r),this.sampledPostUuids.add(r.id));return i}}async drainAutoBatchQueue(){for(;this.autoBatchQueue.size>=0;){let[e,t]=this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);if(!e.length){t();return}try{await this.batchIngestRuns({runCreates:e.filter(i=>i.action==="create").map(i=>i.item),runUpdates:e.filter(i=>i.action==="update").map(i=>i.item)})}finally{t()}}}async processRunOperation(e,t){let i=this.autoBatchTimeout;clearTimeout(this.autoBatchTimeout),this.autoBatchTimeout=void 0;let r=this.autoBatchQueue.push(e);return(t||this.autoBatchQueue.size>this.pendingAutoBatchedRunLimit)&&await this.drainAutoBatchQueue(),this.autoBatchQueue.size>0&&(this.autoBatchTimeout=setTimeout(()=>{this.autoBatchTimeout=void 0,this.drainAutoBatchQueue().catch(console.error)},i?this.autoBatchAggregationDelayMs:this.autoBatchInitialDelayMs)),r}async _getServerInfo(){let e=await fetch(`${this.apiUrl}/info`,{method:"GET",headers:{Accept:"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!e.ok)throw await e.text(),new Error("Failed to retrieve server info.");return e.json()}async batchEndpointIsSupported(){try{this.serverInfo=await this._getServerInfo()}catch{return!1}return!0}async _getSettings(){return this.settings||(this.settings=this._get("/settings")),await this.settings}async createRun(e){if(!this._filterForSampling([e]).length)return;let t={...this.headers,"Content-Type":"application/json"},i=e.project_name;delete e.project_name;let r=this.prepareRunCreateOrUpdateInputs({session_name:i,...e,start_time:e.start_time??Date.now()});if(this.autoBatchTracing&&r.trace_id!==void 0&&r.dotted_order!==void 0){this.processRunOperation({action:"create",item:r}).catch(console.error);return}let s=await Y([r]),a=await this.caller.call(fetch,`${this.apiUrl}/runs`,{method:"POST",headers:t,body:JSON.stringify(s[0]),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(a,"create run")}async batchIngestRuns({runCreates:e,runUpdates:t}){if(e===void 0&&t===void 0)return;let i=e?.map(d=>this.prepareRunCreateOrUpdateInputs(d))??[],r=t?.map(d=>this.prepareRunCreateOrUpdateInputs(d))??[];if(i.length>0&&r.length>0){let d=i.reduce((c,h)=>(h.id&&(c[h.id]=h),c),{}),l=[];for(let c of r)c.id!==void 0&&d[c.id]?d[c.id]={...d[c.id],...c}:l.push(c);i=Object.values(d),r=l}let s={post:this._filterForSampling(i),patch:this._filterForSampling(r,!0)};if(!s.post.length&&!s.patch.length)return;if(i=await Y(i),this.batchEndpointSupported===void 0&&(this.batchEndpointSupported=await this.batchEndpointIsSupported()),!this.batchEndpointSupported){this.autoBatchTracing=!1;for(let d of s.post)await this.createRun(d);for(let d of s.patch)d.id!==void 0&&await this.updateRun(d.id,d);return}let a=this.serverInfo?.batch_ingest_config?.size_limit_bytes??ge,n={post:[],patch:[]},u=0;for(let d of["post","patch"]){let l=d,c=s[l].reverse(),h=c.pop();for(;h!==void 0;){let m=JSON.stringify(h);u>0&&u+m.length>a&&(await this._postBatchIngestRuns(JSON.stringify(n)),u=0,n.post=[],n.patch=[]),u+=m.length,n[l].push(h),h=c.pop()}}(n.post.length>0||n.patch.length>0)&&await this._postBatchIngestRuns(JSON.stringify(n))}async _postBatchIngestRuns(e){let t={...this.headers,"Content-Type":"application/json",Accept:"application/json"},i=await this.batchIngestCaller.call(fetch,`${this.apiUrl}/runs/batch`,{method:"POST",headers:t,body:e,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(i,"batch create run")}async updateRun(e,t){p(e),t.inputs&&(t.inputs=this.processInputs(t.inputs)),t.outputs&&(t.outputs=this.processOutputs(t.outputs));let i={...t,id:e};if(!this._filterForSampling([i],!0).length)return;if(this.autoBatchTracing&&i.trace_id!==void 0&&i.dotted_order!==void 0){if(t.end_time!==void 0&&i.parent_run_id===void 0){await this.processRunOperation({action:"update",item:i},!0);return}else this.processRunOperation({action:"update",item:i}).catch(console.error);return}let r={...this.headers,"Content-Type":"application/json"},s=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}`,{method:"PATCH",headers:r,body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(s,"update run")}async readRun(e,{loadChildRuns:t}={loadChildRuns:!1}){p(e);let i=await this._get(`/runs/${e}`);return t&&i.child_run_ids&&(i=await this._loadChildRuns(i)),i}async getRunUrl({runId:e,run:t,projectOpts:i}){if(t!==void 0){let r;t.session_id?r=t.session_id:i?.projectName?r=(await this.readProject({projectName:i?.projectName})).id:i?.projectId?r=i?.projectId:r=(await this.readProject({projectName:_("LANGCHAIN_PROJECT")||"default"})).id;let s=await this._getTenantId();return`${this.getHostUrl()}/o/${s}/projects/p/${r}/r/${t.id}?poll=true`}else if(e!==void 0){let r=await this.readRun(e);if(!r.app_path)throw new Error(`Run ${e} has no app_path`);return`${this.getHostUrl()}${r.app_path}`}else throw new Error("Must provide either runId or run")}async _loadChildRuns(e){let t=await _e(this.listRuns({id:e.child_run_ids})),i={},r={};t.sort((s,a)=>(s?.dotted_order??"").localeCompare(a?.dotted_order??""));for(let s of t){if(s.parent_run_id===null||s.parent_run_id===void 0)throw new Error(`Child run ${s.id} has no parent`);s.parent_run_id in i||(i[s.parent_run_id]=[]),i[s.parent_run_id].push(s),r[s.id]=s}e.child_runs=i[e.id]||[];for(let s in i)s!==e.id&&(r[s].child_runs=i[s]);return e}async*listRuns(e){let{projectId:t,projectName:i,parentRunId:r,traceId:s,referenceExampleId:a,startTime:n,executionOrder:u,isRoot:d,runType:l,error:c,id:h,query:m,filter:f,traceFilter:y,treeFilter:w,limit:g,select:R}=e,S=[];if(t&&(S=Array.isArray(t)?t:[t]),i){let b=Array.isArray(i)?i:[i],J=await Promise.all(b.map(ie=>this.readProject({projectName:ie}).then(re=>re.id)));S.push(...J)}let G=["app_path","child_run_ids","completion_cost","completion_tokens","dotted_order","end_time","error","events","extra","feedback_stats","first_token_time","id","inputs","name","outputs","parent_run_id","parent_run_ids","prompt_cost","prompt_tokens","reference_example_id","run_type","session_id","start_time","status","tags","total_cost","total_tokens","trace_id"],B={session:S.length?S:null,run_type:l,reference_example:a,query:m,filter:f,trace_filter:y,tree_filter:w,execution_order:u,parent_run:r,start_time:n?n.toISOString():null,error:c,id:h,limit:g,trace:s,select:R||G,is_root:d},$=0;for await(let b of this._getCursorPaginatedList("/runs/query",B))if(g){if($>=g)break;if(b.length+$>g){yield*b.slice(0,g-$);break}$+=b.length,yield*b}else yield*b}async getRunStats({id:e,trace:t,parentRun:i,runType:r,projectNames:s,projectIds:a,referenceExampleIds:n,startTime:u,endTime:d,error:l,query:c,filter:h,traceFilter:m,treeFilter:f,isRoot:y,dataSourceType:w}){let g=a||[];s&&(g=[...a||[],...await Promise.all(s.map($=>this.readProject({projectName:$}).then(b=>b.id)))]);let S=Object.fromEntries(Object.entries({id:e,trace:t,parent_run:i,run_type:r,session:g,reference_example:n,start_time:u,end_time:d,error:l,query:c,filter:h,trace_filter:m,tree_filter:f,is_root:y,data_source_type:w}).filter(([$,b])=>b!==void 0));return await(await this.caller.call(fetch,`${this.apiUrl}/runs/stats`,{method:"POST",headers:this.headers,body:JSON.stringify(S),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async shareRun(e,{shareId:t}={}){let i={run_id:e,share_token:t||M.v4()};p(e);let s=await(await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();if(s===null||!("share_token"in s))throw new Error("Invalid response from server");return`${this.getHostUrl()}/public/${s.share_token}/r`}async unshareRun(e){p(e);let t=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(t,"unshare run")}async readRunSharedLink(e){p(e);let i=await(await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();if(!(i===null||!("share_token"in i)))return`${this.getHostUrl()}/public/${i.share_token}/r`}async listSharedRuns(e,{runIds:t}={}){let i=new URLSearchParams({share_token:e});if(t!==void 0)for(let a of t)i.append("id",a);return p(e),await(await this.caller.call(fetch,`${this.apiUrl}/public/${e}/runs${i}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async readDatasetSharedSchema(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id),p(e);let r=await(await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();return r.url=`${this.getHostUrl()}/public/${r.share_token}/d`,r}async shareDataset(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id);let i={dataset_id:e};p(e);let s=await(await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json();return s.url=`${this.getHostUrl()}/public/${s.share_token}/d`,s}async unshareDataset(e){p(e);let t=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(t,"unshare dataset")}async readSharedDataset(e){return p(e),await(await this.caller.call(fetch,`${this.apiUrl}/public/${e}/datasets`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async createProject({projectName:e,description:t=null,metadata:i=null,upsert:r=!1,projectExtra:s=null,referenceDatasetId:a=null}){let n=r?"?upsert=true":"",u=`${this.apiUrl}/sessions${n}`,d=s||{};i&&(d.metadata=i);let l={name:e,extra:d,description:t};a!==null&&(l.reference_dataset_id=a);let c=await this.caller.call(fetch,u,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(l),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions}),h=await c.json();if(!c.ok)throw new Error(`Failed to create session ${e}: ${c.status} ${c.statusText}`);return h}async updateProject(e,{name:t=null,description:i=null,metadata:r=null,projectExtra:s=null,endTime:a=null}){let n=`${this.apiUrl}/sessions/${e}`,u=s;r&&(u={...u||{},metadata:r});let d={name:t,extra:u,description:i,end_time:a?new Date(a).toISOString():null},l=await this.caller.call(fetch,n,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(d),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions}),c=await l.json();if(!l.ok)throw new Error(`Failed to update project ${e}: ${l.status} ${l.statusText}`);return c}async hasProject({projectId:e,projectName:t}){let i="/sessions",r=new URLSearchParams;if(e!==void 0&&t!==void 0)throw new Error("Must provide either projectName or projectId, not both");if(e!==void 0)p(e),i+=`/${e}`;else if(t!==void 0)r.append("name",t);else throw new Error("Must provide projectName or projectId");let s=await this.caller.call(fetch,`${this.apiUrl}${i}?${r}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});try{let a=await s.json();return s.ok?Array.isArray(a)?a.length>0:!0:!1}catch{return!1}}async readProject({projectId:e,projectName:t,includeStats:i}){let r="/sessions",s=new URLSearchParams;if(e!==void 0&&t!==void 0)throw new Error("Must provide either projectName or projectId, not both");if(e!==void 0)p(e),r+=`/${e}`;else if(t!==void 0)s.append("name",t);else throw new Error("Must provide projectName or projectId");i!==void 0&&s.append("include_stats",i.toString());let a=await this._get(r,s),n;if(Array.isArray(a)){if(a.length===0)throw new Error(`Project[id=${e}, name=${t}] not found`);n=a[0]}else n=a;return n}async getProjectUrl({projectId:e,projectName:t}){if(e===void 0&&t===void 0)throw new Error("Must provide either projectName or projectId");let i=await this.readProject({projectId:e,projectName:t}),r=await this._getTenantId();return`${this.getHostUrl()}/o/${r}/projects/p/${i.id}`}async getDatasetUrl({datasetId:e,datasetName:t}){if(e===void 0&&t===void 0)throw new Error("Must provide either datasetName or datasetId");let i=await this.readDataset({datasetId:e,datasetName:t}),r=await this._getTenantId();return`${this.getHostUrl()}/o/${r}/datasets/${i.id}`}async _getTenantId(){if(this._tenantId!==null)return this._tenantId;let e=new URLSearchParams({limit:"1"});for await(let t of this._getPaginated("/sessions",e))return this._tenantId=t[0].tenant_id,t[0].tenant_id;throw new Error("No projects found to resolve tenant.")}async*listProjects({projectIds:e,name:t,nameContains:i,referenceDatasetId:r,referenceDatasetName:s,referenceFree:a}={}){let n=new URLSearchParams;if(e!==void 0)for(let u of e)n.append("id",u);if(t!==void 0&&n.append("name",t),i!==void 0&&n.append("name_contains",i),r!==void 0)n.append("reference_dataset",r);else if(s!==void 0){let u=await this.readDataset({datasetName:s});n.append("reference_dataset",u.id)}a!==void 0&&n.append("reference_free",a.toString());for await(let u of this._getPaginated("/sessions",n))yield*u}async deleteProject({projectId:e,projectName:t}){let i;if(e===void 0&&t===void 0)throw new Error("Must provide projectName or projectId");if(e!==void 0&&t!==void 0)throw new Error("Must provide either projectName or projectId, not both");e===void 0?i=(await this.readProject({projectName:t})).id:i=e,p(i);let r=await this.caller.call(fetch,`${this.apiUrl}/sessions/${i}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(r,`delete session ${i} (${t})`)}async uploadCsv({csvFile:e,fileName:t,inputKeys:i,outputKeys:r,description:s,dataType:a,name:n}){let u=`${this.apiUrl}/datasets/upload`,d=new FormData;d.append("file",e,t),i.forEach(h=>{d.append("input_keys",h)}),r.forEach(h=>{d.append("output_keys",h)}),s&&d.append("description",s),a&&d.append("data_type",a),n&&d.append("name",n);let l=await this.caller.call(fetch,u,{method:"POST",headers:this.headers,body:d,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!l.ok){let h=await l.json();throw h.detail&&h.detail.includes("already exists")?new Error(`Dataset ${t} already exists`):new Error(`Failed to upload CSV: ${l.status} ${l.statusText}`)}return await l.json()}async createDataset(e,{description:t,dataType:i}={}){let r={name:e,description:t};i&&(r.data_type=i);let s=await this.caller.call(fetch,`${this.apiUrl}/datasets`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!s.ok){let n=await s.json();throw n.detail&&n.detail.includes("already exists")?new Error(`Dataset ${e} already exists`):new Error(`Failed to create dataset ${s.status} ${s.statusText}`)}return await s.json()}async readDataset({datasetId:e,datasetName:t}){let i="/datasets",r=new URLSearchParams({limit:"1"});if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(e!==void 0)p(e),i+=`/${e}`;else if(t!==void 0)r.append("name",t);else throw new Error("Must provide datasetName or datasetId");let s=await this._get(i,r),a;if(Array.isArray(s)){if(s.length===0)throw new Error(`Dataset[id=${e}, name=${t}] not found`);a=s[0]}else a=s;return a}async hasDataset({datasetId:e,datasetName:t}){try{return await this.readDataset({datasetId:e,datasetName:t}),!0}catch(i){if(i instanceof Error&&i.message.toLocaleLowerCase().includes("not found"))return!1;throw i}}async diffDatasetVersions({datasetId:e,datasetName:t,fromVersion:i,toVersion:r}){let s=e;if(s===void 0&&t===void 0)throw new Error("Must provide either datasetName or datasetId");if(s!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");s===void 0&&(s=(await this.readDataset({datasetName:t})).id);let a=new URLSearchParams({from_version:typeof i=="string"?i:i.toISOString(),to_version:typeof r=="string"?r:r.toISOString()});return await this._get(`/datasets/${s}/versions/diff`,a)}async readDatasetOpenaiFinetuning({datasetId:e,datasetName:t}){let i="/datasets";if(e===void 0)if(t!==void 0)e=(await this.readDataset({datasetName:t})).id;else throw new Error("Must provide datasetName or datasetId");return(await(await this._getResponse(`${i}/${e}/openai_ft`)).text()).trim().split(`
`).map(n=>JSON.parse(n))}async*listDatasets({limit:e=100,offset:t=0,datasetIds:i,datasetName:r,datasetNameContains:s}={}){let a="/datasets",n=new URLSearchParams({limit:e.toString(),offset:t.toString()});if(i!==void 0)for(let u of i)n.append("id",u);r!==void 0&&n.append("name",r),s!==void 0&&n.append("name_contains",s);for await(let u of this._getPaginated(a,n))yield*u}async updateDataset(e){let{datasetId:t,datasetName:i,...r}=e;if(!t&&!i)throw new Error("Must provide either datasetName or datasetId");let s=t??(await this.readDataset({datasetName:i})).id;p(s);let a=await this.caller.call(fetch,`${this.apiUrl}/datasets/${s}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!a.ok)throw new Error(`Failed to update dataset ${s}: ${a.status} ${a.statusText}`);return await a.json()}async deleteDataset({datasetId:e,datasetName:t}){let i="/datasets",r=e;if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(t!==void 0&&(r=(await this.readDataset({datasetName:t})).id),r!==void 0)p(r),i+=`/${r}`;else throw new Error("Must provide datasetName or datasetId");let s=await this.caller.call(fetch,this.apiUrl+i,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!s.ok)throw new Error(`Failed to delete ${i}: ${s.status} ${s.statusText}`);await s.json()}async createExample(e,t,{datasetId:i,datasetName:r,createdAt:s,exampleId:a,metadata:n,split:u}){let d=i;if(d===void 0&&r===void 0)throw new Error("Must provide either datasetName or datasetId");if(d!==void 0&&r!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");d===void 0&&(d=(await this.readDataset({datasetName:r})).id);let c={dataset_id:d,inputs:e,outputs:t,created_at:(s||new Date)?.toISOString(),id:a,metadata:n,split:u},h=await this.caller.call(fetch,`${this.apiUrl}/examples`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(c),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!h.ok)throw new Error(`Failed to create example: ${h.status} ${h.statusText}`);return await h.json()}async createExamples(e){let{inputs:t,outputs:i,metadata:r,sourceRunIds:s,exampleIds:a,datasetId:n,datasetName:u}=e,d=n;if(d===void 0&&u===void 0)throw new Error("Must provide either datasetName or datasetId");if(d!==void 0&&u!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");d===void 0&&(d=(await this.readDataset({datasetName:u})).id);let l=t.map((m,f)=>({dataset_id:d,inputs:m,outputs:i?i[f]:void 0,metadata:r?r[f]:void 0,split:e.splits?e.splits[f]:void 0,id:a?a[f]:void 0,source_run_id:s?s[f]:void 0})),c=await this.caller.call(fetch,`${this.apiUrl}/examples/bulk`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(l),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!c.ok)throw new Error(`Failed to create examples: ${c.status} ${c.statusText}`);return await c.json()}async createLLMExample(e,t,i){return this.createExample({input:e},{output:t},i)}async createChatExample(e,t,i){let r=e.map(a=>k(a)?x(a):a),s=k(t)?x(t):t;return this.createExample({input:r},{output:s},i)}async readExample(e){p(e);let t=`/examples/${e}`;return await this._get(t)}async*listExamples({datasetId:e,datasetName:t,exampleIds:i,asOf:r,splits:s,inlineS3Urls:a,metadata:n,limit:u,offset:d,filter:l}={}){let c;if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");if(e!==void 0)c=e;else if(t!==void 0)c=(await this.readDataset({datasetName:t})).id;else throw new Error("Must provide a datasetName or datasetId");let h=new URLSearchParams({dataset:c}),m=r?typeof r=="string"?r:r?.toISOString():void 0;m&&h.append("as_of",m);let f=a??!0;if(h.append("inline_s3_urls",f.toString()),i!==void 0)for(let w of i)h.append("id",w);if(s!==void 0)for(let w of s)h.append("splits",w);if(n!==void 0){let w=JSON.stringify(n);h.append("metadata",w)}u!==void 0&&h.append("limit",u.toString()),d!==void 0&&h.append("offset",d.toString()),l!==void 0&&h.append("filter",l);let y=0;for await(let w of this._getPaginated("/examples",h)){for(let g of w)yield g,y++;if(u!==void 0&&y>=u)break}}async deleteExample(e){p(e);let t=`/examples/${e}`,i=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!i.ok)throw new Error(`Failed to delete ${t}: ${i.status} ${i.statusText}`);await i.json()}async updateExample(e,t){p(e);let i=await this.caller.call(fetch,`${this.apiUrl}/examples/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!i.ok)throw new Error(`Failed to update example ${e}: ${i.status} ${i.statusText}`);return await i.json()}async updateExamples(e){let t=await this.caller.call(fetch,`${this.apiUrl}/examples/bulk`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(e),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!t.ok)throw new Error(`Failed to update examples: ${t.status} ${t.statusText}`);return await t.json()}async listDatasetSplits({datasetId:e,datasetName:t,asOf:i}){let r;if(e===void 0&&t===void 0)throw new Error("Must provide dataset name or ID");if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");e===void 0?r=(await this.readDataset({datasetName:t})).id:r=e,p(r);let s=new URLSearchParams,a=i?typeof i=="string"?i:i?.toISOString():void 0;return a&&s.append("as_of",a),await this._get(`/datasets/${r}/splits`,s)}async updateDatasetSplits({datasetId:e,datasetName:t,splitName:i,exampleIds:r,remove:s=!1}){let a;if(e===void 0&&t===void 0)throw new Error("Must provide dataset name or ID");if(e!==void 0&&t!==void 0)throw new Error("Must provide either datasetName or datasetId, not both");e===void 0?a=(await this.readDataset({datasetName:t})).id:a=e,p(a);let n={split_name:i,examples:r.map(d=>(p(d),d)),remove:s},u=await this.caller.call(fetch,`${this.apiUrl}/datasets/${a}/splits`,{method:"PUT",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(n),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(u,"update dataset splits")}async evaluateRun(e,t,{sourceInfo:i,loadChildRuns:r,referenceExample:s}={loadChildRuns:!1}){A("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");let a;if(typeof e=="string")a=await this.readRun(e,{loadChildRuns:r});else if(typeof e=="object"&&"id"in e)a=e;else throw new Error(`Invalid run type: ${typeof e}`);a.reference_example_id!==null&&a.reference_example_id!==void 0&&(s=await this.readExample(a.reference_example_id));let n=await t.evaluateRun(a,s),[u,d]=await this._logEvaluationFeedback(n,a,i);return d[0]}async createFeedback(e,t,{score:i,value:r,correction:s,comment:a,sourceInfo:n,feedbackSourceType:u="api",sourceRunId:d,feedbackId:l,feedbackConfig:c,projectId:h,comparativeExperimentId:m}){if(!e&&!h)throw new Error("One of runId or projectId must be provided");if(e&&h)throw new Error("Only one of runId or projectId can be provided");let f={type:u??"api",metadata:n??{}};d!==void 0&&f?.metadata!==void 0&&!f.metadata.__run&&(f.metadata.__run={run_id:d}),f?.metadata!==void 0&&f.metadata.__run?.run_id!==void 0&&p(f.metadata.__run.run_id);let y={id:l??M.v4(),run_id:e,key:t,score:i,value:r,correction:s,comment:a,feedback_source:f,comparative_experiment_id:m,feedbackConfig:c,session_id:h},w=`${this.apiUrl}/feedback`,g=await this.caller.call(fetch,w,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(y),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await E(g,"create feedback"),y}async updateFeedback(e,{score:t,value:i,correction:r,comment:s}){let a={};t!=null&&(a.score=t),i!=null&&(a.value=i),r!=null&&(a.correction=r),s!=null&&(a.comment=s),p(e);let n=await this.caller.call(fetch,`${this.apiUrl}/feedback/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(a),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});await E(n,"update feedback")}async readFeedback(e){p(e);let t=`/feedback/${e}`;return await this._get(t)}async deleteFeedback(e){p(e);let t=`/feedback/${e}`,i=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!i.ok)throw new Error(`Failed to delete ${t}: ${i.status} ${i.statusText}`);await i.json()}async*listFeedback({runIds:e,feedbackKeys:t,feedbackSourceTypes:i}={}){let r=new URLSearchParams;if(e&&r.append("run",e.join(",")),t)for(let s of t)r.append("key",s);if(i)for(let s of i)r.append("source",s);for await(let s of this._getPaginated("/feedback",r))yield*s}async createPresignedFeedbackToken(e,t,{expiration:i,feedbackConfig:r}={}){let s={run_id:e,feedback_key:t,feedback_config:r};return i?typeof i=="string"?s.expires_at=i:(i?.hours||i?.minutes||i?.days)&&(s.expires_in=i):s.expires_in={hours:3},await(await this.caller.call(fetch,`${this.apiUrl}/feedback/tokens`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(s),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async createComparativeExperiment({name:e,experimentIds:t,referenceDatasetId:i,createdAt:r,description:s,metadata:a,id:n}){if(t.length===0)throw new Error("At least one experiment is required");if(i||(i=(await this.readProject({projectId:t[0]})).reference_dataset_id),!i==null)throw new Error("A reference dataset is required");let u={id:n,name:e,experiment_ids:t,reference_dataset_id:i,description:s,created_at:(r??new Date)?.toISOString(),extra:{}};return a&&(u.extra.metadata=a),await(await this.caller.call(fetch,`${this.apiUrl}/datasets/comparative`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(u),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async*listPresignedFeedbackTokens(e){p(e);let t=new URLSearchParams({run_id:e});for await(let i of this._getPaginated("/feedback/tokens",t))yield*i}_selectEvalResults(e){let t;return"results"in e?t=e.results:t=[e],t}async _logEvaluationFeedback(e,t,i){let r=this._selectEvalResults(e),s=[];for(let a of r){let n=i||{};a.evaluatorInfo&&(n={...a.evaluatorInfo,...n});let u=null;a.targetRunId?u=a.targetRunId:t&&(u=t.id),s.push(await this.createFeedback(u,a.key,{score:a.score,value:a.value,comment:a.comment,correction:a.correction,sourceInfo:n,sourceRunId:a.sourceRunId,feedbackConfig:a.feedbackConfig,feedbackSourceType:"model"}))}return[r,s]}async logEvaluationFeedback(e,t,i){let[r]=await this._logEvaluationFeedback(e,t,i);return r}async _currentTenantIsOwner(e){let t=await this._getSettings();return e=="-"||t.tenant_handle===e}async _ownerConflictError(e,t){let i=await this._getSettings();return new Error(`Cannot ${e} for another tenant.

      Current tenant: ${i.tenant_handle}

      Requested tenant: ${t}`)}async _getLatestCommitHash(e){let t=await this.caller.call(fetch,`${this.apiUrl}/commits/${e}/?limit=1&offset=0`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions}),i=await t.json();if(!t.ok){let r=typeof i.detail=="string"?i.detail:JSON.stringify(i.detail),s=new Error(`Error ${t.status}: ${t.statusText}
${r}`);throw s.statusCode=t.status,s}if(i.commits.length!==0)return i.commits[0].commit_hash}async _likeOrUnlikePrompt(e,t){let[i,r,s]=O(e),a=await this.caller.call(fetch,`${this.apiUrl}/likes/${i}/${r}`,{method:"POST",body:JSON.stringify({like:t}),headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!a.ok)throw new Error(`Failed to ${t?"like":"unlike"} prompt: ${a.status} ${await a.text()}`);return await a.json()}async _getPromptUrl(e){let[t,i,r]=O(e);if(await this._currentTenantIsOwner(t)){let s=await this._getSettings();return r!=="latest"?`${this.getHostUrl()}/prompts/${i}/${r.substring(0,8)}?organizationId=${s.id}`:`${this.getHostUrl()}/prompts/${i}?organizationId=${s.id}`}else return r!=="latest"?`${this.getHostUrl()}/hub/${t}/${i}/${r.substring(0,8)}`:`${this.getHostUrl()}/hub/${t}/${i}`}async promptExists(e){return!!await this.getPrompt(e)}async likePrompt(e){return this._likeOrUnlikePrompt(e,!0)}async unlikePrompt(e){return this._likeOrUnlikePrompt(e,!1)}async*listCommits(e){for await(let t of this._getPaginated(`/commits/${e}/`,{},i=>i.commits))yield*t}async*listPrompts(e){let t=new URLSearchParams;t.append("sort_field",e?.sortField??"updated_at"),t.append("sort_direction","desc"),t.append("is_archived",(!!e?.isArchived).toString()),e?.isPublic!==void 0&&t.append("is_public",e.isPublic.toString()),e?.query&&t.append("query",e.query);for await(let i of this._getPaginated("/repos",t,r=>r.repos))yield*i}async getPrompt(e){let[t,i,r]=O(e),s=await this.caller.call(fetch,`${this.apiUrl}/repos/${t}/${i}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(s.status===404)return null;if(!s.ok)throw new Error(`Failed to get prompt: ${s.status} ${await s.text()}`);let a=await s.json();return a.repo?a.repo:null}async createPrompt(e,t){let i=await this._getSettings();if(t?.isPublic&&!i.tenant_handle)throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);let[r,s,a]=O(e);if(!await this._currentTenantIsOwner(r))throw await this._ownerConflictError("create a prompt",r);let n={repo_handle:s,...t?.description&&{description:t.description},...t?.readme&&{readme:t.readme},...t?.tags&&{tags:t.tags},is_public:!!t?.isPublic},u=await this.caller.call(fetch,`${this.apiUrl}/repos/`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(n),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!u.ok)throw new Error(`Failed to create prompt: ${u.status} ${await u.text()}`);let{repo:d}=await u.json();return d}async createCommit(e,t,i){if(!await this.promptExists(e))throw new Error("Prompt does not exist, you must create it first.");let[r,s,a]=O(e),n=i?.parentCommitHash==="latest"||!i?.parentCommitHash?await this._getLatestCommitHash(`${r}/${s}`):i?.parentCommitHash,u={manifest:JSON.parse(JSON.stringify(t)),parent_commit:n},d=await this.caller.call(fetch,`${this.apiUrl}/commits/${r}/${s}`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(u),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!d.ok)throw new Error(`Failed to create commit: ${d.status} ${await d.text()}`);let l=await d.json();return this._getPromptUrl(`${r}/${s}${l.commit_hash?`:${l.commit_hash}`:""}`)}async updatePrompt(e,t){if(!await this.promptExists(e))throw new Error("Prompt does not exist, you must create it first.");let[i,r]=O(e);if(!await this._currentTenantIsOwner(i))throw await this._ownerConflictError("update a prompt",i);let s={};if(t?.description!==void 0&&(s.description=t.description),t?.readme!==void 0&&(s.readme=t.readme),t?.tags!==void 0&&(s.tags=t.tags),t?.isPublic!==void 0&&(s.is_public=t.isPublic),t?.isArchived!==void 0&&(s.is_archived=t.isArchived),Object.keys(s).length===0)throw new Error("No valid update options provided");let a=await this.caller.call(fetch,`${this.apiUrl}/repos/${i}/${r}`,{method:"PATCH",body:JSON.stringify(s),headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!a.ok)throw new Error(`HTTP Error: ${a.status} - ${await a.text()}`);return a.json()}async deletePrompt(e){if(!await this.promptExists(e))throw new Error("Prompt does not exist, you must create it first.");let[t,i,r]=O(e);if(!await this._currentTenantIsOwner(t))throw await this._ownerConflictError("delete a prompt",t);return await(await this.caller.call(fetch,`${this.apiUrl}/repos/${t}/${i}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions})).json()}async pullPromptCommit(e,t){let[i,r,s]=O(e),a=await this._getServerInfo(),n=Q(a.version,"0.5.23"),u=s;if(!n&&s==="latest"){let c=await this._getLatestCommitHash(`${i}/${r}`);if(c)u=c;else throw new Error("No commits found")}let d=await this.caller.call(fetch,`${this.apiUrl}/commits/${i}/${r}/${u}${t?.includeModel?"?include_model=true":""}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});if(!d.ok)throw new Error(`Failed to pull prompt commit: ${d.status} ${d.statusText}`);let l=await d.json();return{owner:i,repo:r,commit_hash:l.commit_hash,manifest:l.manifest,examples:l.examples}}async _pullPrompt(e,t){let i=await this.pullPromptCommit(e,{includeModel:t?.includeModel});return JSON.stringify(i.manifest)}async pushPrompt(e,t){return await this.promptExists(e)?await this.updatePrompt(e,{description:t?.description,readme:t?.readme,tags:t?.tags,isPublic:t?.isPublic}):await this.createPrompt(e,{description:t?.description,readme:t?.readme,tags:t?.tags,isPublic:t?.isPublic}),t?.object?await this.createCommit(e,t?.object,{parentCommitHash:t?.parentCommitHash}):await this._getPromptUrl(e)}};import*as ee from"/v135/uuid@9.0.1/denonext/uuid.mjs";var Z=o=>o!==void 0?o:!!["LANGSMITH_TRACING_V2","LANGCHAIN_TRACING_V2","LANGSMITH_TRACING","LANGCHAIN_TRACING"].find(t=>_(t)==="true");function be(o){return o.replace(/[-:.]/g,"")}function ye(o,e,t=1){let i=t.toFixed(0).slice(0,3).padStart(3,"0");return be(`${new Date(o).toISOString().slice(0,-1)}${i}Z`)+e}var I=class o{constructor(e,t){Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.metadata=e,this.tags=t}static fromHeader(e){let t=e.split(","),i={},r=[];for(let s of t){let[a,n]=s.split("="),u=decodeURIComponent(n);a==="langsmith-metadata"?i=JSON.parse(u):a==="langsmith-tags"&&(r=u.split(","))}return new o(i,r)}toHeader(){let e=[];return this.metadata&&Object.keys(this.metadata).length>0&&e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`),this.tags&&this.tags.length>0&&e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`),e.join(",")}},F=class o{constructor(e){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"run_type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"project_name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"parent_run",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"child_runs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"start_time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"end_time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extra",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"error",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"serialized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"reference_example_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"events",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"trace_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"dotted_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tracingEnabled",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"execution_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"child_execution_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let t=o.getDefaultConfig(),{metadata:i,...r}=e,s=r.client??new T,a={...i,...r?.extra?.metadata};if(r.extra={...r.extra,metadata:a},Object.assign(this,{...t,...r,client:s}),this.trace_id||(this.parent_run?this.trace_id=this.parent_run.trace_id??this.id:this.trace_id=this.id),this.execution_order??=1,this.child_execution_order??=1,!this.dotted_order){let n=ye(this.start_time,this.id,this.execution_order);this.parent_run?this.dotted_order=this.parent_run.dotted_order+"."+n:this.dotted_order=n}}static getDefaultConfig(){return{id:ee.v4(),run_type:"chain",project_name:_("LANGCHAIN_PROJECT")??_("LANGCHAIN_SESSION")??"default",child_runs:[],api_url:_("LANGCHAIN_ENDPOINT")??"http://localhost:1984",api_key:_("LANGCHAIN_API_KEY"),caller_options:{},start_time:Date.now(),serialized:{},inputs:{},extra:{}}}createChild(e){let t=this.child_execution_order+1,i=new o({...e,parent_run:this,project_name:this.project_name,client:this.client,tracingEnabled:this.tracingEnabled,execution_order:t,child_execution_order:t}),r=Symbol.for("lc:child_config"),s=e.extra?.[r]??this.extra[r];if(Oe(s)){let u={...s},d=ve(u.callbacks)?u.callbacks.copy?.():void 0;d&&(Object.assign(d,{_parentRunId:i.id}),d.handlers?.find(te)?.updateFromRunTree?.(i),u.callbacks=d),i.extra[r]=u}let a=new Set,n=this;for(;n!=null&&!a.has(n.id);)a.add(n.id),n.child_execution_order=Math.max(n.child_execution_order,t),n=n.parent_run;return this.child_runs.push(i),i}async end(e,t,i=Date.now()){this.outputs=this.outputs??e,this.error=this.error??t,this.end_time=this.end_time??i}_convertToCreate(e,t,i=!0){let r=e.extra??{};if(r.runtime||(r.runtime={}),t)for(let[u,d]of Object.entries(t))r.runtime[u]||(r.runtime[u]=d);let s,a;return i?(a=e.parent_run?.id,s=[]):(s=e.child_runs.map(u=>this._convertToCreate(u,t,i)),a=void 0),{id:e.id,name:e.name,start_time:e.start_time,end_time:e.end_time,run_type:e.run_type,reference_example_id:e.reference_example_id,extra:r,serialized:e.serialized,error:e.error,inputs:e.inputs,outputs:e.outputs,session_name:e.project_name,child_runs:s,parent_run_id:a,trace_id:e.trace_id,dotted_order:e.dotted_order,tags:e.tags}}async postRun(e=!0){let t=await C(),i=await this._convertToCreate(this,t,!0);if(await this.client.createRun(i),!e){A("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");for(let r of this.child_runs)await r.postRun(!1)}}async patchRun(){let e={end_time:this.end_time,error:this.error,inputs:this.inputs,outputs:this.outputs,parent_run_id:this.parent_run?.id,reference_example_id:this.reference_example_id,extra:this.extra,events:this.events,dotted_order:this.dotted_order,trace_id:this.trace_id,tags:this.tags};await this.client.updateRun(this.id,e)}toJSON(){return this._convertToCreate(this,void 0,!1)}static fromRunnableConfig(e,t){let i=e?.callbacks,r,s,a,n=Z();if(i){let d=i?.getParentRunId?.()??"",l=i?.handlers?.find(c=>c?.name=="langchain_tracer");r=l?.getRun?.(d),s=l?.projectName,a=l?.client,n=n||!!l}return r?new o({name:r.name,id:r.id,client:a,tracingEnabled:n,project_name:s,tags:[...new Set((r?.tags??[]).concat(e?.tags??[]))],extra:{metadata:{...r?.extra?.metadata,...e?.metadata}}}).createChild(t):new o({...t,client:a,tracingEnabled:n,project_name:s})}static fromDottedOrder(e){return this.fromHeaders({"langsmith-trace":e})}static fromHeaders(e,t){let i="get"in e&&typeof e.get=="function"?{"langsmith-trace":e.get("langsmith-trace"),baggage:e.get("baggage")}:e,r=i["langsmith-trace"];if(!r||typeof r!="string")return;let s=r.trim(),a=s.split(".").map(d=>{let[l,c]=d.split("Z");return{strTime:l,time:Date.parse(l+"Z"),uuid:c}}),n=a[0].uuid,u={...t,name:t?.name??"parent",run_type:t?.run_type??"chain",start_time:t?.start_time??Date.now(),id:a.at(-1)?.uuid,trace_id:n,dotted_order:s};if(i.baggage&&typeof i.baggage=="string"){let d=I.fromHeader(i.baggage);u.metadata=d.metadata,u.tags=d.tags}return new o(u)}toHeaders(e){let t={"langsmith-trace":this.dotted_order,baggage:new I(this.extra?.metadata,this.tags).toHeader()};if(e)for(let[i,r]of Object.entries(t))e.set(i,r);return t}};function te(o){return typeof o=="object"&&o!=null&&typeof o.name=="string"&&o.name==="langchain_tracer"}function X(o){return Array.isArray(o)&&o.some(e=>te(e))}function ve(o){return typeof o=="object"&&o!=null&&Array.isArray(o.handlers)}function Oe(o){return o!==void 0&&typeof o.callbacks=="object"&&(X(o.callbacks?.handlers)||X(o.callbacks))}var j="0.1.40";export{T as Client,F as RunTree,j as __version__};
//# sourceMappingURL=langsmith.mjs.map