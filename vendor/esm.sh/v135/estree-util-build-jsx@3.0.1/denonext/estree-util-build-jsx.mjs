/* esm.sh - esbuild bundle(estree-util-build-jsx@3.0.1) denonext production */
import{ok as j}from"/v135/devlop@1.1.0/denonext/devlop.mjs";import{name as J}from"/v135/estree-util-is-identifier-name@3.0.0/denonext/estree-util-is-identifier-name.mjs";import{walk as k}from"/v135/estree-walker@3.0.3/denonext/estree-walker.mjs";var S=/@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g;function X(e,s){let t=s||{},i=t.runtime==="automatic",n={},c={};k(e,{enter(a){if(a.type==="Program"){let l=a.comments||[],x=-1;for(;++x<l.length;){S.lastIndex=0;let p=S.exec(l[x].value);for(;p;)n[p[1]]=p[2],p=S.exec(l[x].value)}if(n.jsxRuntime)if(n.jsxRuntime==="automatic"){if(i=!0,n.jsx)throw new Error("Unexpected `@jsx` pragma w/ automatic runtime");if(n.jsxFrag)throw new Error("Unexpected `@jsxFrag` pragma w/ automatic runtime")}else if(n.jsxRuntime==="classic"){if(i=!1,n.jsxImportSource)throw new Error("Unexpected `@jsxImportSource` w/ classic runtime")}else throw new Error("Unexpected `jsxRuntime` `"+n.jsxRuntime+"`, expected `automatic` or `classic`")}},leave(a){if(a.type==="Program"){let r=[];if(c.fragment&&r.push({type:"ImportSpecifier",imported:{type:"Identifier",name:"Fragment"},local:{type:"Identifier",name:"_Fragment"}}),c.jsx&&r.push({type:"ImportSpecifier",imported:{type:"Identifier",name:"jsx"},local:{type:"Identifier",name:"_jsx"}}),c.jsxs&&r.push({type:"ImportSpecifier",imported:{type:"Identifier",name:"jsxs"},local:{type:"Identifier",name:"_jsxs"}}),c.jsxDEV&&r.push({type:"ImportSpecifier",imported:{type:"Identifier",name:"jsxDEV"},local:{type:"Identifier",name:"_jsxDEV"}}),r.length>0){let o=0;for(;o<a.body.length;){let u=a.body[o];if("directive"in u&&u.directive)o++;else break}a.body.splice(o,0,{type:"ImportDeclaration",specifiers:r,source:{type:"Literal",value:(n.jsxImportSource||t.importSource||"react")+(t.development?"/jsx-dev-runtime":"/jsx-runtime")}})}}if(a.type!=="JSXElement"&&a.type!=="JSXFragment")return;let l=[],x=-1;for(;++x<a.children.length;){let r=a.children[x];if(r.type==="JSXExpressionContainer")r.expression.type!=="JSXEmptyExpression"&&l.push(r.expression);else if(r.type==="JSXText"){let o=r.value.replace(/\t/g," ").replace(/ *(\r?\n|\r) */g,`
`).replace(/\n+/g,`
`).replace(/\n+$/,"").replace(/^\n+/,"").replace(/\n/g," ");if(o){let u={type:"Literal",value:o};g(r,u),l.push(u)}}else j(r.type!=="JSXElement"&&r.type!=="JSXFragment"&&r.type!=="JSXSpreadChild"),l.push(r)}let p,y=[],m=[],I;if(a.type==="JSXElement"){if(p=v(a.openingElement.name),p.type==="Identifier"&&/^[a-z]/.test(p.name)){let f={type:"Literal",value:p.name};g(p,f),p=f}let r,o=a.openingElement.attributes,u=-1;for(;++u<o.length;){let f=o[u];if(f.type==="JSXSpreadAttribute")f.argument.type==="ObjectExpression"?y.push(...f.argument.properties):y.push({type:"SpreadElement",argument:f.argument}),r=!0;else{let E=L(f);if(i&&E.key.type==="Identifier"&&E.key.name==="key"){if(r)throw new Error("Expected `key` to come before any spread expressions");let h=E.value;j(h.type!=="AssignmentPattern"&&h.type!=="ArrayPattern"&&h.type!=="ObjectPattern"&&h.type!=="RestElement"),I=h}else y.push(E)}}}else i?(c.fragment=!0,p={type:"Identifier",name:"_Fragment"}):p=w(n.jsxFrag||t.pragmaFrag||"React.Fragment");i?l.length>0&&y.push({type:"Property",key:{type:"Identifier",name:"children"},value:l.length>1?{type:"ArrayExpression",elements:l}:l[0],kind:"init",method:!1,shorthand:!1,computed:!1}):m=l;let d;if(i){m.push({type:"ObjectExpression",properties:y}),I?m.push(I):t.development&&m.push({type:"Identifier",name:"undefined"});let r=l.length>1;if(t.development){c.jsxDEV=!0,d={type:"Identifier",name:"_jsxDEV"},m.push({type:"Literal",value:r});let o={type:"ObjectExpression",properties:[{type:"Property",method:!1,shorthand:!1,computed:!1,kind:"init",key:{type:"Identifier",name:"fileName"},value:{type:"Literal",value:t.filePath||"<source.js>"}}]};a.loc&&o.properties.push({type:"Property",method:!1,shorthand:!1,computed:!1,kind:"init",key:{type:"Identifier",name:"lineNumber"},value:{type:"Literal",value:a.loc.start.line}},{type:"Property",method:!1,shorthand:!1,computed:!1,kind:"init",key:{type:"Identifier",name:"columnNumber"},value:{type:"Literal",value:a.loc.start.column+1}}),m.push(o,{type:"ThisExpression"})}else r?(c.jsxs=!0,d={type:"Identifier",name:"_jsxs"}):(c.jsx=!0,d={type:"Identifier",name:"_jsx"})}else y.length>0?m.unshift({type:"ObjectExpression",properties:y}):m.length>0&&m.unshift({type:"Literal",value:null}),d=w(n.jsx||t.pragma||"React.createElement");m.unshift(p);let b={type:"CallExpression",callee:d,arguments:m,optional:!1};g(a,b),this.replace(b)}})}function L(e){let s;if(e.value)if(e.value.type==="JSXExpressionContainer"){let i=e.value.expression;j(i.type!=="JSXEmptyExpression","`JSXEmptyExpression` is not allowed in props."),s=i}else{let i=e.value;j(i.type!=="JSXElement"&&i.type!=="JSXFragment","JSX{Element,Fragment} are already compiled to `CallExpression`"),s=i,delete s.raw}else s={type:"Literal",value:!0};let t={type:"Property",key:v(e.name),value:s,kind:"init",method:!1,shorthand:!1,computed:!1};return g(e,t),t}function v(e){let s;if(e.type==="JSXMemberExpression"){let t=v(e.property);s={type:"MemberExpression",object:v(e.object),property:t,computed:t.type==="Literal",optional:!1}}else e.type==="JSXNamespacedName"?s={type:"Literal",value:e.namespace.name+":"+e.name.name}:s=J(e.name)?{type:"Identifier",name:e.name}:{type:"Literal",value:e.name};return g(e,s),s}function w(e){let s=e.split("."),t=-1,i;for(;++t<s.length;){let n=J(s[t])?{type:"Identifier",name:s[t]}:{type:"Literal",value:s[t]};i=i?{type:"MemberExpression",object:i,property:n,computed:!!(t&&n.type==="Literal"),optional:!1}:n}return j(i,"always a result"),i}function g(e,s){let t=["start","end","loc","range","comments"],i=-1;for(;++i<t.length;){let n=t[i];n in e&&(s[n]=e[n])}}export{X as buildJsx};
//# sourceMappingURL=estree-util-build-jsx.mjs.map